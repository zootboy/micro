; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--debug -c --asm --interleave -o.\Obj\fs_fat.o --depend=.\Obj\fs_fat.d --cpu=Cortex-M3 --apcs=interwork -O3 -I.\FlashFS -Id:\Keil\ARM\INC -Id:\Keil\ARM\INC\NXP\LPC17xx --omf_browse=.\Obj\fs_fat.crf FlashFS\fs_fat.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  cache_fat PROC
;;;1586   
;;;1587   static BOOL cache_fat (U32 sect) {
000000  b570              PUSH     {r4-r6,lr}
;;;1588     /* Handle MC FAT Cache. Read/write a 512 byte FAT sector. */
;;;1589   
;;;1590     if (sect == fat.sect) {
000002  4cf9              LDR      r4,|L1.1000|
000004  4605              MOV      r5,r0                 ;1587
000006  6820              LDR      r0,[r4,#0]  ; fat
000008  42a8              CMP      r0,r5
00000a  d017              BEQ      |L1.60|
;;;1591       /* Required sector already in buffer. */
;;;1592       return (__TRUE);
;;;1593     }
;;;1594     if (fat.dirty == __TRUE) {
00000c  7a21              LDRB     r1,[r4,#8]  ; fat
00000e  2901              CMP      r1,#1
000010  d107              BNE      |L1.34|
;;;1595       /* Current FAT sector has been changed, write it first. */
;;;1596       EX(mmc_write_sect (fat.sect, fat.buf, 1),__FALSE);
000012  2201              MOVS     r2,#1
000014  6861              LDR      r1,[r4,#4]  ; fat
000016  f7fffffe          BL       mmc_write_sect
00001a  2800              CMP      r0,#0
00001c  d00d              BEQ      |L1.58|
;;;1597       fat.dirty = __FALSE;
00001e  2000              MOVS     r0,#0
000020  7220              STRB     r0,[r4,#8]
                  |L1.34|
;;;1598     }
;;;1599     if (sect == 0) {
000022  b15d              CBZ      r5,|L1.60|
;;;1600       /* Only write if sector updated. */
;;;1601       return (__TRUE);
;;;1602     }
;;;1603     if (mmc_read_sect (sect, fat.buf, 1) == __TRUE) {
000024  2201              MOVS     r2,#1
000026  4628              MOV      r0,r5
000028  6861              LDR      r1,[r4,#4]  ; fat
00002a  f7fffffe          BL       mmc_read_sect
00002e  2801              CMP      r0,#1
000030  d006              BEQ      |L1.64|
;;;1604       fat.sect = sect;
;;;1605       return (__TRUE);
;;;1606     }
;;;1607     fat.sect = INVAL_SECT;
000032  f04f30ff          MOV      r0,#0xffffffff
;;;1608     return (__FALSE);
000036  6020              STR      r0,[r4,#0]  ; fat
000038  2000              MOVS     r0,#0
                  |L1.58|
;;;1609   }
00003a  bd70              POP      {r4-r6,pc}
                  |L1.60|
00003c  2001              MOVS     r0,#1                 ;1601
00003e  bd70              POP      {r4-r6,pc}
                  |L1.64|
000040  6025              STR      r5,[r4,#0]            ;1605  ; fat
000042  e7fb              B        |L1.60|
;;;1610   
                          ENDP

                  get_fat_sect PROC
;;;1434   
;;;1435   static U32 get_fat_sect (U32 clus) {
000044  49e8              LDR      r1,|L1.1000|
;;;1436     /* Calculate absolute FAT Sector address from cluster address. */
;;;1437     U32 fats;
;;;1438   
;;;1439     switch (mmc.FatType) {
000046  3120              ADDS     r1,r1,#0x20
000048  790a              LDRB     r2,[r1,#4]  ; mmc
00004a  2a01              CMP      r2,#1
00004c  d004              BEQ      |L1.88|
00004e  2a02              CMP      r2,#2
000050  d006              BEQ      |L1.96|
000052  2a03              CMP      r2,#3
000054  d10a              BNE      |L1.108|
000056  e005              B        |L1.100|
                  |L1.88|
;;;1440       case FS_FAT12:
;;;1441         /* FAT Cluster width 12 bits. */
;;;1442         fats = (clus * 3) / 1024;
000058  eb000040          ADD      r0,r0,r0,LSL #1
00005c  0a80              LSRS     r0,r0,#10
;;;1443         break;
00005e  e002              B        |L1.102|
                  |L1.96|
;;;1444   
;;;1445       case FS_FAT16:
;;;1446         /* FAT Cluster width 16 bits. */
;;;1447         fats = clus / 256;
000060  0a00              LSRS     r0,r0,#8
;;;1448         break;
000062  e000              B        |L1.102|
                  |L1.100|
;;;1449   
;;;1450       case FS_FAT32:
;;;1451         /* FAT Cluster width 32 bits. */
;;;1452         fats = clus / 128;
000064  09c0              LSRS     r0,r0,#7
                  |L1.102|
;;;1453         break;
;;;1454   
;;;1455       default:
;;;1456         /* Not supported. */
;;;1457         return (0);
;;;1458     }
;;;1459     if (fats >= mmc.FatSize) {
000066  890a              LDRH     r2,[r1,#8]  ; mmc
000068  4282              CMP      r2,r0
00006a  d801              BHI      |L1.112|
                  |L1.108|
;;;1460       return (0);
00006c  2000              MOVS     r0,#0
;;;1461     }
;;;1462     fats += (mmc.BootRecSec + mmc.RsvdSecCnt);
;;;1463     return (fats);
;;;1464   }
00006e  4770              BX       lr
                  |L1.112|
000070  680a              LDR      r2,[r1,#0]            ;1462  ; mmc
000072  8949              LDRH     r1,[r1,#0xa]          ;1462  ; mmc
000074  4411              ADD      r1,r1,r2              ;1462
000076  4408              ADD      r0,r0,r1              ;1462
000078  4770              BX       lr
;;;1465   
                          ENDP

                  count_free_clus PROC
;;;1349   
;;;1350   static U32 count_free_clus (void) {
00007a  e92d47f0          PUSH     {r4-r10,lr}
;;;1351     /* Scan FAT table and Count number of free clusters. */
;;;1352     U32 clus,sect,ofs,next,nfree;
;;;1353   
;;;1354     nfree = 0;
;;;1355     if (mmc.FatType == FS_FAT12) {
00007e  4cda              LDR      r4,|L1.1000|
000080  2500              MOVS     r5,#0                 ;1354
000082  3420              ADDS     r4,r4,#0x20
;;;1356       for (clus = 2; clus < (mmc.DataClusCnt + 2); clus++) {
;;;1357         /* Read a part of FAT table to buffer. */
;;;1358         sect = get_fat_sect (clus);
;;;1359         EX(cache_fat (sect),nfree);
;;;1360         ofs  = ((clus * 3) / 2) & 0x1FF;
;;;1361         if (ofs < 511) {
;;;1362           next = get_u16 (&fat.buf[ofs]);
000084  4ed8              LDR      r6,|L1.1000|
000086  7920              LDRB     r0,[r4,#4]            ;1355  ; mmc
000088  2801              CMP      r0,#1                 ;1355
00008a  d006              BEQ      |L1.154|
;;;1363         }
;;;1364         else {
;;;1365           /* This cluster spans on two sectors in the FAT. */
;;;1366           next = fat.buf[511];
;;;1367           EX(cache_fat (sect+1),nfree);
;;;1368           next |= fat.buf[0] << 8;
;;;1369         }
;;;1370         if (clus & 0x001) {
;;;1371           next >>= 4;
;;;1372         }
;;;1373         else {
;;;1374           next &= 0xFFF;
;;;1375         }
;;;1376         if (next == 0) {
;;;1377           nfree++;
;;;1378         }
;;;1379       }
;;;1380       return (nfree);
;;;1381     }
;;;1382     if (mmc.FatType == FS_FAT16) {
00008c  2802              CMP      r0,#2
00008e  d032              BEQ      |L1.246|
;;;1383       sect = get_fat_sect (2);
;;;1384       EX(cache_fat (sect),nfree);
;;;1385       for (clus = 2; clus < (mmc.DataClusCnt + 2); clus++) {
;;;1386         if ((clus & 0xFF) == 0) {
;;;1387           /* Read a part of FAT table to buffer. */
;;;1388           sect++;
;;;1389           EX(cache_fat (sect),nfree);
;;;1390         }
;;;1391         /* if 'next' == 0 (LE or BE) */
;;;1392         if (((U16 *)fat.buf)[clus & 0xFF] == 0) {
;;;1393           nfree++;
;;;1394         }
;;;1395       }
;;;1396       return (nfree);
;;;1397     }
;;;1398     if (mmc.FatType == FS_FAT32) {
000090  2803              CMP      r0,#3
000092  d04e              BEQ      |L1.306|
;;;1399       sect = get_fat_sect (2);
;;;1400       EX(cache_fat (sect),nfree);
;;;1401       for (clus = 2; clus < (mmc.DataClusCnt + 2); clus++) {
;;;1402         if ((clus & 0x7F) == 0) {
;;;1403           /* Read a part of FAT table to buffer. */
;;;1404           sect++;
;;;1405           EX(cache_fat (sect),nfree);
;;;1406         }
;;;1407         /* if 'next' == 0 (LE or BE) */
;;;1408         if (((U32 *)fat.buf)[clus & 0x7F] == 0) {
;;;1409           nfree++;
;;;1410         }
;;;1411       }
;;;1412       return (nfree);
;;;1413     }
;;;1414     return (0);
000094  2000              MOVS     r0,#0
                  |L1.150|
;;;1415   }
000096  e8bd87f0          POP      {r4-r10,pc}
                  |L1.154|
00009a  2702              MOVS     r7,#2                 ;1356
00009c  e026              B        |L1.236|
                  |L1.158|
00009e  4638              MOV      r0,r7                 ;1358
0000a0  f7fffffe          BL       get_fat_sect
0000a4  4681              MOV      r9,r0                 ;1358
0000a6  f7fffffe          BL       cache_fat
0000aa  b318              CBZ      r0,|L1.244|
0000ac  eb070047          ADD      r0,r7,r7,LSL #1       ;1360
0000b0  f3c00048          UBFX     r0,r0,#1,#9           ;1360
0000b4  f5b07fff          CMP      r0,#0x1fe             ;1361
0000b8  d803              BHI      |L1.194|
0000ba  6871              LDR      r1,[r6,#4]            ;1362  ; fat
0000bc  4408              ADD      r0,r0,r1              ;1362
0000be  8800              LDRH     r0,[r0,#0]            ;1362
0000c0  e00b              B        |L1.218|
                  |L1.194|
0000c2  6870              LDR      r0,[r6,#4]            ;1366  ; fat
0000c4  f89081ff          LDRB     r8,[r0,#0x1ff]        ;1366
0000c8  f1090001          ADD      r0,r9,#1              ;1367
0000cc  f7fffffe          BL       cache_fat
0000d0  b180              CBZ      r0,|L1.244|
0000d2  6870              LDR      r0,[r6,#4]            ;1368  ; fat
0000d4  7801              LDRB     r1,[r0,#0]            ;1368
0000d6  ea482001          ORR      r0,r8,r1,LSL #8       ;1368
                  |L1.218|
0000da  07f9              LSLS     r1,r7,#31             ;1370
0000dc  d001              BEQ      |L1.226|
0000de  0900              LSRS     r0,r0,#4              ;1371
0000e0  e001              B        |L1.230|
                  |L1.226|
0000e2  f3c0000b          UBFX     r0,r0,#0,#12          ;1374
                  |L1.230|
0000e6  b900              CBNZ     r0,|L1.234|
0000e8  1c6d              ADDS     r5,r5,#1              ;1377
                  |L1.234|
0000ea  1c7f              ADDS     r7,r7,#1              ;1356
                  |L1.236|
0000ec  69a0              LDR      r0,[r4,#0x18]         ;1356  ; mmc
0000ee  1c80              ADDS     r0,r0,#2              ;1356
0000f0  42b8              CMP      r0,r7                 ;1356
0000f2  d8d4              BHI      |L1.158|
                  |L1.244|
0000f4  e03a              B        |L1.364|
                  |L1.246|
0000f6  2002              MOVS     r0,#2                 ;1383
0000f8  f7fffffe          BL       get_fat_sect
0000fc  4680              MOV      r8,r0                 ;1383
0000fe  f7fffffe          BL       cache_fat
000102  b398              CBZ      r0,|L1.364|
000104  2702              MOVS     r7,#2                 ;1385
000106  e00f              B        |L1.296|
                  |L1.264|
000108  f0170fff          TST      r7,#0xff              ;1386
00010c  d105              BNE      |L1.282|
00010e  f1080001          ADD      r0,r8,#1              ;1388
000112  4680              MOV      r8,r0                 ;1388
000114  f7fffffe          BL       cache_fat
000118  b340              CBZ      r0,|L1.364|
                  |L1.282|
00011a  6870              LDR      r0,[r6,#4]            ;1392  ; fat
00011c  b2f9              UXTB     r1,r7                 ;1392
00011e  f8300011          LDRH     r0,[r0,r1,LSL #1]     ;1392
000122  b900              CBNZ     r0,|L1.294|
000124  1c6d              ADDS     r5,r5,#1              ;1393
                  |L1.294|
000126  1c7f              ADDS     r7,r7,#1              ;1385
                  |L1.296|
000128  69a0              LDR      r0,[r4,#0x18]         ;1385  ; mmc
00012a  1c80              ADDS     r0,r0,#2              ;1385
00012c  42b8              CMP      r0,r7                 ;1385
00012e  d8eb              BHI      |L1.264|
000130  e01c              B        |L1.364|
                  |L1.306|
000132  2002              MOVS     r0,#2                 ;1399
000134  f7fffffe          BL       get_fat_sect
000138  4680              MOV      r8,r0                 ;1399
00013a  f7fffffe          BL       cache_fat
00013e  b1a8              CBZ      r0,|L1.364|
000140  2702              MOVS     r7,#2                 ;1401
000142  e00f              B        |L1.356|
                  |L1.324|
000144  0678              LSLS     r0,r7,#25             ;1402
000146  d105              BNE      |L1.340|
000148  f1080001          ADD      r0,r8,#1              ;1404
00014c  4680              MOV      r8,r0                 ;1404
00014e  f7fffffe          BL       cache_fat
000152  b158              CBZ      r0,|L1.364|
                  |L1.340|
000154  6870              LDR      r0,[r6,#4]            ;1408  ; fat
000156  f007017f          AND      r1,r7,#0x7f           ;1408
00015a  f8500021          LDR      r0,[r0,r1,LSL #2]     ;1408
00015e  b900              CBNZ     r0,|L1.354|
000160  1c6d              ADDS     r5,r5,#1              ;1409
                  |L1.354|
000162  1c7f              ADDS     r7,r7,#1              ;1401
                  |L1.356|
000164  69a0              LDR      r0,[r4,#0x18]         ;1401  ; mmc
000166  1c80              ADDS     r0,r0,#2              ;1401
000168  42b8              CMP      r0,r7                 ;1401
00016a  d8eb              BHI      |L1.324|
                  |L1.364|
00016c  4628              MOV      r0,r5                 ;1412
00016e  e792              B        |L1.150|
;;;1416   
                          ENDP

                  read_sector PROC
;;;1468   
;;;1469   static BOOL read_sector (U32 sect) {
000170  b570              PUSH     {r4-r6,lr}
;;;1470     /* Read a 512 byte sector from Flash Card. */
;;;1471   
;;;1472     if (sect == ca.sect) {
000172  4d9d              LDR      r5,|L1.1000|
000174  4604              MOV      r4,r0                 ;1469
000176  350c              ADDS     r5,r5,#0xc
000178  6828              LDR      r0,[r5,#0]  ; ca
00017a  42a0              CMP      r0,r4
00017c  d101              BNE      |L1.386|
                  |L1.382|
;;;1473       /* Required sector already in buffer. */
;;;1474       return (__TRUE);
00017e  2001              MOVS     r0,#1
;;;1475     }
;;;1476   
;;;1477     if (sect >= ca.csect && sect < (ca.csect + ca.nwr)) {
;;;1478       /* This sector is in write cache buffer. */
;;;1479       memcpy (ca.buf, ca.cbuf + (sect - ca.csect) * 512, 512);
;;;1480       ca.sect = sect;
;;;1481       return (__TRUE);
;;;1482     }
;;;1483   
;;;1484     /* Sector not in cache, read it from the Memory Card. */
;;;1485     if (mmc_read_sect (sect, ca.buf, 1) == __TRUE) {
;;;1486       ca.sect = sect;
;;;1487       return (__TRUE);
;;;1488     }
;;;1489     ca.sect = INVAL_SECT;
;;;1490     return (__FALSE);
;;;1491   }
000180  bd70              POP      {r4-r6,pc}
                  |L1.386|
000182  4899              LDR      r0,|L1.1000|
000184  6869              LDR      r1,[r5,#4]            ;1479  ; ca
000186  300c              ADDS     r0,r0,#0xc            ;1472
000188  42a1              CMP      r1,r4                 ;1477
00018a  6880              LDR      r0,[r0,#8]            ;1479
00018c  d80c              BHI      |L1.424|
00018e  7c2a              LDRB     r2,[r5,#0x10]         ;1477  ; ca
000190  440a              ADD      r2,r2,r1              ;1477
000192  42a2              CMP      r2,r4                 ;1477
000194  d908              BLS      |L1.424|
000196  68ea              LDR      r2,[r5,#0xc]          ;1479  ; ca
000198  1a61              SUBS     r1,r4,r1              ;1479
00019a  eb022141          ADD      r1,r2,r1,LSL #9       ;1479
00019e  f44f7200          MOV      r2,#0x200             ;1479
0001a2  f7fffffe          BL       __aeabi_memcpy
0001a6  e00b              B        |L1.448|
                  |L1.424|
0001a8  4601              MOV      r1,r0                 ;1485
0001aa  2201              MOVS     r2,#1                 ;1485
0001ac  4620              MOV      r0,r4                 ;1485
0001ae  f7fffffe          BL       mmc_read_sect
0001b2  2801              CMP      r0,#1                 ;1485
0001b4  d004              BEQ      |L1.448|
0001b6  f04f30ff          MOV      r0,#0xffffffff        ;1489
0001ba  6028              STR      r0,[r5,#0]            ;1490  ; ca
0001bc  2000              MOVS     r0,#0                 ;1490
0001be  bd70              POP      {r4-r6,pc}
                  |L1.448|
0001c0  602c              STR      r4,[r5,#0]            ;1487  ; ca
0001c2  e7dc              B        |L1.382|
;;;1492   
                          ENDP

                  get_bootrec PROC
;;;1682   
;;;1683   static BOOL get_bootrec (void) {
0001c4  b570              PUSH     {r4-r6,lr}
;;;1684     /* Read Volume Boot Record info. */
;;;1685   
;;;1686     EX(read_sector (mmc.BootRecSec),__FALSE);
0001c6  4c88              LDR      r4,|L1.1000|
0001c8  3420              ADDS     r4,r4,#0x20
0001ca  6820              LDR      r0,[r4,#0]  ; mmc
0001cc  f7fffffe          BL       read_sector
0001d0  2800              CMP      r0,#0
0001d2  d009              BEQ      |L1.488|
;;;1687   
;;;1688     /* Check Executable Marker. */
;;;1689     if (get_u16 (&ca.buf[510]) != 0xAA55) {
0001d4  f1a40514          SUB      r5,r4,#0x14
0001d8  68a8              LDR      r0,[r5,#8]  ; ca
0001da  f8b011fe          LDRH     r1,[r0,#0x1fe]
0001de  f5a1422a          SUB      r2,r1,#0xaa00
0001e2  3a55              SUBS     r2,r2,#0x55
0001e4  d001              BEQ      |L1.490|
;;;1690       /* Invalid Master Boot Record. */
;;;1691       return (__FALSE);
0001e6  2000              MOVS     r0,#0
                  |L1.488|
;;;1692     }
;;;1693     /* Set Volume Parameter Info. */
;;;1694     mmc.SecPerClus = ca.buf[13];
;;;1695     mmc.BytesPerSec= get_u16 (&ca.buf[11]);
;;;1696     mmc.RsvdSecCnt = get_u16 (&ca.buf[14]);
;;;1697     mmc.NumOfFat   = ca.buf[16];
;;;1698     mmc.RootEntCnt = get_u16 (&ca.buf[17]);
;;;1699     mmc.DskSize    = get_u16 (&ca.buf[19]);
;;;1700     mmc.FatSize    = get_u16 (&ca.buf[22]);
;;;1701   
;;;1702     if ((mmc.DskSize == 0) && (mmc.FatSize == 0)) {
;;;1703       /* Read or correct specific data in mmc structure for FAT32. */
;;;1704       mmc.FAT32_ExtFlags  = get_u16 (&ca.buf[40]);
;;;1705       mmc.FAT32_RootClus  = get_u32 (&ca.buf[44]);
;;;1706       mmc.FAT32_FSInfo    = get_u16 (&ca.buf[48]);
;;;1707       mmc.FAT32_BkBootSec = get_u16 (&ca.buf[50]);
;;;1708     }
;;;1709   
;;;1710     if (mmc.DskSize == 0) {
;;;1711       /* If num of sectors > 0xFFFF, this field is nonzero. */
;;;1712       mmc.DskSize = get_u32 (&ca.buf[32]);
;;;1713     }
;;;1714   
;;;1715     if (mmc.FatSize == 0) {
;;;1716       /* Fat size is in this field for FAT32. */
;;;1717       mmc.FatSize = get_u32 (&ca.buf[36]);
;;;1718     }
;;;1719   
;;;1720     return (__TRUE);
;;;1721   }
0001e8  bd70              POP      {r4-r6,pc}
                  |L1.490|
0001ea  7b41              LDRB     r1,[r0,#0xd]          ;1694
0001ec  71a1              STRB     r1,[r4,#6]            ;1694
0001ee  f8b0100b          LDRH     r1,[r0,#0xb]          ;1694
0001f2  82e1              STRH     r1,[r4,#0x16]         ;1695
0001f4  89c1              LDRH     r1,[r0,#0xe]          ;1695
0001f6  8161              STRH     r1,[r4,#0xa]          ;1696
0001f8  7c01              LDRB     r1,[r0,#0x10]         ;1697
0001fa  7161              STRB     r1,[r4,#5]            ;1697
0001fc  f8b01011          LDRH     r1,[r0,#0x11]         ;1697
000200  82a1              STRH     r1,[r4,#0x14]         ;1698
000202  f8b01013          LDRH     r1,[r0,#0x13]         ;1698
000206  60e1              STR      r1,[r4,#0xc]          ;1698  ; mmc
000208  8ac2              LDRH     r2,[r0,#0x16]         ;1698
00020a  8122              STRH     r2,[r4,#8]            ;1700
00020c  b999              CBNZ     r1,|L1.566|
00020e  b96a              CBNZ     r2,|L1.556|
000210  8d01              LDRH     r1,[r0,#0x28]         ;1702
000212  84e1              STRH     r1,[r4,#0x26]         ;1704
000214  302c              ADDS     r0,r0,#0x2c           ;1705
000216  f7fffffe          BL       get_u32
00021a  62a0              STR      r0,[r4,#0x28]         ;1706  ; mmc
00021c  68a9              LDR      r1,[r5,#8]            ;1706  ; ca
00021e  4608              MOV      r0,r1                 ;1706
000220  8e09              LDRH     r1,[r1,#0x30]         ;1706
000222  85a1              STRH     r1,[r4,#0x2c]         ;1706
000224  8e40              LDRH     r0,[r0,#0x32]         ;1706
000226  85e0              STRH     r0,[r4,#0x2e]         ;1707
000228  68e0              LDR      r0,[r4,#0xc]          ;1710  ; mmc
00022a  b920              CBNZ     r0,|L1.566|
                  |L1.556|
00022c  68a8              LDR      r0,[r5,#8]            ;1712  ; ca
00022e  3020              ADDS     r0,r0,#0x20           ;1712
000230  f7fffffe          BL       get_u32
000234  60e0              STR      r0,[r4,#0xc]          ;1712  ; mmc
                  |L1.566|
000236  8920              LDRH     r0,[r4,#8]            ;1715  ; mmc
000238  b920              CBNZ     r0,|L1.580|
00023a  68a8              LDR      r0,[r5,#8]            ;1717  ; ca
00023c  3024              ADDS     r0,r0,#0x24           ;1717
00023e  f7fffffe          BL       get_u32
000242  8120              STRH     r0,[r4,#8]            ;1717
                  |L1.580|
000244  2001              MOVS     r0,#1                 ;1720
000246  bd70              POP      {r4-r6,pc}
;;;1722   
                          ENDP

                  init_dev PROC
;;;135    
;;;136    static int init_dev (void) {
000248  e92d41f0          PUSH     {r4-r8,lr}
;;;137      U32 root_scnt;
;;;138    
;;;139      /* Invalidate Cached Sectors. */
;;;140      fat.sect = INVAL_SECT;
00024c  4866              LDR      r0,|L1.1000|
;;;141      fat.buf  = (U8 *)&mc_cache[0];
00024e  4967              LDR      r1,|L1.1004|
000250  f04f36ff          MOV      r6,#0xffffffff        ;140
;;;142      fat.dirty= __FALSE;
000254  e9c06100          STRD     r6,r1,[r0,#0]
000258  2500              MOVS     r5,#0
00025a  7205              STRB     r5,[r0,#8]
;;;143    
;;;144      ca.sect  = INVAL_SECT;
00025c  300c              ADDS     r0,r0,#0xc
;;;145      ca.buf   = (U8 *)&mc_cache[128];
00025e  f5017100          ADD      r1,r1,#0x200
;;;146      ca.cbuf  = (U8 *)&mc_cache[256];
000262  6006              STR      r6,[r0,#0]  ; ca
000264  6081              STR      r1,[r0,#8]  ; ca
000266  f5017100          ADD      r1,r1,#0x200
;;;147      ca.nwr   = 0;
00026a  60c1              STR      r1,[r0,#0xc]  ; ca
00026c  7405              STRB     r5,[r0,#0x10]
;;;148      ca.nrd   = 0;
;;;149    
;;;150      /* First 2 clusters are always reserved. */
;;;151      top_clus = 2;
00026e  4c60              LDR      r4,|L1.1008|
000270  7445              STRB     r5,[r0,#0x11]         ;148
000272  f04f0802          MOV      r8,#2
;;;152    
;;;153      /* Clear MMC info record. */
;;;154      memset (&mmc, 0, sizeof (mmc));
000276  2130              MOVS     r1,#0x30
000278  3014              ADDS     r0,r0,#0x14
00027a  f8c4800c          STR      r8,[r4,#0xc]  ; top_clus
00027e  f7fffffe          BL       __aeabi_memclr4
;;;155    
;;;156      if (get_mbrec () == __FALSE) {
000282  f7fffffe          BL       get_mbrec
000286  b350              CBZ      r0,|L1.734|
;;;157        /* Failed to read or invalid MBR. */
;;;158        warm_restart = __FALSE;
;;;159        return (2);
;;;160      }
;;;161    
;;;162      /* Read Boot Record Info. */
;;;163      if (get_bootrec () == __FALSE) {
000288  f7fffffe          BL       get_bootrec
00028c  b358              CBZ      r0,|L1.742|
;;;164        /* Failed to read or Invalid Boot Record. */
;;;165        warm_restart = __FALSE;
;;;166        return (3);
;;;167      }
;;;168    
;;;169      if (is_fat_valid () == __FALSE) {
00028e  f7fffffe          BL       is_fat_valid
000292  b358              CBZ      r0,|L1.748|
;;;170        /* Invalid FAT table. */
;;;171        warm_restart = __FALSE;
;;;172        return (4);
;;;173      }
;;;174    
;;;175      /* Calculate Root Sector Count. */
;;;176      root_scnt = (mmc.RootEntCnt * 32 + mmc.BytesPerSec - 1) / mmc.BytesPerSec;
000294  4854              LDR      r0,|L1.1000|
000296  3020              ADDS     r0,r0,#0x20
000298  8a81              LDRH     r1,[r0,#0x14]  ; mmc
00029a  f8b0c016          LDRH     r12,[r0,#0x16]  ; mmc
00029e  eb061141          ADD      r1,r6,r1,LSL #5
0002a2  4461              ADD      r1,r1,r12
0002a4  fb91f1fc          SDIV     r1,r1,r12
;;;177    
;;;178      /* Count Data Sectors/Clusters */
;;;179      mmc.DataSecCnt  = mmc.DskSize - (mmc.RsvdSecCnt + 
0002a8  8942              LDRH     r2,[r0,#0xa]  ; mmc
0002aa  7943              LDRB     r3,[r0,#5]  ; mmc
0002ac  8906              LDRH     r6,[r0,#8]  ; mmc
0002ae  68c7              LDR      r7,[r0,#0xc]  ; mmc
0002b0  fb032206          MLA      r2,r3,r6,r2
0002b4  1853              ADDS     r3,r2,r1
0002b6  1afe              SUBS     r6,r7,r3
;;;180                                       mmc.NumOfFat * mmc.FatSize + root_scnt);
;;;181      mmc.DataClusCnt = mmc.DataSecCnt / mmc.SecPerClus;
0002b8  6106              STR      r6,[r0,#0x10]  ; mmc
0002ba  7983              LDRB     r3,[r0,#6]  ; mmc
0002bc  fbb6f6f3          UDIV     r6,r6,r3
;;;182      mmc.RootDirAddr = mmc.RsvdSecCnt + mmc.NumOfFat * mmc.FatSize;
0002c0  6186              STR      r6,[r0,#0x18]  ; mmc
0002c2  8382              STRH     r2,[r0,#0x1c]
;;;183      mmc.RootSecCnt  = root_scnt;
0002c4  83c1              STRH     r1,[r0,#0x1e]
;;;184      mmc.ClusSize    = mmc.SecPerClus * mmc.BytesPerSec;
0002c6  fb03f30c          MUL      r3,r3,r12
;;;185      mmc.EntsPerClus = mmc.ClusSize / 32;
0002ca  0959              LSRS     r1,r3,#5
0002cc  6203              STR      r3,[r0,#0x20]  ; mmc
0002ce  8481              STRH     r1,[r0,#0x24]
;;;186    
;;;187      /* Determine Fat Type. */
;;;188      if (mmc.DataClusCnt < 4085) {
0002d0  f64072f5          MOV      r2,#0xff5
;;;189        mmc.FatType = FS_FAT12;
0002d4  2101              MOVS     r1,#1
0002d6  4296              CMP      r6,r2                 ;188
0002d8  d20b              BCS      |L1.754|
0002da  7101              STRB     r1,[r0,#4]
;;;190        warm_restart = __FALSE;
0002dc  e00f              B        |L1.766|
                  |L1.734|
0002de  70a5              STRB     r5,[r4,#2]            ;158
0002e0  2002              MOVS     r0,#2                 ;159
                  |L1.738|
;;;191      }
;;;192      else if (mmc.DataClusCnt < 65525) {
;;;193        mmc.FatType = FS_FAT16;
;;;194        warm_restart = __FALSE;
;;;195      }
;;;196      else {
;;;197        mmc.FatType = FS_FAT32;
;;;198        /* Calculate number of free cluster the first time. */
;;;199        if (warm_restart == __FALSE) {
;;;200          warm_restart = __TRUE;
;;;201          free_clus = count_free_clus ();
;;;202        }
;;;203      }
;;;204    
;;;205      return (0);
;;;206    }
0002e2  e8bd81f0          POP      {r4-r8,pc}
                  |L1.742|
0002e6  70a5              STRB     r5,[r4,#2]            ;165
0002e8  2003              MOVS     r0,#3                 ;166
0002ea  e7fa              B        |L1.738|
                  |L1.748|
0002ec  70a5              STRB     r5,[r4,#2]            ;171
0002ee  2004              MOVS     r0,#4                 ;172
0002f0  e7f7              B        |L1.738|
                  |L1.754|
0002f2  f64f72f5          MOV      r2,#0xfff5            ;192
0002f6  4296              CMP      r6,r2                 ;192
0002f8  d203              BCS      |L1.770|
0002fa  f8808004          STRB     r8,[r0,#4]            ;193
                  |L1.766|
0002fe  70a5              STRB     r5,[r4,#2]            ;194
000300  e007              B        |L1.786|
                  |L1.770|
000302  2203              MOVS     r2,#3                 ;197
000304  7102              STRB     r2,[r0,#4]            ;197
000306  78a0              LDRB     r0,[r4,#2]            ;199  ; warm_restart
000308  b918              CBNZ     r0,|L1.786|
00030a  70a1              STRB     r1,[r4,#2]            ;200
00030c  f7fffffe          BL       count_free_clus
000310  60a0              STR      r0,[r4,#8]            ;201  ; free_clus
                  |L1.786|
000312  2000              MOVS     r0,#0                 ;205
                  |L1.788|
000314  e7e5              B        |L1.738|
;;;207    
                          ENDP

                  fat_init PROC
;;;120    
;;;121    int fat_init (void) {
000316  b510              PUSH     {r4,lr}
;;;122      /* Initialize FAT File System driver. */
;;;123    
;;;124      /* Initialize Flash Card interface. */
;;;125      if (mmc_init () == __FALSE) {
000318  f7fffffe          BL       mmc_init
00031c  b110              CBZ      r0,|L1.804|
;;;126        /* Failed to Initialize or No Card error. */
;;;127        return (1);
;;;128      }
;;;129      /* Initialize FAT file system. */
;;;130      return (init_dev ());
00031e  e8bd4010          POP      {r4,lr}
000322  e7fe              B        init_dev
                  |L1.804|
000324  2001              MOVS     r0,#1                 ;127
;;;131    }
000326  bd10              POP      {r4,pc}
;;;132    
                          ENDP

                  get_time PROC
;;;1762   
;;;1763   static U16 get_time (void) {
000328  b510              PUSH     {r4,lr}
;;;1764     /* Get current system time for a time stamp of a file. */
;;;1765     U32 retv, time, v;
;;;1766   
;;;1767     time = fs_get_time ();
00032a  f7fffffe          BL       fs_get_time
;;;1768   
;;;1769     /* Seconds: 0-29 (2-second count) */
;;;1770     v = (time >> 1) & 0x1F;
00032e  f3c00144          UBFX     r1,r0,#1,#5
;;;1771     if (v > 29) v = 0;
000332  291d              CMP      r1,#0x1d
000334  d900              BLS      |L1.824|
000336  2100              MOVS     r1,#0
                  |L1.824|
;;;1772     retv = v;
;;;1773   
;;;1774     /* Minutes: 0-59 */
;;;1775     v = (time >> 8) & 0x3F;
000338  f3c02205          UBFX     r2,r0,#8,#6
;;;1776     if (v > 59) v = 0;
00033c  2a3b              CMP      r2,#0x3b
00033e  d900              BLS      |L1.834|
000340  2200              MOVS     r2,#0
                  |L1.834|
;;;1777     retv |= (v << 5);
;;;1778   
;;;1779     /* Hours: 0-23 */
;;;1780     v = (time >> 16) & 0x1F;
000342  f3c04004          UBFX     r0,r0,#16,#5
000346  ea411142          ORR      r1,r1,r2,LSL #5       ;1777
;;;1781     if (v > 23) v = 23;
00034a  2817              CMP      r0,#0x17
00034c  d900              BLS      |L1.848|
00034e  2017              MOVS     r0,#0x17
                  |L1.848|
;;;1782     retv |= (v << 11);
000350  ea4120c0          ORR      r0,r1,r0,LSL #11
;;;1783   
;;;1784     return (retv);
000354  b280              UXTH     r0,r0
;;;1785   }
000356  bd10              POP      {r4,pc}
;;;1786   
                          ENDP

                  get_date PROC
;;;1789   
;;;1790   static U16 get_date (void) {
000358  b510              PUSH     {r4,lr}
;;;1791     /* Get current system date for a time stamp of a file. */
;;;1792     U32 retv, date, v;
;;;1793   
;;;1794     date = fs_get_date ();
00035a  f7fffffe          BL       fs_get_date
;;;1795   
;;;1796     /* Days: 1-31 */
;;;1797     v = date & 0x1F;
00035e  f010011f          ANDS     r1,r0,#0x1f
;;;1798     if (v == 0) v = 1;
000362  d100              BNE      |L1.870|
000364  2101              MOVS     r1,#1
                  |L1.870|
;;;1799     retv = v;
;;;1800   
;;;1801     /* Month: 1-12 */
;;;1802     v = (date >> 8) & 0x0F;
000366  f3c02203          UBFX     r2,r0,#8,#4
;;;1803     if (v > 12 || v == 0) v = 1;
00036a  2a0c              CMP      r2,#0xc
00036c  d800              BHI      |L1.880|
00036e  b902              CBNZ     r2,|L1.882|
                  |L1.880|
000370  2201              MOVS     r2,#1
                  |L1.882|
;;;1804     retv |= (v << 5);
000372  ea411142          ORR      r1,r1,r2,LSL #5
;;;1805   
;;;1806     /* Year: 0-127 */
;;;1807     v  = (date >> 16) - 1980;
000376  2244              MOVS     r2,#0x44
000378  eb024010          ADD      r0,r2,r0,LSR #16
;;;1808     v &= 0x7F;
;;;1809     retv |= (v << 9);
00037c  ea412040          ORR      r0,r1,r0,LSL #9
;;;1810   
;;;1811     return (retv);
000380  b280              UXTH     r0,r0
;;;1812   }
000382  bd10              POP      {r4,pc}
;;;1813   
                          ENDP

                  write_cache PROC
;;;1545   
;;;1546   static BOOL write_cache (U32 sect) {
000384  e92d41f0          PUSH     {r4-r8,lr}
;;;1547     /* Write a 512 byte sector to Data cache. */
;;;1548   
;;;1549     if (_MC_CSIZE == 0) {
000388  4b1a              LDR      r3,|L1.1012|
00038a  4605              MOV      r5,r0                 ;1546
00038c  8818              LDRH     r0,[r3,#0]  ; _MC_CSIZE
00038e  b1d8              CBZ      r0,|L1.968|
;;;1550       /* File Caching switched off. */
;;;1551       if (sect) {
;;;1552         EX(write_sector (sect),__FALSE);
;;;1553       }
;;;1554       return (__TRUE);
;;;1555     }
;;;1556     if (sect == 0) {
;;;1557       /* Flush cache request. */
;;;1558       if (ca.nwr) {
000390  4c15              LDR      r4,|L1.1000|
000392  2600              MOVS     r6,#0                 ;1549
000394  340c              ADDS     r4,r4,#0xc
000396  7c22              LDRB     r2,[r4,#0x10]
000398  68e1              LDR      r1,[r4,#0xc]          ;1556
00039a  6860              LDR      r0,[r4,#4]            ;1556
00039c  b1e5              CBZ      r5,|L1.984|
;;;1559         EX(mmc_write_sect (ca.csect, ca.cbuf, ca.nwr),__FALSE);
;;;1560         ca.nwr = 0;
;;;1561       }
;;;1562       return (__TRUE);
;;;1563     }
;;;1564     ca.sect = sect;
;;;1565     if (ca.nwr > 0) {
;;;1566       if (sect == (ca.csect + ca.nwr) && ca.nwr < _MC_CSIZE) {
;;;1567         /* Next sector is continuous, still space in cache. */
;;;1568         memcpy (ca.cbuf + (ca.nwr * 512), ca.buf, 512);
00039e  f44f7800          MOV      r8,#0x200
0003a2  6025              STR      r5,[r4,#0]            ;1565  ; ca
0003a4  b342              CBZ      r2,|L1.1016|
0003a6  1887              ADDS     r7,r0,r2              ;1566
0003a8  42af              CMP      r7,r5                 ;1566
0003aa  d126              BNE      |L1.1018|
0003ac  881b              LDRH     r3,[r3,#0]            ;1566  ; _MC_CSIZE
0003ae  429a              CMP      r2,r3                 ;1566
0003b0  d223              BCS      |L1.1018|
0003b2  eb012042          ADD      r0,r1,r2,LSL #9
0003b6  4642              MOV      r2,r8
0003b8  68a1              LDR      r1,[r4,#8]  ; ca
0003ba  f7fffffe          BL       __aeabi_memcpy
;;;1569         ca.nwr++;
0003be  7c20              LDRB     r0,[r4,#0x10]  ; ca
0003c0  1c40              ADDS     r0,r0,#1
0003c2  7420              STRB     r0,[r4,#0x10]
                  |L1.964|
;;;1570         return (__TRUE);
;;;1571       }
;;;1572       /* Not continuous sector or buffer full, flush the cache. */
;;;1573       EX(mmc_write_sect (ca.csect, ca.cbuf, ca.nwr),__FALSE);
;;;1574       ca.nwr = 0;
;;;1575     }
;;;1576     /* Write Data cache is empty. */
;;;1577     memcpy (ca.cbuf, ca.buf, 512);
;;;1578     ca.csect = sect;
;;;1579     ca.nwr   = 1;
;;;1580     ca.nrd   = 0;
;;;1581     return (__TRUE);
0003c4  2001              MOVS     r0,#1
                  |L1.966|
;;;1582   }
0003c6  e78c              B        |L1.738|
                  |L1.968|
0003c8  2d00              CMP      r5,#0                 ;1551
0003ca  d0fb              BEQ      |L1.964|
0003cc  4628              MOV      r0,r5                 ;1552
0003ce  f7fffffe          BL       write_sector
0003d2  2800              CMP      r0,#0                 ;1552
0003d4  d085              BEQ      |L1.738|
0003d6  e7f5              B        |L1.964|
                  |L1.984|
0003d8  2a00              CMP      r2,#0                 ;1558
0003da  d0f3              BEQ      |L1.964|
0003dc  f7fffffe          BL       mmc_write_sect
0003e0  2800              CMP      r0,#0                 ;1559
0003e2  d0f0              BEQ      |L1.966|
0003e4  7426              STRB     r6,[r4,#0x10]         ;1560
0003e6  e7ed              B        |L1.964|
                  |L1.1000|
                          DCD      ||.bss||
                  |L1.1004|
                          DCD      mc_cache
                  |L1.1008|
                          DCD      ||.data||
                  |L1.1012|
                          DCD      _MC_CSIZE
                  |L1.1016|
0003f8  e004              B        |L1.1028|
                  |L1.1018|
0003fa  f7fffffe          BL       mmc_write_sect
0003fe  2800              CMP      r0,#0                 ;1573
000400  d0e1              BEQ      |L1.966|
000402  7426              STRB     r6,[r4,#0x10]         ;1574
                  |L1.1028|
000404  e9d41002          LDRD     r1,r0,[r4,#8]         ;1577
000408  4642              MOV      r2,r8                 ;1577
00040a  f7fffffe          BL       __aeabi_memcpy
00040e  2001              MOVS     r0,#1                 ;1579
000410  6065              STR      r5,[r4,#4]            ;1579  ; ca
000412  7420              STRB     r0,[r4,#0x10]         ;1579
000414  7466              STRB     r6,[r4,#0x11]         ;1580
000416  e7d5              B        |L1.964|
;;;1583   
                          ENDP

                  write_br PROC
;;;426    
;;;427    static BOOL write_br (U32 sernum) {
000418  e92d47f0          PUSH     {r4-r10,lr}
;;;428      /* Construct and write a Boot Rrecord. */
;;;429    
;;;430      memset (ca.buf, 0, 512);
00041c  4cff              LDR      r4,|L1.2076|
00041e  4682              MOV      r10,r0                ;427
000420  f44f7100          MOV      r1,#0x200
000424  68a0              LDR      r0,[r4,#8]  ; ca
000426  f7fffffe          BL       __aeabi_memclr
;;;431    
;;;432      /* Boot Code: E9 00 90 */
;;;433      ca.buf[0] = 0xE9;
00042a  68a0              LDR      r0,[r4,#8]  ; ca
00042c  21e9              MOVS     r1,#0xe9
;;;434      ca.buf[1] = 0x00;
00042e  2600              MOVS     r6,#0
000430  7001              STRB     r1,[r0,#0]            ;433
000432  7046              STRB     r6,[r0,#1]
;;;435      ca.buf[2] = 0x90;
000434  2190              MOVS     r1,#0x90
000436  7081              STRB     r1,[r0,#2]
;;;436    
;;;437      /* OEM name */
;;;438      memcpy (&ca.buf[3], "MSWIN4.1", 8);
000438  a1f9              ADR      r1,|L1.2080|
;;;439    
;;;440      /* Bytes per Sector */
;;;441      set_u16 (&ca.buf[11], 512);
;;;442    
;;;443      /* Sectors per Cluster */
;;;444      ca.buf[13] = mmc.SecPerClus;
00043a  f1040514          ADD      r5,r4,#0x14
00043e  680a              LDR      r2,[r1,#0]            ;438
000440  f8c02003          STR      r2,[r0,#3]            ;438
000444  6849              LDR      r1,[r1,#4]            ;438
000446  f8c01007          STR      r1,[r0,#7]            ;438
00044a  2102              MOVS     r1,#2                 ;438
00044c  7301              STRB     r1,[r0,#0xc]          ;438
00044e  72c6              STRB     r6,[r0,#0xb]          ;438
000450  79aa              LDRB     r2,[r5,#6]  ; mmc
000452  7342              STRB     r2,[r0,#0xd]
;;;445    
;;;446      /* Reserved Sectors */
;;;447      ca.buf[14] = mmc.RsvdSecCnt;
000454  896a              LDRH     r2,[r5,#0xa]  ; mmc
000456  7382              STRB     r2,[r0,#0xe]
;;;448    
;;;449      /* Number of FAT Tables */
;;;450      ca.buf[16] = 2;
000458  7401              STRB     r1,[r0,#0x10]
;;;451    
;;;452      /* Root Entry Count */
;;;453      if (mmc.FatType != FS_FAT32) {
00045a  792a              LDRB     r2,[r5,#4]  ; mmc
00045c  2a03              CMP      r2,#3
00045e  d001              BEQ      |L1.1124|
000460  7481              STRB     r1,[r0,#0x12]
000462  7446              STRB     r6,[r0,#0x11]
                  |L1.1124|
;;;454        /* Must be 0 for FAT32. */
;;;455        set_u16 (&ca.buf[17], 512);
;;;456      }
;;;457    
;;;458      /* Total Sector Count */
;;;459      if (mmc.DskSize < 0x10000) {
000464  68e9              LDR      r1,[r5,#0xc]  ; mmc
000466  f5b13f80          CMP      r1,#0x10000
00046a  d204              BCS      |L1.1142|
;;;460        set_u16 (&ca.buf[19], mmc.DskSize);
00046c  b289              UXTH     r1,r1
00046e  3013              ADDS     r0,r0,#0x13
000470  f7fffffe          BL       set_u16
000474  e002              B        |L1.1148|
                  |L1.1142|
;;;461      }
;;;462      else {
;;;463        set_u32 (&ca.buf[32], mmc.DskSize);
000476  3020              ADDS     r0,r0,#0x20
000478  f7fffffe          BL       set_u32
                  |L1.1148|
;;;464      }
;;;465    
;;;466      /* Media Type, must be the same as FAT byte 0 */
;;;467      ca.buf[21] = 0xF8;
00047c  68a0              LDR      r0,[r4,#8]  ; ca
00047e  21f8              MOVS     r1,#0xf8
000480  7541              STRB     r1,[r0,#0x15]
;;;468    
;;;469      /* Number of Hidden Sectors */
;;;470      set_u32 (&ca.buf[28], mmc.BootRecSec);
000482  301c              ADDS     r0,r0,#0x1c
000484  6829              LDR      r1,[r5,#0]  ; mmc
000486  f7fffffe          BL       set_u32
;;;471    
;;;472      if (mmc.FatType != FS_FAT32) {
00048a  7928              LDRB     r0,[r5,#4]  ; mmc
;;;473        /* FAT Size */
;;;474        set_u16 (&ca.buf[22], mmc.FatSize);
;;;475    
;;;476        /* Physical Disk Number */
;;;477        ca.buf[36] = 0x80;
00048c  2780              MOVS     r7,#0x80
00048e  2803              CMP      r0,#3                 ;472
;;;478    
;;;479        /* Boot Sig */
;;;480        ca.buf[38] = 0x29;
;;;481    
;;;482        /* Volume ID */
;;;483        set_u32 (&ca.buf[39], sernum);
;;;484    
;;;485        /* Volume Label */
;;;486        memcpy (&ca.buf[43], "NO NAME    ", 11);
;;;487    
;;;488        /* File System Type. */
;;;489        if (mmc.FatType == FS_FAT12) {
;;;490          memcpy (&ca.buf[54], "FAT12   ", 8);
;;;491        }
;;;492        else {
;;;493          memcpy (&ca.buf[54], "FAT16   ", 8);
;;;494        }
;;;495      }
;;;496      else {
;;;497        /* FAT32 Structure different from offset 36. */
;;;498    
;;;499        /* FAT Size */
;;;500        set_u32 (&ca.buf[36], mmc.FatSize);
000490  8929              LDRH     r1,[r5,#8]  ; mmc
000492  68a0              LDR      r0,[r4,#8]            ;472  ; ca
000494  f04f0829          MOV      r8,#0x29              ;480
000498  f04f0920          MOV      r9,#0x20              ;486
00049c  d025              BEQ      |L1.1258|
00049e  3016              ADDS     r0,r0,#0x16           ;474
0004a0  f7fffffe          BL       set_u16
0004a4  68a0              LDR      r0,[r4,#8]            ;477  ; ca
0004a6  4651              MOV      r1,r10                ;483
0004a8  f8807024          STRB     r7,[r0,#0x24]         ;477
0004ac  f8808026          STRB     r8,[r0,#0x26]         ;480
0004b0  3027              ADDS     r0,r0,#0x27           ;483
0004b2  f7fffffe          BL       set_u32
0004b6  a1dd              ADR      r1,|L1.2092|
0004b8  68a0              LDR      r0,[r4,#8]            ;486  ; ca
0004ba  680a              LDR      r2,[r1,#0]            ;486
0004bc  f8c0202b          STR      r2,[r0,#0x2b]         ;486
0004c0  684a              LDR      r2,[r1,#4]            ;486
0004c2  f8c0202f          STR      r2,[r0,#0x2f]         ;486
0004c6  8909              LDRH     r1,[r1,#8]            ;486
0004c8  f8a01033          STRH     r1,[r0,#0x33]         ;486
0004cc  f8809035          STRB     r9,[r0,#0x35]         ;486
0004d0  7929              LDRB     r1,[r5,#4]            ;489  ; mmc
0004d2  2901              CMP      r1,#1                 ;489
0004d4  d007              BEQ      |L1.1254|
0004d6  a1d8              ADR      r1,|L1.2104|
                  |L1.1240|
0004d8  680a              LDR      r2,[r1,#0]            ;490
0004da  f8c02036          STR      r2,[r0,#0x36]         ;490
0004de  6849              LDR      r1,[r1,#4]            ;490
0004e0  f8c0103a          STR      r1,[r0,#0x3a]         ;490
0004e4  e02f              B        |L1.1350|
                  |L1.1254|
0004e6  a1d7              ADR      r1,|L1.2116|
0004e8  e7f6              B        |L1.1240|
                  |L1.1258|
0004ea  3024              ADDS     r0,r0,#0x24
0004ec  f7fffffe          BL       set_u32
;;;501    
;;;502        /* Root Cluster Number. */
;;;503        set_u32 (&ca.buf[44], 2);
0004f0  68a0              LDR      r0,[r4,#8]  ; ca
0004f2  2102              MOVS     r1,#2
0004f4  302c              ADDS     r0,r0,#0x2c
0004f6  f7fffffe          BL       set_u32
;;;504    
;;;505        /* FSInfo */
;;;506        set_u16 (&ca.buf[48], 1);
0004fa  68a0              LDR      r0,[r4,#8]  ; ca
0004fc  2101              MOVS     r1,#1
0004fe  f1000230          ADD      r2,r0,#0x30
000502  7056              STRB     r6,[r2,#1]
000504  7011              STRB     r1,[r2,#0]
;;;507    
;;;508        /* Backup Boot Sector */
;;;509        set_u16 (&ca.buf[50], 6);
000506  1c92              ADDS     r2,r2,#2
000508  2106              MOVS     r1,#6
00050a  7056              STRB     r6,[r2,#1]
00050c  7011              STRB     r1,[r2,#0]
;;;510    
;;;511        /* Physical Disk Number */
;;;512        ca.buf[64] = 0x80;
00050e  f8807040          STRB     r7,[r0,#0x40]
;;;513    
;;;514        /* Boot Sig */
;;;515        ca.buf[66] = 0x29;
000512  f8808042          STRB     r8,[r0,#0x42]
;;;516    
;;;517        /* Volume ID */
;;;518        set_u32 (&ca.buf[67], sernum);
000516  3043              ADDS     r0,r0,#0x43
000518  4651              MOV      r1,r10
00051a  f7fffffe          BL       set_u32
;;;519    
;;;520        /* Volume Label */
;;;521        memcpy (&ca.buf[71], "NO NAME    ", 11);
00051e  a1c3              ADR      r1,|L1.2092|
000520  68a0              LDR      r0,[r4,#8]  ; ca
000522  680a              LDR      r2,[r1,#0]
000524  f8c02047          STR      r2,[r0,#0x47]
000528  684a              LDR      r2,[r1,#4]
00052a  f8c0204b          STR      r2,[r0,#0x4b]
00052e  8909              LDRH     r1,[r1,#8]
000530  f8a0104f          STRH     r1,[r0,#0x4f]
;;;522    
;;;523        /* File System Type. */
;;;524        memcpy (&ca.buf[82], "FAT32   ", 8);
000534  a1c6              ADR      r1,|L1.2128|
000536  f8809051          STRB     r9,[r0,#0x51]         ;521
00053a  680a              LDR      r2,[r1,#0]
00053c  f8c02052          STR      r2,[r0,#0x52]
000540  6849              LDR      r1,[r1,#4]
000542  f8c01056          STR      r1,[r0,#0x56]
                  |L1.1350|
;;;525      }
;;;526    
;;;527      /* Executable Marker */
;;;528      set_u16 (&ca.buf[510], 0xAA55);
000546  68a0              LDR      r0,[r4,#8]  ; ca
000548  21aa              MOVS     r1,#0xaa
00054a  f50070ff          ADD      r0,r0,#0x1fe
00054e  7041              STRB     r1,[r0,#1]
000550  2155              MOVS     r1,#0x55
000552  7001              STRB     r1,[r0,#0]
;;;529    
;;;530      return (write_sector (mmc.BootRecSec));
000554  6828              LDR      r0,[r5,#0]  ; mmc
000556  e8bd47f0          POP      {r4-r10,lr}
00055a  f7ffbffe          B.W      write_sector
;;;531    }
;;;532    
                          ENDP

                  write_mbr PROC
;;;368    
;;;369    static BOOL write_mbr (U32 iSz) {
00055e  b570              PUSH     {r4-r6,lr}
;;;370      /* Construct and write a Master Boot Record to sector 0. */
;;;371      U32 val;
;;;372    
;;;373      memset (ca.buf, 0, 512);
000560  4cae              LDR      r4,|L1.2076|
000562  4605              MOV      r5,r0                 ;369
000564  f44f7100          MOV      r1,#0x200
000568  68a0              LDR      r0,[r4,#8]  ; ca
00056a  f7fffffe          BL       __aeabi_memclr
;;;374    
;;;375      /* Boot Descriptor: Non Bootable Device. */
;;;376      ca.buf[446] = 0;
00056e  68a0              LDR      r0,[r4,#8]  ; ca
000570  2300              MOVS     r3,#0
;;;377    
;;;378      /* Beginning of Partition - Head */
;;;379      ca.buf[447] = 1;
000572  2101              MOVS     r1,#1
000574  f88031be          STRB     r3,[r0,#0x1be]        ;376
;;;380    
;;;381      /* First Partition Cylinder/Sector */
;;;382      set_u16 (&ca.buf[448], 1);
000578  f50072e0          ADD      r2,r0,#0x1c0
00057c  f88011bf          STRB     r1,[r0,#0x1bf]        ;379
000580  7053              STRB     r3,[r2,#1]            ;379
;;;383    
;;;384      /* File System Descriptor. */
;;;385      switch (mmc.FatType) {
000582  f1040614          ADD      r6,r4,#0x14
000586  7011              STRB     r1,[r2,#0]
000588  7932              LDRB     r2,[r6,#4]  ; mmc
00058a  2a01              CMP      r2,#1
00058c  d009              BEQ      |L1.1442|
00058e  2a02              CMP      r2,#2
000590  d002              BEQ      |L1.1432|
000592  2a03              CMP      r2,#3
000594  d107              BNE      |L1.1446|
000596  e035              B        |L1.1540|
                  |L1.1432|
;;;386        case FS_FAT12:
;;;387          /* Type 12-bit FAT */
;;;388          ca.buf[450] = 0x01;
;;;389          break;
;;;390        case FS_FAT16:
;;;391          if (iSz < 3) {
000598  2d03              CMP      r5,#3
00059a  d201              BCS      |L1.1440|
;;;392            /* Type 16-bit FAT, Partition < 32 MB */
;;;393            ca.buf[450] = 0x04;
00059c  2104              MOVS     r1,#4
00059e  e000              B        |L1.1442|
                  |L1.1440|
;;;394          }
;;;395          else {
;;;396            /* Type 16-bit FAT, Partition > 32MB */
;;;397            ca.buf[450] = 0x06;
0005a0  2106              MOVS     r1,#6
                  |L1.1442|
0005a2  f88011c2          STRB     r1,[r0,#0x1c2]        ;393
                  |L1.1446|
;;;398          }
;;;399          break;
;;;400        case FS_FAT32:
;;;401            /* Type 32-bit FAT, Partition < 2047GB */
;;;402          ca.buf[450] = 0x0b;
;;;403          break;
;;;404      }
;;;405    
;;;406      /* End of Partition - Head */
;;;407      ca.buf[451] = IniDevCfg[iSz].NumHeads - 1;
0005a6  49ad              LDR      r1,|L1.2140|
0005a8  eb050245          ADD      r2,r5,r5,LSL #1
0005ac  eb010282          ADD      r2,r1,r2,LSL #2
;;;408    
;;;409      /* End of Partition Cylinder/Sector. */
;;;410      val = IniDevCfg[iSz].NumSect | ((IniDevCfg[iSz].NumCyl - 1) << 6);
0005b0  f06f033f          MVN      r3,#0x3f
0005b4  8891              LDRH     r1,[r2,#4]            ;407
0005b6  1e49              SUBS     r1,r1,#1              ;407
0005b8  f88011c3          STRB     r1,[r0,#0x1c3]        ;407
0005bc  7991              LDRB     r1,[r2,#6]
0005be  8912              LDRH     r2,[r2,#8]
;;;411      set_u16 (&ca.buf[452], val);
0005c0  f50070e2          ADD      r0,r0,#0x1c4
0005c4  eb031282          ADD      r2,r3,r2,LSL #6       ;410
0005c8  4311              ORRS     r1,r1,r2              ;410
0005ca  b289              UXTH     r1,r1
0005cc  f7fffffe          BL       set_u16
;;;412    
;;;413      /* First Sector Position Relative to Beginning of Device. */
;;;414      set_u32 (&ca.buf[454], mmc.BootRecSec);
0005d0  68a0              LDR      r0,[r4,#8]  ; ca
0005d2  6831              LDR      r1,[r6,#0]  ; mmc
0005d4  f50070e3          ADD      r0,r0,#0x1c6
0005d8  f7fffffe          BL       set_u32
;;;415    
;;;416      /* Number of Sectors in Partition */
;;;417      set_u32 (&ca.buf[458], mmc.DskSize - mmc.BootRecSec);
0005dc  6831              LDR      r1,[r6,#0]  ; mmc
0005de  68f0              LDR      r0,[r6,#0xc]  ; mmc
0005e0  1a41              SUBS     r1,r0,r1
0005e2  68a0              LDR      r0,[r4,#8]  ; ca
0005e4  f50070e5          ADD      r0,r0,#0x1ca
0005e8  f7fffffe          BL       set_u32
;;;418    
;;;419      /* Executable Marker */
;;;420      set_u16 (&ca.buf[510], 0xAA55);
0005ec  68a0              LDR      r0,[r4,#8]  ; ca
0005ee  21aa              MOVS     r1,#0xaa
0005f0  f50070ff          ADD      r0,r0,#0x1fe
0005f4  7041              STRB     r1,[r0,#1]
0005f6  2155              MOVS     r1,#0x55
0005f8  7001              STRB     r1,[r0,#0]
;;;421      return (write_sector (0));
0005fa  e8bd4070          POP      {r4-r6,lr}
0005fe  2000              MOVS     r0,#0
000600  f7ffbffe          B.W      write_sector
                  |L1.1540|
000604  210b              MOVS     r1,#0xb               ;402
000606  e7cc              B        |L1.1442|
;;;422    }
;;;423    
                          ENDP

                  fat_format PROC
;;;210    
;;;211    BOOL fat_format (const char *label) {
000608  e92d4ff1          PUSH     {r0,r4-r11,lr}
00060c  b084              SUB      sp,sp,#0x10
;;;212      /* Format a Flash Card for FAT12 or FAT16. */
;;;213      U32 datSect,volSz,iSz,secClus,i,sec;
;;;214      MMCFG mcfg;
;;;215    
;;;216      /* Read MMC/SD Card configuration. */
;;;217      EX(mmc_read_config (&mcfg),__FALSE);
00060e  4668              MOV      r0,sp
000610  f7fffffe          BL       mmc_read_config
000614  2800              CMP      r0,#0
000616  d07d              BEQ      |L1.1812|
;;;218    
;;;219      /* Check Read and Write Block sizes. */
;;;220      if (mcfg.read_blen != mcfg.write_blen) {
000618  f8bd0008          LDRH     r0,[sp,#8]
00061c  f8bd100a          LDRH     r1,[sp,#0xa]
000620  4288              CMP      r0,r1
000622  d178              BNE      |L1.1814|
;;;221        return (__FALSE);
;;;222      }
;;;223      switch (mcfg.read_blen) {
000624  f5b07f00          CMP      r0,#0x200
000628  d006              BEQ      |L1.1592|
00062a  f5b06f80          CMP      r0,#0x400
00062e  d005              BEQ      |L1.1596|
000630  f5b06f00          CMP      r0,#0x800
000634  d177              BNE      |L1.1830|
000636  e004              B        |L1.1602|
                  |L1.1592|
;;;224        case 512:
;;;225          /* Up to 1GB cards. */
;;;226          break;
000638  9801              LDR      r0,[sp,#4]
00063a  e005              B        |L1.1608|
                  |L1.1596|
;;;227    
;;;228        case 1024:
;;;229          /* 2 GB cards. */
;;;230          mcfg.blocknr *= 2;
00063c  9801              LDR      r0,[sp,#4]
00063e  0040              LSLS     r0,r0,#1
;;;231          break;
000640  e001              B        |L1.1606|
                  |L1.1602|
;;;232    
;;;233        case 2048:
;;;234          /* 4 GB cards. */
;;;235          mcfg.blocknr *= 4;
000642  9801              LDR      r0,[sp,#4]
000644  0080              LSLS     r0,r0,#2
                  |L1.1606|
000646  9001              STR      r0,[sp,#4]            ;230
                  |L1.1608|
;;;236          break;
;;;237    
;;;238        default:
;;;239          /* Block Size not supported. */
;;;240          return (__FALSE);
;;;241      }
;;;242    
;;;243      volSz = mcfg.blocknr >> 11;
000648  0ac1              LSRS     r1,r0,#11
;;;244      for (iSz = 0, i = 8; iSz < 10; i <<= 1, iSz++) {
00064a  2500              MOVS     r5,#0
00064c  2008              MOVS     r0,#8
                  |L1.1614|
;;;245        if (volSz < i) break;
00064e  4281              CMP      r1,r0
000650  d303              BCC      |L1.1626|
000652  0040              LSLS     r0,r0,#1              ;244
000654  1c6d              ADDS     r5,r5,#1              ;244
000656  2d0a              CMP      r5,#0xa               ;244
000658  d3f9              BCC      |L1.1614|
                  |L1.1626|
;;;246      }
;;;247      if (iSz == 10) {
00065a  2d0a              CMP      r5,#0xa
00065c  d063              BEQ      |L1.1830|
;;;248        /* Only Flash Card up to 4GB supported. */
;;;249        return (__FALSE);
;;;250      }
;;;251    
;;;252      /* Check for parameter: /WIPE */
;;;253      if (chk_param ("WIPE", label) == __TRUE) {
00065e  a080              ADR      r0,|L1.2144|
000660  9904              LDR      r1,[sp,#0x10]
000662  f7fffffe          BL       chk_param
000666  f8dfb1b4          LDR      r11,|L1.2076|
00066a  f04f0a01          MOV      r10,#1
00066e  f04f0900          MOV      r9,#0                 ;217
000672  2801              CMP      r0,#1
000674  d11c              BNE      |L1.1712|
000676  9f01              LDR      r7,[sp,#4]
000678  497b              LDR      r1,|L1.2152|
00067a  f88b9010          STRB     r9,[r11,#0x10]
00067e  f88b9011          STRB     r9,[r11,#0x11]
000682  880c              LDRH     r4,[r1,#0]  ; _MC_CSIZE
000684  b904              CBNZ     r4,|L1.1672|
000686  2401              MOVS     r4,#1
                  |L1.1672|
000688  0261              LSLS     r1,r4,#9
00068a  46d8              MOV      r8,r11
00068c  22ff              MOVS     r2,#0xff
00068e  f8db0008          LDR      r0,[r11,#8]  ; ca
000692  f7fffffe          BL       __aeabi_memset
000696  2600              MOVS     r6,#0
000698  e008              B        |L1.1708|
                  |L1.1690|
00069a  4622              MOV      r2,r4
00069c  4630              MOV      r0,r6
00069e  f8d81008          LDR      r1,[r8,#8]  ; ca
0006a2  f7fffffe          BL       mmc_write_sect
0006a6  2800              CMP      r0,#0
0006a8  d03e              BEQ      |L1.1832|
0006aa  4426              ADD      r6,r6,r4
                  |L1.1708|
0006ac  42be              CMP      r6,r7
0006ae  d3f4              BCC      |L1.1690|
                  |L1.1712|
;;;254        /* Clear the whole disk. */
;;;255        EX(wipe_disk (mcfg.blocknr),__FALSE);
;;;256      }
;;;257    
;;;258      /* Format with Partition Table and BPB. */
;;;259      mmc.BootRecSec = IniDevCfg[iSz].BootRecSec;
0006b0  496a              LDR      r1,|L1.2140|
0006b2  eb050245          ADD      r2,r5,r5,LSL #1
0006b6  4c59              LDR      r4,|L1.2076|
0006b8  eb010082          ADD      r0,r1,r2,LSL #2
0006bc  3414              ADDS     r4,r4,#0x14
0006be  8943              LDRH     r3,[r0,#0xa]
;;;260      mmc.DskSize    = mcfg.blocknr - mmc.BootRecSec;
0006c0  6023              STR      r3,[r4,#0]  ; mmc
0006c2  9e01              LDR      r6,[sp,#4]
0006c4  4680              MOV      r8,r0                 ;259
0006c6  1af3              SUBS     r3,r6,r3
;;;261      mmc.RsvdSecCnt = 1;
0006c8  60e3              STR      r3,[r4,#0xc]  ; mmc
0006ca  f8a4a00a          STRH     r10,[r4,#0xa]
;;;262      mmc.BytesPerSec= 512;
0006ce  f44f7600          MOV      r6,#0x200
0006d2  82e6              STRH     r6,[r4,#0x16]
;;;263      mmc.NumOfFat   = 2;
0006d4  2302              MOVS     r3,#2
0006d6  7163              STRB     r3,[r4,#5]
;;;264    
;;;265      /* Set Volume Parameter Info. */
;;;266      mmc.FatType    = IniDevCfg[iSz].FatType;
0006d8  f8111022          LDRB     r1,[r1,r2,LSL #2]
0006dc  7121              STRB     r1,[r4,#4]
;;;267      secClus        = IniDevCfg[iSz].SecClus;
0006de  7847              LDRB     r7,[r0,#1]
;;;268    
;;;269      /* Check for parameter: /FAT32 */
;;;270      if (chk_param ("FAT32", label) == __TRUE) {
0006e0  a062              ADR      r0,|L1.2156|
0006e2  9904              LDR      r1,[sp,#0x10]
0006e4  f7fffffe          BL       chk_param
;;;271        /* Force FAT32 */
;;;272        mmc.FatType = FS_FAT32;
0006e8  f04f0c03          MOV      r12,#3
0006ec  2801              CMP      r0,#1                 ;270
0006ee  d104              BNE      |L1.1786|
0006f0  f884c004          STRB     r12,[r4,#4]
;;;273        secClus     = IniDevCfg[iSz].SecClus32;
0006f4  f8987002          LDRB     r7,[r8,#2]
;;;274        if (secClus == 0) {
0006f8  b16f              CBZ      r7,|L1.1814|
                  |L1.1786|
;;;275          /* Not possible to use FAT32, size is too small. */
;;;276          return (__FALSE);
;;;277        }
;;;278      }
;;;279    
;;;280      mmc.SecPerClus = secClus;
0006fa  71a7              STRB     r7,[r4,#6]
;;;281      mmc.ClusSize   = secClus * 512;
0006fc  0278              LSLS     r0,r7,#9
;;;282    
;;;283      datSect = mmc.DskSize - mmc.RsvdSecCnt;
0006fe  6220              STR      r0,[r4,#0x20]  ; mmc
000700  8960              LDRH     r0,[r4,#0xa]  ; mmc
000702  68e3              LDR      r3,[r4,#0xc]  ; mmc
;;;284      /* Calculate Data Space and FAT Table Size. */
;;;285      switch (mmc.FatType) {
000704  f8948004          LDRB     r8,[r4,#4]  ; mmc
000708  1a19              SUBS     r1,r3,r0              ;283
;;;286        case FS_FAT12:
;;;287          datSect -= 32;
;;;288          mmc.RootEntCnt  = 512;
;;;289          mmc.RootSecCnt  = 32;
00070a  2220              MOVS     r2,#0x20
00070c  f1b80f01          CMP      r8,#1                 ;285
000710  d00d              BEQ      |L1.1838|
000712  e001              B        |L1.1816|
                  |L1.1812|
000714  e008              B        |L1.1832|
                  |L1.1814|
000716  e006              B        |L1.1830|
                  |L1.1816|
000718  f1b80f02          CMP      r8,#2                 ;285
00071c  d018              BEQ      |L1.1872|
00071e  f1b80f03          CMP      r8,#3                 ;285
000722  d124              BNE      |L1.1902|
000724  e056              B        |L1.2004|
                  |L1.1830|
000726  2000              MOVS     r0,#0                 ;276
                  |L1.1832|
;;;290          mmc.DataClusCnt = (datSect * 512 - 1022) / (secClus * 512 + 3);
;;;291          mmc.FatSize     = (mmc.DataClusCnt * 3 + 1022) / 1024;
;;;292          break;
;;;293        case FS_FAT16:
;;;294          datSect -= 32;
;;;295          mmc.RootEntCnt  = 512;
;;;296          mmc.RootSecCnt  = 32;
;;;297          mmc.DataClusCnt = (datSect * 128 - 255) / (secClus * 128 + 1);
;;;298          mmc.FatSize     = (mmc.DataClusCnt + 255) / 256;
;;;299          break;
;;;300        case FS_FAT32:
;;;301          mmc.RootSecCnt  = 0;
;;;302          mmc.DataClusCnt = (datSect * 64 - 127) / (secClus * 64 + 1);
;;;303          mmc.FatSize     = (mmc.DataClusCnt + 127) / 128;
;;;304          break;
;;;305      }
;;;306    
;;;307      /* Count Data Sectors/Clusters */
;;;308      mmc.DataSecCnt  = mmc.DskSize - (mmc.RsvdSecCnt + mmc.RootSecCnt +
;;;309                                       mmc.NumOfFat * mmc.FatSize);
;;;310      mmc.RootDirAddr = mmc.RsvdSecCnt + mmc.NumOfFat * mmc.FatSize;
;;;311    
;;;312      /* 2nd Cluster should be 32K aligned for optimal Card performance. */
;;;313      sec = mmc.RootDirAddr + mmc.RootSecCnt;
;;;314      mmc.BootRecSec = ((mmc.BootRecSec + sec + 32) & ~0x3F) - sec;
;;;315    
;;;316      warm_restart = __FALSE;
;;;317      /* Write MBR, create Partition Table. */
;;;318      EX(write_mbr (iSz),__FALSE);
;;;319    
;;;320      /* Generate Boot Record  */
;;;321      EX(write_br (mcfg.sernum),__FALSE);
;;;322    
;;;323      /* Clear FAT Table and Root Directory. */
;;;324      memset (ca.buf, 0, 512);
;;;325    
;;;326      /* Write Reserved Clusters 0,1 to FAT table. */
;;;327      switch (mmc.FatType) {
;;;328        case FS_FAT12:
;;;329          set_u32 (&ca.buf[0], 0xFFFFF8);
;;;330          break;
;;;331        case FS_FAT16:
;;;332          set_u32 (&ca.buf[0], 0xFFFFFFF8);
;;;333          break;
;;;334        case FS_FAT32:
;;;335          /* Write also Root Dir Cluster to FAT table. */
;;;336          set_u32 (&ca.buf[0], 0x0FFFFFF8);
;;;337          set_u32 (&ca.buf[4], 0xFFFFFFFF);
;;;338          set_u32 (&ca.buf[8], 0x0FFFFFFF);
;;;339          break;
;;;340      }
;;;341      sec = mmc.BootRecSec + mmc.RsvdSecCnt;
;;;342      /* Use cache for faster write. */
;;;343      EX(write_cache (sec),__FALSE);
;;;344      memset (ca.buf, 0, 12);
;;;345    
;;;346      datSect = mmc.RootSecCnt;
;;;347      if (mmc.FatType == FS_FAT32) {
;;;348        /* Clear first Data Cluster (Root Dir) for FAT32. */
;;;349        datSect = mmc.SecPerClus;
;;;350      }
;;;351      datSect += mmc.FatSize * 2;
;;;352    
;;;353      for (i = 1; i < datSect; i++) {
;;;354        EX(write_cache (sec + i),__FALSE);
;;;355      }
;;;356      /* Flush the cache when done. */
;;;357      EX(write_cache (0),__FALSE);
;;;358    
;;;359      if (*label != 0) {
;;;360        /* If provided, write also a Volume Label. */
;;;361        EX(write_label (label),__FALSE);
;;;362      }
;;;363      return (__TRUE);
;;;364    }
000728  b005              ADD      sp,sp,#0x14
00072a  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.1838|
00072e  82a6              STRH     r6,[r4,#0x14]         ;288
000730  83e2              STRH     r2,[r4,#0x1e]         ;289
000732  4a50              LDR      r2,|L1.2164|
000734  3920              SUBS     r1,r1,#0x20           ;287
000736  eb022141          ADD      r1,r2,r1,LSL #9       ;290
00073a  eb0c2247          ADD      r2,r12,r7,LSL #9      ;290
00073e  fbb1f1f2          UDIV     r1,r1,r2              ;290
000742  61a1              STR      r1,[r4,#0x18]         ;291  ; mmc
000744  eb010141          ADD      r1,r1,r1,LSL #1       ;291
000748  f20131fe          ADD      r1,r1,#0x3fe          ;291
00074c  0a89              LSRS     r1,r1,#10             ;291
00074e  e00d              B        |L1.1900|
                  |L1.1872|
000750  82a6              STRH     r6,[r4,#0x14]         ;295
000752  83e2              STRH     r2,[r4,#0x1e]         ;296
000754  3920              SUBS     r1,r1,#0x20           ;294
000756  f06f02fe          MVN      r2,#0xfe              ;297
00075a  eb0211c1          ADD      r1,r2,r1,LSL #7       ;297
00075e  eb0a12c7          ADD      r2,r10,r7,LSL #7      ;297
000762  fbb1f1f2          UDIV     r1,r1,r2              ;297
000766  61a1              STR      r1,[r4,#0x18]         ;298  ; mmc
000768  31ff              ADDS     r1,r1,#0xff           ;298
00076a  0a09              LSRS     r1,r1,#8              ;298
                  |L1.1900|
00076c  8121              STRH     r1,[r4,#8]            ;291
                  |L1.1902|
00076e  f8b4c01e          LDRH     r12,[r4,#0x1e]        ;308  ; mmc
000772  7961              LDRB     r1,[r4,#5]            ;308  ; mmc
000774  8922              LDRH     r2,[r4,#8]            ;308  ; mmc
000776  eb00070c          ADD      r7,r0,r12             ;308
00077a  fb017702          MLA      r7,r1,r2,r7           ;308
00077e  fb010002          MLA      r0,r1,r2,r0           ;310
000782  1bdb              SUBS     r3,r3,r7              ;308
000784  b280              UXTH     r0,r0                 ;310
000786  6123              STR      r3,[r4,#0x10]         ;310  ; mmc
000788  83a0              STRH     r0,[r4,#0x1c]         ;310
00078a  4460              ADD      r0,r0,r12             ;313
00078c  6822              LDR      r2,[r4,#0]            ;314  ; mmc
00078e  f1000120          ADD      r1,r0,#0x20           ;314
000792  4411              ADD      r1,r1,r2              ;314
000794  f021013f          BIC      r1,r1,#0x3f           ;314
000798  1a08              SUBS     r0,r1,r0              ;314
00079a  6020              STR      r0,[r4,#0]            ;316  ; mmc
00079c  4836              LDR      r0,|L1.2168|
00079e  464f              MOV      r7,r9                 ;316
0007a0  f8809002          STRB     r9,[r0,#2]            ;316
0007a4  4628              MOV      r0,r5                 ;318
0007a6  f7fffffe          BL       write_mbr
0007aa  2800              CMP      r0,#0                 ;318
0007ac  d0bc              BEQ      |L1.1832|
0007ae  9800              LDR      r0,[sp,#0]            ;321
0007b0  f7fffffe          BL       write_br
0007b4  2800              CMP      r0,#0                 ;321
0007b6  d0b7              BEQ      |L1.1832|
0007b8  465d              MOV      r5,r11                ;324
0007ba  4631              MOV      r1,r6                 ;324
0007bc  f8db0008          LDR      r0,[r11,#8]           ;324  ; ca
0007c0  f7fffffe          BL       __aeabi_memclr
0007c4  7920              LDRB     r0,[r4,#4]            ;327  ; mmc
0007c6  2801              CMP      r0,#1                 ;327
0007c8  d012              BEQ      |L1.2032|
0007ca  2802              CMP      r0,#2                 ;327
0007cc  d013              BEQ      |L1.2038|
0007ce  2803              CMP      r0,#3                 ;327
0007d0  d116              BNE      |L1.2048|
0007d2  e059              B        |L1.2184|
                  |L1.2004|
0007d4  f06f027e          MVN      r2,#0x7e              ;302
0007d8  eb021181          ADD      r1,r2,r1,LSL #6       ;302
0007dc  eb0a1287          ADD      r2,r10,r7,LSL #6      ;302
0007e0  fbb1f1f2          UDIV     r1,r1,r2              ;302
0007e4  f8a4901e          STRH     r9,[r4,#0x1e]         ;301
0007e8  61a1              STR      r1,[r4,#0x18]         ;303  ; mmc
0007ea  317f              ADDS     r1,r1,#0x7f           ;303
0007ec  09c9              LSRS     r1,r1,#7              ;303
0007ee  e7bd              B        |L1.1900|
                  |L1.2032|
0007f0  4922              LDR      r1,|L1.2172|
0007f2  68a8              LDR      r0,[r5,#8]            ;330  ; ca
0007f4  e002              B        |L1.2044|
                  |L1.2038|
0007f6  f06f0107          MVN      r1,#7                 ;332
0007fa  68a8              LDR      r0,[r5,#8]            ;332  ; ca
                  |L1.2044|
0007fc  f7fffffe          BL       set_u32
                  |L1.2048|
000800  8961              LDRH     r1,[r4,#0xa]          ;341  ; mmc
000802  6820              LDR      r0,[r4,#0]            ;341  ; mmc
000804  1846              ADDS     r6,r0,r1              ;341
000806  4630              MOV      r0,r6                 ;343
000808  f7fffffe          BL       write_cache
00080c  2800              CMP      r0,#0                 ;343
                  |L1.2062|
00080e  d08b              BEQ      |L1.1832|
000810  68a8              LDR      r0,[r5,#8]            ;344  ; ca
000812  6007              STR      r7,[r0,#0]            ;344
000814  6047              STR      r7,[r0,#4]            ;344
000816  6087              STR      r7,[r0,#8]            ;344
000818  8be0              LDRH     r0,[r4,#0x1e]         ;346  ; mmc
00081a  e031              B        |L1.2176|
                  |L1.2076|
                          DCD      ||.bss||+0xc
                  |L1.2080|
000820  4d535749          DCB      "MSWIN4.1",0
000824  4e342e31
000828  00      
000829  00                DCB      0
00082a  00                DCB      0
00082b  00                DCB      0
                  |L1.2092|
00082c  4e4f204e          DCB      "NO NAME    ",0
000830  414d4520
000834  20202000
                  |L1.2104|
000838  46415431          DCB      "FAT16   ",0
00083c  36202020
000840  00      
000841  00                DCB      0
000842  00                DCB      0
000843  00                DCB      0
                  |L1.2116|
000844  46415431          DCB      "FAT12   ",0
000848  32202020
00084c  00      
00084d  00                DCB      0
00084e  00                DCB      0
00084f  00                DCB      0
                  |L1.2128|
000850  46415433          DCB      "FAT32   ",0
000854  32202020
000858  00      
000859  00                DCB      0
00085a  00                DCB      0
00085b  00                DCB      0
                  |L1.2140|
                          DCD      ||.constdata||
                  |L1.2144|
000860  57495045          DCB      "WIPE",0
000864  00      
000865  00                DCB      0
000866  00                DCB      0
000867  00                DCB      0
                  |L1.2152|
                          DCD      _MC_CSIZE
                  |L1.2156|
00086c  46415433          DCB      "FAT32",0
000870  3200    
000872  00                DCB      0
000873  00                DCB      0
                  |L1.2164|
                          DCD      0xfffffc02
                  |L1.2168|
                          DCD      ||.data||
                  |L1.2172|
                          DCD      0x00fffff8
                  |L1.2176|
000880  7921              LDRB     r1,[r4,#4]            ;347  ; mmc
000882  2903              CMP      r1,#3                 ;347
000884  d00f              BEQ      |L1.2214|
000886  e00f              B        |L1.2216|
                  |L1.2184|
000888  49ff              LDR      r1,|L1.3208|
00088a  68a8              LDR      r0,[r5,#8]            ;336  ; ca
00088c  f7fffffe          BL       set_u32
000890  68a8              LDR      r0,[r5,#8]            ;337  ; ca
000892  f04f31ff          MOV      r1,#0xffffffff        ;337
000896  1d00              ADDS     r0,r0,#4              ;337
000898  f7fffffe          BL       set_u32
00089c  68a8              LDR      r0,[r5,#8]            ;338  ; ca
00089e  f06f4170          MVN      r1,#0xf0000000        ;338
0008a2  3008              ADDS     r0,r0,#8              ;338
0008a4  e7aa              B        |L1.2044|
                  |L1.2214|
0008a6  79a0              LDRB     r0,[r4,#6]            ;349  ; mmc
                  |L1.2216|
0008a8  8921              LDRH     r1,[r4,#8]            ;351  ; mmc
0008aa  2401              MOVS     r4,#1                 ;353
0008ac  eb000541          ADD      r5,r0,r1,LSL #1       ;351
0008b0  e005              B        |L1.2238|
                  |L1.2226|
0008b2  1930              ADDS     r0,r6,r4              ;354
0008b4  f7fffffe          BL       write_cache
0008b8  2800              CMP      r0,#0                 ;354
0008ba  d0a8              BEQ      |L1.2062|
0008bc  1c64              ADDS     r4,r4,#1              ;353
                  |L1.2238|
0008be  42ac              CMP      r4,r5                 ;353
0008c0  d3f7              BCC      |L1.2226|
0008c2  2000              MOVS     r0,#0                 ;357
0008c4  f7fffffe          BL       write_cache
0008c8  2800              CMP      r0,#0                 ;357
0008ca  d0a0              BEQ      |L1.2062|
0008cc  9804              LDR      r0,[sp,#0x10]         ;359
0008ce  7800              LDRB     r0,[r0,#0]            ;359
0008d0  b120              CBZ      r0,|L1.2268|
0008d2  9804              LDR      r0,[sp,#0x10]         ;361
0008d4  f7fffffe          BL       write_label
0008d8  2800              CMP      r0,#0                 ;361
0008da  d098              BEQ      |L1.2062|
                  |L1.2268|
0008dc  2001              MOVS     r0,#1                 ;363
0008de  e723              B        |L1.1832|
;;;365    
                          ENDP

                  fat_free PROC
;;;559    
;;;560    U64 fat_free (void) {
0008e0  b570              PUSH     {r4-r6,lr}
;;;561      /* Calculate a free space for Flash Card. */
;;;562    
;;;563      if (mmc.FatType == FS_RAW) {
0008e2  4dea              LDR      r5,|L1.3212|
0008e4  7928              LDRB     r0,[r5,#4]  ; mmc
0008e6  b148              CBZ      r0,|L1.2300|
;;;564        /* RAW File System or FAT not initialized. */
;;;565        return (0);
;;;566      }
;;;567    
;;;568      /* For FAT32 count only once. */
;;;569      if (mmc.FatType != FS_FAT32) {
;;;570        free_clus = count_free_clus ();
0008e8  4ce9              LDR      r4,|L1.3216|
0008ea  2803              CMP      r0,#3                 ;569
0008ec  d002              BEQ      |L1.2292|
0008ee  f7fffffe          BL       count_free_clus
0008f2  60a0              STR      r0,[r4,#8]  ; free_clus
                  |L1.2292|
;;;571      }
;;;572    
;;;573      if (free_clus > mmc.DataClusCnt) {
0008f4  69a8              LDR      r0,[r5,#0x18]  ; mmc
0008f6  68a1              LDR      r1,[r4,#8]  ; free_clus
0008f8  4288              CMP      r0,r1
0008fa  d201              BCS      |L1.2304|
                  |L1.2300|
0008fc  2000              MOVS     r0,#0                 ;565
0008fe  e001              B        |L1.2308|
                  |L1.2304|
;;;574        /* Error, something wrong. */
;;;575        return (0);
;;;576      }
;;;577      /* Return free data space in bytes. */
;;;578      return (free_clus * mmc.ClusSize);
000900  6a28              LDR      r0,[r5,#0x20]  ; mmc
000902  4348              MULS     r0,r1,r0
                  |L1.2308|
000904  2100              MOVS     r1,#0
;;;579    }
000906  bd70              POP      {r4-r6,pc}
;;;580    
                          ENDP

                  write_dot_entries PROC
;;;3088   
;;;3089   static BOOL write_dot_entries (IOB *fcb) {
000908  e92d47f0          PUSH     {r4-r10,lr}
00090c  4607              MOV      r7,r0
;;;3090     /* Create "." and ".." directory entries. */
;;;3091     FILEREC     *frec;
;;;3092     U16          time, date;
;;;3093     U32          idx           = 0;
;;;3094     U32          clus          = fcb->_firstClus;
;;;3095     U32          sect;
;;;3096   
;;;3097     /* Initialize local variables. */
;;;3098     time = get_time ();
00090e  f8d0801c          LDR      r8,[r0,#0x1c]
000912  f7fffffe          BL       get_time
000916  4606              MOV      r6,r0
;;;3099     date = get_date ();
000918  f7fffffe          BL       get_date
;;;3100   
;;;3101     /* Clear the buffer. */
;;;3102     memset (ca.buf, 0, 512);
00091c  f8df936c          LDR      r9,|L1.3212|
000920  4605              MOV      r5,r0                 ;3099
000922  f1a90914          SUB      r9,r9,#0x14
000926  464c              MOV      r4,r9
000928  f44f7100          MOV      r1,#0x200
00092c  f8d90008          LDR      r0,[r9,#8]  ; ca
000930  f7fffffe          BL       __aeabi_memclr
;;;3103   
;;;3104     /* Create "." entry. */
;;;3105     frec = (FILEREC *)ca.buf;
000934  68a4              LDR      r4,[r4,#8]  ; ca
;;;3106     memcpy (&frec->FileName[0], ".          ", 11);
000936  220b              MOVS     r2,#0xb
000938  a1d6              ADR      r1,|L1.3220|
00093a  4620              MOV      r0,r4
00093c  f7fffffe          BL       __aeabi_memcpy4
;;;3107     frec->Attr   = ATTR_DIRECTORY;
000940  2010              MOVS     r0,#0x10
000942  72e0              STRB     r0,[r4,#0xb]
000944  0a31              LSRS     r1,r6,#8
000946  73e1              STRB     r1,[r4,#0xf]
000948  73a6              STRB     r6,[r4,#0xe]
00094a  0a2b              LSRS     r3,r5,#8
00094c  7463              STRB     r3,[r4,#0x11]
00094e  7425              STRB     r5,[r4,#0x10]
000950  74e3              STRB     r3,[r4,#0x13]
000952  74a5              STRB     r5,[r4,#0x12]
000954  75e1              STRB     r1,[r4,#0x17]
000956  75a6              STRB     r6,[r4,#0x16]
000958  7663              STRB     r3,[r4,#0x19]
00095a  7625              STRB     r5,[r4,#0x18]
;;;3108     set_u16 ((U8 *)&frec->CrtTime, time);
;;;3109     set_u16 ((U8 *)&frec->CrtDate, date);
;;;3110     set_u16 ((U8 *)&frec->LastAccDate, date);
;;;3111     set_u16 ((U8 *)&frec->WriteTime, time);
;;;3112     set_u16 ((U8 *)&frec->WriteDate, date);
;;;3113   
;;;3114     /* Copy this record to ".." entry. */
;;;3115     memcpy (frec + 1, frec, sizeof (FILEREC));
00095c  f1040020          ADD      r0,r4,#0x20
000960  2220              MOVS     r2,#0x20
000962  4621              MOV      r1,r4
000964  4605              MOV      r5,r0
000966  f7fffffe          BL       __aeabi_memcpy4
;;;3116   
;;;3117     set_u16 ((U8 *)&frec->FirstClusHI, (fcb->_firstClus >> 16));
00096a  69f8              LDR      r0,[r7,#0x1c]
00096c  0c01              LSRS     r1,r0,#16
00096e  f1040014          ADD      r0,r4,#0x14
000972  f7fffffe          BL       set_u16
;;;3118     set_u16 ((U8 *)&frec->FirstClusLO, (fcb->_firstClus      ));
000976  69f8              LDR      r0,[r7,#0x1c]
000978  b281              UXTH     r1,r0
00097a  f104001a          ADD      r0,r4,#0x1a
00097e  f7fffffe          BL       set_u16
;;;3119   
;;;3120     /* Create ".." entry, modify "." entry differences. */
;;;3121     frec++;
;;;3122     frec->FileName[1] = '.';
;;;3123   
;;;3124     /* For Root folder FirstClusHI and FirstClusLO are 0. */
;;;3125     set_u16 ((U8 *)&frec->FirstClusHI, (startDirClus >> 16));
000982  4cc3              LDR      r4,|L1.3216|
000984  202e              MOVS     r0,#0x2e              ;3122
000986  7068              STRB     r0,[r5,#1]            ;3122
000988  6920              LDR      r0,[r4,#0x10]  ; startDirClus
00098a  0c01              LSRS     r1,r0,#16
00098c  f1050014          ADD      r0,r5,#0x14
000990  f7fffffe          BL       set_u16
;;;3126     set_u16 ((U8 *)&frec->FirstClusLO, (startDirClus      ));
000994  6920              LDR      r0,[r4,#0x10]  ; startDirClus
000996  b281              UXTH     r1,r0
000998  f105001a          ADD      r0,r5,#0x1a
00099c  f7fffffe          BL       set_u16
;;;3127   
;;;3128     /* Calculate address of sector where write will start. */
;;;3129     sect = clus_to_sect (clus);
0009a0  4640              MOV      r0,r8
0009a2  f7fffffe          BL       clus_to_sect
0009a6  4605              MOV      r5,r0
;;;3130     EX(write_sector (sect),__FALSE);
0009a8  f7fffffe          BL       write_sector
0009ac  2800              CMP      r0,#0
0009ae  d013              BEQ      |L1.2520|
;;;3131   
;;;3132     /* Clear the remaining sectors in the cluster. */
;;;3133     memset (ca.buf, 0, 2*sizeof (FILEREC));
0009b0  2140              MOVS     r1,#0x40
0009b2  f8d90008          LDR      r0,[r9,#8]  ; ca
0009b6  f7fffffe          BL       __aeabi_memclr
;;;3134     for (idx = 1; idx < mmc.SecPerClus; idx++) {
0009ba  2401              MOVS     r4,#1
0009bc  4eb3              LDR      r6,|L1.3212|
0009be  e005              B        |L1.2508|
                  |L1.2496|
;;;3135       EX(write_sector (sect + idx),__FALSE);
0009c0  1928              ADDS     r0,r5,r4
0009c2  f7fffffe          BL       write_sector
0009c6  2800              CMP      r0,#0
0009c8  d006              BEQ      |L1.2520|
0009ca  1c64              ADDS     r4,r4,#1              ;3134
                  |L1.2508|
0009cc  79b0              LDRB     r0,[r6,#6]            ;3134  ; mmc
0009ce  42a0              CMP      r0,r4                 ;3134
0009d0  d8f6              BHI      |L1.2496|
;;;3136     }
;;;3137   
;;;3138     /* Position fcb to point to first entry after ".." entry. */
;;;3139     fcb->fileID = 2;
0009d2  2002              MOVS     r0,#2
0009d4  8038              STRH     r0,[r7,#0]
;;;3140   
;;;3141     /* Entries written successfully. */
;;;3142     return (__TRUE);
0009d6  2001              MOVS     r0,#1
                  |L1.2520|
;;;3143   }
0009d8  e8bd87f0          POP      {r4-r10,pc}
;;;3144   
                          ENDP

                  clear_clus PROC
;;;1159   
;;;1160   static BOOL clear_clus (U32 clus) {
0009dc  b570              PUSH     {r4-r6,lr}
;;;1161     /* Clear current cluster. */
;;;1162     U32 i;
;;;1163     U32 sect = clus_to_sect(clus);
0009de  f7fffffe          BL       clus_to_sect
0009e2  4605              MOV      r5,r0
;;;1164   
;;;1165     /* Use cache for faster write. */
;;;1166     memset(ca.buf, 0, 512);
0009e4  48a9              LDR      r0,|L1.3212|
0009e6  f44f7100          MOV      r1,#0x200
0009ea  3814              SUBS     r0,r0,#0x14
0009ec  6880              LDR      r0,[r0,#8]  ; ca
0009ee  f7fffffe          BL       __aeabi_memclr
;;;1167     for (i = 0; i < mmc.SecPerClus; i++) {
0009f2  2400              MOVS     r4,#0
0009f4  4ea5              LDR      r6,|L1.3212|
0009f6  e005              B        |L1.2564|
                  |L1.2552|
;;;1168       EX(write_cache(sect + i),__FALSE);
0009f8  1928              ADDS     r0,r5,r4
0009fa  f7fffffe          BL       write_cache
0009fe  2800              CMP      r0,#0
000a00  d009              BEQ      |L1.2582|
000a02  1c64              ADDS     r4,r4,#1              ;1167
                  |L1.2564|
000a04  79b0              LDRB     r0,[r6,#6]            ;1167  ; mmc
000a06  42a0              CMP      r0,r4                 ;1167
000a08  d8f6              BHI      |L1.2552|
;;;1169     }
;;;1170     /* Flush the cache buffer when done. */
;;;1171     EX(write_cache (0),__FALSE);
000a0a  2000              MOVS     r0,#0
000a0c  f7fffffe          BL       write_cache
000a10  2800              CMP      r0,#0
000a12  d000              BEQ      |L1.2582|
;;;1172     return (__TRUE);
000a14  2001              MOVS     r0,#1
                  |L1.2582|
;;;1173   }
000a16  bd70              POP      {r4-r6,pc}
;;;1174   
                          ENDP

                  write_fat_link PROC
;;;1177   
;;;1178   static BOOL write_fat_link (U32 clus, U32 next_clus) {
000a18  e92d41f0          PUSH     {r4-r8,lr}
000a1c  460d              MOV      r5,r1
000a1e  4607              MOV      r7,r0
;;;1179     /* Write FAT table, update link cluster at cluster address. */
;;;1180     U32 sect,ofs,temp;
;;;1181   
;;;1182     sect = get_fat_sect (clus);
000a20  f7fffffe          BL       get_fat_sect
000a24  4680              MOV      r8,r0
;;;1183     EX(cache_fat (sect),__FALSE);
000a26  f7fffffe          BL       cache_fat
000a2a  2800              CMP      r0,#0
000a2c  d00b              BEQ      |L1.2630|
;;;1184   
;;;1185     switch (mmc.FatType) {
000a2e  4897              LDR      r0,|L1.3212|
;;;1186       case FS_FAT12:
;;;1187         next_clus &= 0x0FFF;
;;;1188         ofs  = ((clus * 3) / 2) & 0x1FF;
;;;1189         if (ofs < 511) {
;;;1190           temp = get_u16 (&fat.buf[ofs]);
000a30  4c96              LDR      r4,|L1.3212|
000a32  2601              MOVS     r6,#1                 ;1185
000a34  7900              LDRB     r0,[r0,#4]            ;1185  ; mmc
000a36  3c20              SUBS     r4,r4,#0x20
000a38  2801              CMP      r0,#1                 ;1185
000a3a  d005              BEQ      |L1.2632|
000a3c  2802              CMP      r0,#2                 ;1185
000a3e  d03e              BEQ      |L1.2750|
000a40  2803              CMP      r0,#3                 ;1185
000a42  d042              BEQ      |L1.2762|
;;;1191           if (clus & 0x001) {
;;;1192             temp = (temp & 0x000F) | (next_clus << 4);
;;;1193           }
;;;1194           else {
;;;1195             temp = (temp & 0xF000) | next_clus;
;;;1196           }
;;;1197           set_u16 (&fat.buf[ofs], temp);
;;;1198         }
;;;1199         else {
;;;1200           /* This cluster spans on two sectors in the FAT. */
;;;1201           if (clus & 0x001) {
;;;1202             fat.buf[511] = (fat.buf[511] & 0x0F) | (next_clus << 4);
;;;1203           }
;;;1204           else {
;;;1205             fat.buf[511] = (U8)next_clus;
;;;1206           }
;;;1207           fat.dirty = __TRUE;
;;;1208           sect++;
;;;1209           EX(cache_fat (sect),__FALSE);
;;;1210           if (clus & 0x001) {
;;;1211             fat.buf[0] = next_clus >> 4;
;;;1212           }
;;;1213           else {
;;;1214             fat.buf[0] = (fat.buf[0] & 0xF0) | (next_clus >> 8);
;;;1215           }
;;;1216         }
;;;1217         break;
;;;1218   
;;;1219       case FS_FAT16:
;;;1220         ofs  = (clus & 0xFF) << 1;
;;;1221         set_u16 (&fat.buf[ofs], next_clus);
;;;1222         break;
;;;1223   
;;;1224       case FS_FAT32:
;;;1225         ofs  = (clus & 0x7F) << 2;
;;;1226         if ((get_u32(&fat.buf[ofs]) == 0) && free_clus) {
;;;1227           free_clus--;
;;;1228         }
;;;1229   
;;;1230         set_u32 (&fat.buf[ofs], next_clus);
;;;1231         break;
;;;1232   
;;;1233       default:
;;;1234         return (__FALSE);
000a44  2000              MOVS     r0,#0
                  |L1.2630|
;;;1235     }
;;;1236     fat.dirty = __TRUE;
;;;1237     return (__TRUE);
;;;1238   }
000a46  e44c              B        |L1.738|
                  |L1.2632|
000a48  eb070047          ADD      r0,r7,r7,LSL #1       ;1188
000a4c  f3c00048          UBFX     r0,r0,#1,#9           ;1188
000a50  f3c5050b          UBFX     r5,r5,#0,#12          ;1187
000a54  f5b07fff          CMP      r0,#0x1fe             ;1189
000a58  d80f              BHI      |L1.2682|
000a5a  6861              LDR      r1,[r4,#4]            ;1191  ; fat
000a5c  07fa              LSLS     r2,r7,#31             ;1191
000a5e  4408              ADD      r0,r0,r1              ;1190
000a60  8801              LDRH     r1,[r0,#0]            ;1190
000a62  d002              BEQ      |L1.2666|
000a64  f365111f          BFI      r1,r5,#4,#28          ;1192
000a68  e002              B        |L1.2672|
                  |L1.2666|
000a6a  f4014170          AND      r1,r1,#0xf000         ;1195
000a6e  4329              ORRS     r1,r1,r5              ;1195
                  |L1.2672|
000a70  fa1ff181          UXTH.W   r1,r1                 ;1197
                  |L1.2676|
000a74  f7fffffe          BL       set_u16
000a78  e038              B        |L1.2796|
                  |L1.2682|
000a7a  07f8              LSLS     r0,r7,#31             ;1201
000a7c  d007              BEQ      |L1.2702|
000a7e  6861              LDR      r1,[r4,#4]            ;1202  ; fat
000a80  f89101ff          LDRB     r0,[r1,#0x1ff]        ;1202
000a84  f365101f          BFI      r0,r5,#4,#28          ;1202
000a88  f88101ff          STRB     r0,[r1,#0x1ff]        ;1202
000a8c  e002              B        |L1.2708|
                  |L1.2702|
000a8e  6860              LDR      r0,[r4,#4]            ;1205  ; fat
000a90  f88051ff          STRB     r5,[r0,#0x1ff]        ;1205
                  |L1.2708|
000a94  7226              STRB     r6,[r4,#8]            ;1207
000a96  f1080001          ADD      r0,r8,#1              ;1208
000a9a  f7fffffe          BL       cache_fat
000a9e  2800              CMP      r0,#0                 ;1209
000aa0  d0d1              BEQ      |L1.2630|
000aa2  07f8              LSLS     r0,r7,#31             ;1210
000aa4  d003              BEQ      |L1.2734|
000aa6  6861              LDR      r1,[r4,#4]            ;1211  ; fat
000aa8  0928              LSRS     r0,r5,#4              ;1211
000aaa  7008              STRB     r0,[r1,#0]            ;1211
000aac  e01e              B        |L1.2796|
                  |L1.2734|
000aae  6860              LDR      r0,[r4,#4]            ;1214  ; fat
000ab0  7801              LDRB     r1,[r0,#0]            ;1214
000ab2  f00101f0          AND      r1,r1,#0xf0           ;1214
000ab6  ea412115          ORR      r1,r1,r5,LSR #8       ;1214
000aba  7001              STRB     r1,[r0,#0]            ;1214
000abc  e016              B        |L1.2796|
                  |L1.2750|
000abe  6861              LDR      r1,[r4,#4]            ;1221  ; fat
000ac0  0638              LSLS     r0,r7,#24             ;1220
000ac2  eb0150d0          ADD      r0,r1,r0,LSR #23      ;1221
000ac6  b2a9              UXTH     r1,r5                 ;1221
000ac8  e7d4              B        |L1.2676|
                  |L1.2762|
000aca  0678              LSLS     r0,r7,#25             ;1225
000acc  0dc7              LSRS     r7,r0,#23             ;1225
000ace  6860              LDR      r0,[r4,#4]            ;1226  ; fat
000ad0  4438              ADD      r0,r0,r7              ;1226
000ad2  f7fffffe          BL       get_u32
000ad6  b920              CBNZ     r0,|L1.2786|
000ad8  486d              LDR      r0,|L1.3216|
000ada  6881              LDR      r1,[r0,#8]            ;1226  ; free_clus
000adc  b109              CBZ      r1,|L1.2786|
000ade  1e49              SUBS     r1,r1,#1              ;1227
000ae0  6081              STR      r1,[r0,#8]            ;1227  ; free_clus
                  |L1.2786|
000ae2  6860              LDR      r0,[r4,#4]            ;1230  ; fat
000ae4  4629              MOV      r1,r5                 ;1230
000ae6  4438              ADD      r0,r0,r7              ;1230
000ae8  f7fffffe          BL       set_u32
                  |L1.2796|
000aec  7226              STRB     r6,[r4,#8]            ;1236
000aee  2001              MOVS     r0,#1                 ;1237
000af0  e410              B        |L1.788|
;;;1239   
                          ENDP

                  get_free_clus PROC
;;;1080   
;;;1081   static BOOL get_free_clus (U32 *ptr_clus) {
000af2  e92d47f0          PUSH     {r4-r10,lr}
;;;1082     /* Scan FAT Table and find first free cluster. */
;;;1083     U32 sect,ofs,next;
;;;1084     U32 clus = *ptr_clus;
;;;1085   
;;;1086     for (clus = top_clus; clus < (mmc.DataClusCnt + 2); clus++) {
000af6  4f66              LDR      r7,|L1.3216|
;;;1087       /* Read a part of FAT table to buffer. */
;;;1088       sect = get_fat_sect (clus);
;;;1089       EX(cache_fat (sect),__FALSE);
;;;1090       switch (mmc.FatType) {
;;;1091         case FS_FAT12:
;;;1092           ofs  = ((clus * 3) / 2) & 0x1FF;
;;;1093           if (ofs < 511) {
;;;1094             next = get_u16 (&fat.buf[ofs]);
000af8  4d64              LDR      r5,|L1.3212|
000afa  4680              MOV      r8,r0                 ;1081
000afc  3d20              SUBS     r5,r5,#0x20
000afe  4e63              LDR      r6,|L1.3212|
000b00  68fc              LDR      r4,[r7,#0xc]          ;1086  ; top_clus
000b02  e054              B        |L1.2990|
                  |L1.2820|
000b04  4620              MOV      r0,r4                 ;1088
000b06  f7fffffe          BL       get_fat_sect
000b0a  4682              MOV      r10,r0                ;1088
000b0c  f7fffffe          BL       cache_fat
000b10  2800              CMP      r0,#0                 ;1089
000b12  d035              BEQ      |L1.2944|
000b14  7930              LDRB     r0,[r6,#4]            ;1090  ; mmc
000b16  2801              CMP      r0,#1                 ;1090
000b18  d004              BEQ      |L1.2852|
000b1a  2802              CMP      r0,#2                 ;1090
000b1c  d021              BEQ      |L1.2914|
000b1e  2803              CMP      r0,#3                 ;1090
000b20  d12d              BNE      |L1.2942|
000b22  e024              B        |L1.2926|
                  |L1.2852|
000b24  eb040044          ADD      r0,r4,r4,LSL #1       ;1092
000b28  f3c00048          UBFX     r0,r0,#1,#9           ;1092
000b2c  f5b07fff          CMP      r0,#0x1fe             ;1093
000b30  d803              BHI      |L1.2874|
000b32  6869              LDR      r1,[r5,#4]  ; fat
000b34  4408              ADD      r0,r0,r1
000b36  8800              LDRH     r0,[r0,#0]
000b38  e00c              B        |L1.2900|
                  |L1.2874|
;;;1095           }
;;;1096           else {
;;;1097             /* This cluster spans on two sectors in the FAT. */
;;;1098             next = fat.buf[511];
000b3a  6868              LDR      r0,[r5,#4]  ; fat
000b3c  f89091ff          LDRB     r9,[r0,#0x1ff]
;;;1099             EX(cache_fat (sect+1),__FALSE);
000b40  f10a0001          ADD      r0,r10,#1
000b44  f7fffffe          BL       cache_fat
000b48  2800              CMP      r0,#0
000b4a  d019              BEQ      |L1.2944|
;;;1100             next |= fat.buf[0] << 8;
000b4c  6868              LDR      r0,[r5,#4]  ; fat
000b4e  7801              LDRB     r1,[r0,#0]
000b50  ea492001          ORR      r0,r9,r1,LSL #8
                  |L1.2900|
;;;1101           }
;;;1102           if (clus & 0x001) {
000b54  07e1              LSLS     r1,r4,#31
000b56  d001              BEQ      |L1.2908|
;;;1103             next >>= 4;
000b58  0900              LSRS     r0,r0,#4
000b5a  e00e              B        |L1.2938|
                  |L1.2908|
;;;1104           }
;;;1105           else {
;;;1106             next &= 0xFFF;
000b5c  f3c0000b          UBFX     r0,r0,#0,#12
000b60  e00b              B        |L1.2938|
                  |L1.2914|
;;;1107           }
;;;1108           break;
;;;1109   
;;;1110         case FS_FAT16:
;;;1111           ofs  = (clus & 0xFF) << 1;
;;;1112           next = get_u16 (&fat.buf[ofs]);
000b62  6869              LDR      r1,[r5,#4]  ; fat
000b64  0620              LSLS     r0,r4,#24             ;1111
000b66  eb0150d0          ADD      r0,r1,r0,LSR #23
000b6a  8800              LDRH     r0,[r0,#0]
;;;1113           break;
000b6c  e005              B        |L1.2938|
                  |L1.2926|
;;;1114   
;;;1115         case FS_FAT32:
;;;1116           ofs  = (clus & 0x7F) << 2;
;;;1117           next = get_u32 (&fat.buf[ofs]);
000b6e  6869              LDR      r1,[r5,#4]  ; fat
000b70  0660              LSLS     r0,r4,#25             ;1116
000b72  eb0150d0          ADD      r0,r1,r0,LSR #23
000b76  f7fffffe          BL       get_u32
                  |L1.2938|
;;;1118           break;
;;;1119   
;;;1120         default:
;;;1121           return (__FALSE);
;;;1122       }
;;;1123       if (next == 0) {
000b7a  b110              CBZ      r0,|L1.2946|
000b7c  e016              B        |L1.2988|
                  |L1.2942|
000b7e  2000              MOVS     r0,#0                 ;1121
                  |L1.2944|
;;;1124         if (clus_in_use (clus) == __FALSE) {
;;;1125           *ptr_clus = clus;
;;;1126           top_clus  = clus + 1;
;;;1127           return (__TRUE);
;;;1128         }
;;;1129       }
;;;1130     }
;;;1131     /* Disk Full, no free clusters found. */
;;;1132     top_clus = clus;
;;;1133     return (__FALSE);
;;;1134   }
000b80  e72a              B        |L1.2520|
                  |L1.2946|
000b82  4847              LDR      r0,|L1.3232|
000b84  2100              MOVS     r1,#0
000b86  8802              LDRH     r2,[r0,#0]  ; _NFILE
000b88  4846              LDR      r0,|L1.3236|
000b8a  e007              B        |L1.2972|
                  |L1.2956|
000b8c  8843              LDRH     r3,[r0,#2]
000b8e  079b              LSLS     r3,r3,#30
000b90  d502              BPL      |L1.2968|
000b92  6a83              LDR      r3,[r0,#0x28]
000b94  42a3              CMP      r3,r4
000b96  d009              BEQ      |L1.2988|
                  |L1.2968|
000b98  3034              ADDS     r0,r0,#0x34
000b9a  1c49              ADDS     r1,r1,#1
                  |L1.2972|
000b9c  4291              CMP      r1,r2
000b9e  d3f5              BCC      |L1.2956|
000ba0  f8c84000          STR      r4,[r8,#0]            ;1126
000ba4  1c64              ADDS     r4,r4,#1              ;1126
000ba6  2001              MOVS     r0,#1                 ;1127
000ba8  60fc              STR      r4,[r7,#0xc]          ;1127  ; top_clus
000baa  e715              B        |L1.2520|
                  |L1.2988|
000bac  1c64              ADDS     r4,r4,#1              ;1086
                  |L1.2990|
000bae  69b0              LDR      r0,[r6,#0x18]         ;1086  ; mmc
000bb0  1c80              ADDS     r0,r0,#2              ;1086
000bb2  42a0              CMP      r0,r4                 ;1086
000bb4  d8a6              BHI      |L1.2820|
000bb6  60fc              STR      r4,[r7,#0xc]          ;1133  ; top_clus
000bb8  e7e1              B        |L1.2942|
;;;1135   
                          ENDP

                  alloc_new_clus PROC
;;;1329   
;;;1330   static BOOL alloc_new_clus (U32 *ptr_clus, U8 wr_fat_link) {
000bba  b570              PUSH     {r4-r6,lr}
000bbc  460d              MOV      r5,r1
000bbe  4604              MOV      r4,r0
;;;1331     /* Allocate a new cluster. */
;;;1332     U32 clus = *ptr_clus;
;;;1333   
;;;1334     EX(get_free_clus (ptr_clus),__FALSE);
000bc0  6806              LDR      r6,[r0,#0]
000bc2  f7fffffe          BL       get_free_clus
000bc6  2800              CMP      r0,#0
000bc8  d014              BEQ      |L1.3060|
;;;1335   
;;;1336     EX(write_fat_link (*ptr_clus, get_EOC()),__FALSE);
000bca  f7fffffe          BL       get_EOC
000bce  4601              MOV      r1,r0
000bd0  6820              LDR      r0,[r4,#0]
000bd2  f7fffffe          BL       write_fat_link
000bd6  2800              CMP      r0,#0
000bd8  d00c              BEQ      |L1.3060|
;;;1337     if (wr_fat_link) {
000bda  b12d              CBZ      r5,|L1.3048|
;;;1338       /* Update also a FAT cluster chain. */
;;;1339       EX(write_fat_link (clus, *ptr_clus),__FALSE);
000bdc  4630              MOV      r0,r6
000bde  6821              LDR      r1,[r4,#0]
000be0  f7fffffe          BL       write_fat_link
000be4  2800              CMP      r0,#0
000be6  d005              BEQ      |L1.3060|
                  |L1.3048|
;;;1340     }
;;;1341     EX(cache_fat (0),__FALSE);
000be8  2000              MOVS     r0,#0
000bea  f7fffffe          BL       cache_fat
000bee  2800              CMP      r0,#0
000bf0  d000              BEQ      |L1.3060|
;;;1342   
;;;1343     /* New cluster allocated successfully. */
;;;1344     return (__TRUE);
000bf2  2001              MOVS     r0,#1
                  |L1.3060|
;;;1345   }
000bf4  bd70              POP      {r4-r6,pc}
;;;1346   
                          ENDP

                  cvt_fatname PROC
;;;1833   
;;;1834   static BOOL cvt_fatname (const char *fn, char *en) {
000bf6  e92d41f0          PUSH     {r4-r8,lr}
;;;1835     /* Convert name to short file entry name. */
;;;1836     /* fn = pointer to the file name
;;;1837        en = pointer to the entry file name */
;;;1838     BOOL dot = 0;
000bfa  2700              MOVS     r7,#0
000bfc  4604              MOV      r4,r0                 ;1834
000bfe  460d              MOV      r5,r1                 ;1834
;;;1839     U8   ch0, ch1, ch2;
;;;1840     U32  i;
;;;1841   
;;;1842     /* Prepare entry name with 'space's. */
;;;1843     for (i = 0; i < 11; i++) {
000c00  4638              MOV      r0,r7
;;;1844       en[i] = ' ';
000c02  2120              MOVS     r1,#0x20
                  |L1.3076|
000c04  5429              STRB     r1,[r5,r0]
000c06  1c40              ADDS     r0,r0,#1              ;1843
000c08  280b              CMP      r0,#0xb               ;1843
000c0a  d3fb              BCC      |L1.3076|
;;;1845     }
;;;1846     /* Terminate entry name. */
;;;1847     en[i] = 0;
000c0c  2100              MOVS     r1,#0
000c0e  5429              STRB     r1,[r5,r0]
;;;1848   
;;;1849     /* Check for "." and ".." name */
;;;1850     ch0 = *fn;
000c10  7821              LDRB     r1,[r4,#0]
;;;1851     ch1 = *(fn + 1);
000c12  7862              LDRB     r2,[r4,#1]
;;;1852     ch2 = *(fn + 2);
000c14  78a0              LDRB     r0,[r4,#2]
;;;1853     if (ch0 == '.') {
000c16  292e              CMP      r1,#0x2e
000c18  d106              BNE      |L1.3112|
;;;1854       if (ch1 == 0) {
000c1a  b112              CBZ      r2,|L1.3106|
;;;1855         en[0] = '.';
;;;1856         return (__TRUE);
;;;1857       }
;;;1858       else if (ch1 == '.' && ch2 == 0) {
000c1c  2a2e              CMP      r2,#0x2e
000c1e  d002              BEQ      |L1.3110|
000c20  e002              B        |L1.3112|
                  |L1.3106|
000c22  7029              STRB     r1,[r5,#0]            ;1855
000c24  e043              B        |L1.3246|
                  |L1.3110|
000c26  b1a8              CBZ      r0,|L1.3156|
                  |L1.3112|
;;;1859         en[0] = '.';
;;;1860         en[1] = '.';
;;;1861         return (__TRUE);
;;;1862       }
;;;1863     }
;;;1864   
;;;1865     /* Copy name part (maximum 8 characters) */
;;;1866     for (i = 0; i < 8; ) {
000c28  2600              MOVS     r6,#0
                  |L1.3114|
;;;1867       if (!(*fn))     {          return (__TRUE); }
000c2a  7820              LDRB     r0,[r4,#0]
000c2c  b3e0              CBZ      r0,|L1.3240|
;;;1868       if (*fn == '.') { dot = 1; fn++; break;     }
000c2e  282e              CMP      r0,#0x2e
000c30  d013              BEQ      |L1.3162|
;;;1869       if (*fn == ' ') {          fn++; continue;  }
000c32  2820              CMP      r0,#0x20
000c34  d00a              BEQ      |L1.3148|
;;;1870       en[i] = val_char(*fn);
000c36  f7fffffe          BL       val_char
;;;1871       if (en[i] >= 'a' && en[i] <= 'z')
000c3a  f1a00161          SUB      r1,r0,#0x61
000c3e  55a8              STRB     r0,[r5,r6]            ;1870
000c40  2919              CMP      r1,#0x19
000c42  d802              BHI      |L1.3146|
;;;1872         en[i] = en[i] & (~0x20);
000c44  f0200020          BIC      r0,r0,#0x20
000c48  55a8              STRB     r0,[r5,r6]
                  |L1.3146|
;;;1873       i  ++;
000c4a  1c76              ADDS     r6,r6,#1
                  |L1.3148|
000c4c  1c64              ADDS     r4,r4,#1              ;1869
000c4e  2e08              CMP      r6,#8                 ;1866
000c50  d3eb              BCC      |L1.3114|
000c52  e004              B        |L1.3166|
                  |L1.3156|
000c54  7029              STRB     r1,[r5,#0]            ;1859
000c56  7069              STRB     r1,[r5,#1]            ;1860
000c58  e029              B        |L1.3246|
                  |L1.3162|
000c5a  2701              MOVS     r7,#1                 ;1868
000c5c  1c64              ADDS     r4,r4,#1              ;1868
                  |L1.3166|
;;;1874       fn ++;
;;;1875     }
;;;1876   
;;;1877     /* Copy extension part (maximum 3 characters) */
;;;1878     for (i = 8; i < 11; ) {
000c5e  2608              MOVS     r6,#8
                  |L1.3168|
;;;1879       if (!(*fn))     {         return (__TRUE); }
000c60  7820              LDRB     r0,[r4,#0]
000c62  b308              CBZ      r0,|L1.3240|
;;;1880       if (*fn == '.') { dot = 1; fn++; continue; }
000c64  282e              CMP      r0,#0x2e
000c66  d024              BEQ      |L1.3250|
;;;1881       if (*fn == ' ') {          fn++; continue; }
000c68  2820              CMP      r0,#0x20
000c6a  d00b              BEQ      |L1.3204|
;;;1882       if (dot)        {
000c6c  b157              CBZ      r7,|L1.3204|
;;;1883         en[i] = val_char(*fn);
000c6e  f7fffffe          BL       val_char
;;;1884         if (en[i] >= 'a' && en[i] <= 'z')
000c72  f1a00161          SUB      r1,r0,#0x61
000c76  55a8              STRB     r0,[r5,r6]            ;1883
000c78  2919              CMP      r1,#0x19
000c7a  d802              BHI      |L1.3202|
;;;1885           en[i] = en[i] & (~0x20);
000c7c  f0200020          BIC      r0,r0,#0x20
000c80  55a8              STRB     r0,[r5,r6]
                  |L1.3202|
;;;1886         i  ++;
000c82  1c76              ADDS     r6,r6,#1
                  |L1.3204|
;;;1887       }
;;;1888       fn ++;
000c84  1c64              ADDS     r4,r4,#1
000c86  e010              B        |L1.3242|
                  |L1.3208|
                          DCD      0x0ffffff8
                  |L1.3212|
                          DCD      ||.bss||+0x20
                  |L1.3216|
                          DCD      ||.data||
                  |L1.3220|
000c94  2e202020          DCB      ".          ",0
000c98  20202020
000c9c  20202000
                  |L1.3232|
                          DCD      _NFILE
                  |L1.3236|
                          DCD      _iob
                  |L1.3240|
000ca8  e001              B        |L1.3246|
                  |L1.3242|
000caa  2e0b              CMP      r6,#0xb               ;1878
000cac  d3d8              BCC      |L1.3168|
                  |L1.3246|
;;;1889     }
;;;1890     return (__TRUE);
000cae  2001              MOVS     r0,#1
;;;1891   }
000cb0  e6c9              B        |L1.2630|
                  |L1.3250|
000cb2  2701              MOVS     r7,#1                 ;1880
000cb4  e7e6              B        |L1.3204|
;;;1892   
                          ENDP

                  is_EOC PROC
;;;1613   
;;;1614   static BOOL is_EOC (U32 clus) {
000cb6  49ff              LDR      r1,|L1.4276|
;;;1615     /* Check if this cluster is an End Of Chain Marker. */
;;;1616   
;;;1617     switch (mmc.FatType) {
000cb8  7909              LDRB     r1,[r1,#4]  ; mmc
000cba  2901              CMP      r1,#1
000cbc  d004              BEQ      |L1.3272|
000cbe  2902              CMP      r1,#2
000cc0  d005              BEQ      |L1.3278|
000cc2  2903              CMP      r1,#3
000cc4  d10d              BNE      |L1.3298|
000cc6  e008              B        |L1.3290|
                  |L1.3272|
;;;1618       case FS_FAT12:
;;;1619         if (clus >= 0x0FF8) {
000cc8  f64071f8          MOV      r1,#0xff8
000ccc  e001              B        |L1.3282|
                  |L1.3278|
;;;1620           return (__TRUE);
;;;1621         }
;;;1622         break;
;;;1623       case FS_FAT16:
;;;1624         if (clus >= 0xFFF8) {
000cce  f64f71f8          MOV      r1,#0xfff8
                  |L1.3282|
000cd2  4288              CMP      r0,r1                 ;1619
000cd4  d305              BCC      |L1.3298|
;;;1625           return (__TRUE);
;;;1626         }
;;;1627         break;
;;;1628       case FS_FAT32:
;;;1629         if ((clus & 0x0FFFFFFF) >= 0x0FFFFFF8) {
;;;1630           return (__TRUE);
000cd6  2001              MOVS     r0,#1
;;;1631         }
;;;1632         break;
;;;1633     }
;;;1634     return (__FALSE);
;;;1635   }
000cd8  4770              BX       lr
                  |L1.3290|
000cda  f0204070          BIC      r0,r0,#0xf0000000     ;1629
000cde  49f6              LDR      r1,|L1.4280|
000ce0  e7f7              B        |L1.3282|
                  |L1.3298|
000ce2  2000              MOVS     r0,#0                 ;1634
000ce4  4770              BX       lr
;;;1636   
                          ENDP

                  set_next_clus PROC
;;;1031   
;;;1032   static BOOL set_next_clus (U32 *ptr_clus) {
000ce6  e92d41f0          PUSH     {r4-r8,lr}
;;;1033     /* Read next Cluster address from FAT table. */
;;;1034     U32 sect,ofs,next;
;;;1035     U32 clus = *ptr_clus;
;;;1036   
;;;1037     /* Read a part of FAT table to buffer. */
;;;1038     sect = get_fat_sect (clus);
000cea  6804              LDR      r4,[r0,#0]
000cec  4605              MOV      r5,r0                 ;1032
000cee  4620              MOV      r0,r4
000cf0  f7fffffe          BL       get_fat_sect
000cf4  4680              MOV      r8,r0
;;;1039     EX(cache_fat (sect),__FALSE);
000cf6  f7fffffe          BL       cache_fat
000cfa  2800              CMP      r0,#0
000cfc  d00a              BEQ      |L1.3348|
;;;1040     next = 0;
;;;1041     switch (mmc.FatType) {
000cfe  48ed              LDR      r0,|L1.4276|
;;;1042       case FS_FAT12:
;;;1043         ofs  = ((clus * 3) / 2) & 0x1FF;
;;;1044         if (ofs < 511) {
;;;1045           next = get_u16 (&fat.buf[ofs]);
000d00  4eec              LDR      r6,|L1.4276|
000d02  7900              LDRB     r0,[r0,#4]            ;1041  ; mmc
000d04  3e20              SUBS     r6,r6,#0x20
000d06  2801              CMP      r0,#1                 ;1041
000d08  d005              BEQ      |L1.3350|
000d0a  2802              CMP      r0,#2                 ;1041
000d0c  d022              BEQ      |L1.3412|
000d0e  2803              CMP      r0,#3                 ;1041
000d10  d025              BEQ      |L1.3422|
;;;1046         }
;;;1047         else {
;;;1048           /* This cluster spans on two sectors in the FAT. */
;;;1049           next = fat.buf[511];
;;;1050           EX(cache_fat (sect+1),__FALSE);
;;;1051           next |= fat.buf[0] << 8;
;;;1052         }
;;;1053         if (clus & 0x001) {
;;;1054           next >>= 4;
;;;1055         }
;;;1056         else {
;;;1057           next &= 0xFFF;
;;;1058         }
;;;1059         break;
;;;1060   
;;;1061       case FS_FAT16:
;;;1062         ofs  = (clus & 0xFF) << 1;
;;;1063         next = *(U16 *)&fat.buf[ofs];
;;;1064         break;
;;;1065   
;;;1066       case FS_FAT32:
;;;1067         ofs  = (clus & 0x7F) << 2;
;;;1068         next = *(U32 *)&fat.buf[ofs];
;;;1069         break;
;;;1070   
;;;1071       default:
;;;1072         return (__FALSE);
000d12  2000              MOVS     r0,#0
                  |L1.3348|
;;;1073     }
;;;1074     *ptr_clus = next;
;;;1075     return (__TRUE);
;;;1076   }
000d14  e697              B        |L1.2630|
                  |L1.3350|
000d16  eb040044          ADD      r0,r4,r4,LSL #1       ;1043
000d1a  f3c00048          UBFX     r0,r0,#1,#9           ;1043
000d1e  f5b07fff          CMP      r0,#0x1fe             ;1044
000d22  d803              BHI      |L1.3372|
000d24  6871              LDR      r1,[r6,#4]            ;1045  ; fat
000d26  4408              ADD      r0,r0,r1              ;1045
000d28  8800              LDRH     r0,[r0,#0]            ;1045
000d2a  e00c              B        |L1.3398|
                  |L1.3372|
000d2c  6870              LDR      r0,[r6,#4]            ;1049  ; fat
000d2e  f89071ff          LDRB     r7,[r0,#0x1ff]        ;1049
000d32  f1080001          ADD      r0,r8,#1              ;1050
000d36  f7fffffe          BL       cache_fat
000d3a  2800              CMP      r0,#0                 ;1050
000d3c  d0ea              BEQ      |L1.3348|
000d3e  6870              LDR      r0,[r6,#4]            ;1051  ; fat
000d40  7800              LDRB     r0,[r0,#0]            ;1051
000d42  ea472000          ORR      r0,r7,r0,LSL #8       ;1051
                  |L1.3398|
000d46  07e1              LSLS     r1,r4,#31             ;1053
000d48  d001              BEQ      |L1.3406|
000d4a  0900              LSRS     r0,r0,#4              ;1054
000d4c  e00b              B        |L1.3430|
                  |L1.3406|
000d4e  f3c0000b          UBFX     r0,r0,#0,#12          ;1057
000d52  e008              B        |L1.3430|
                  |L1.3412|
000d54  6871              LDR      r1,[r6,#4]            ;1063  ; fat
000d56  0620              LSLS     r0,r4,#24             ;1062
000d58  0dc0              LSRS     r0,r0,#23             ;1062
000d5a  5a08              LDRH     r0,[r1,r0]            ;1063
000d5c  e003              B        |L1.3430|
                  |L1.3422|
000d5e  0660              LSLS     r0,r4,#25             ;1067
000d60  6871              LDR      r1,[r6,#4]            ;1068  ; fat
000d62  0dc0              LSRS     r0,r0,#23             ;1067
000d64  5808              LDR      r0,[r1,r0]            ;1068
                  |L1.3430|
000d66  6028              STR      r0,[r5,#0]            ;1075
000d68  2001              MOVS     r0,#1                 ;1075
000d6a  e66c              B        |L1.2630|
;;;1077   
                          ENDP

                  get_dir_sect PROC
;;;2172   
;;;2173   static U32 get_dir_sect (U32 clus) {
000d6c  49d3              LDR      r1,|L1.4284|
;;;2174     /* Calculate sector address of the cluster, and update in_root_1x flag. */
;;;2175     U32 sect;
;;;2176   
;;;2177     in_root_1x = 0;
000d6e  2200              MOVS     r2,#0
000d70  704a              STRB     r2,[r1,#1]
;;;2178     if (clus == 0) {
000d72  b958              CBNZ     r0,|L1.3468|
;;;2179       startDirClus = 0;
;;;2180   
;;;2181       /* This is a ROOT folder. */
;;;2182       if (mmc.FatType == FS_FAT32) {
000d74  48cf              LDR      r0,|L1.4276|
000d76  610a              STR      r2,[r1,#0x10]  ; startDirClus
000d78  7902              LDRB     r2,[r0,#4]  ; mmc
000d7a  2a03              CMP      r2,#3
000d7c  d005              BEQ      |L1.3466|
;;;2183         /* This is a ROOT folder on FAT32. */
;;;2184         sect = clus_to_sect (mmc.FAT32_RootClus);
;;;2185       }
;;;2186       else {
;;;2187         /* This is a ROOT folder on FAT12 or FAT16. */
;;;2188         sect = mmc.BootRecSec + mmc.RootDirAddr;
000d7e  6802              LDR      r2,[r0,#0]  ; mmc
000d80  8b80              LDRH     r0,[r0,#0x1c]  ; mmc
;;;2189         in_root_1x = 1;
000d82  2301              MOVS     r3,#1
000d84  4410              ADD      r0,r0,r2              ;2188
000d86  704b              STRB     r3,[r1,#1]
;;;2190       }
;;;2191     }
;;;2192     else {
;;;2193       /* This is a subfolder. */
;;;2194       sect = clus_to_sect (clus);
;;;2195     }
;;;2196     return (sect);
;;;2197   }
000d88  4770              BX       lr
                  |L1.3466|
000d8a  6a80              LDR      r0,[r0,#0x28]         ;2184  ; mmc
                  |L1.3468|
000d8c  f7ffbffe          B.W      clus_to_sect
;;;2198   
                          ENDP

                  check_lfn PROC
;;;1895   
;;;1896   static BOOL check_lfn (const char *fn) {
000d90  e92d41f0          PUSH     {r4-r8,lr}
;;;1897     /* Check if "fn" is a long name. */
;;;1898     BOOL dot = 0;
000d94  2700              MOVS     r7,#0
000d96  4604              MOV      r4,r0                 ;1896
;;;1899     U8   ch, prev_ch = 0;
000d98  46b8              MOV      r8,r7
;;;1900     U32  i = 0, j = 0;
000d9a  463d              MOV      r5,r7
000d9c  463e              MOV      r6,r7
;;;1901   
;;;1902     while (*fn) {
000d9e  e025              B        |L1.3564|
                  |L1.3488|
;;;1903       if (val_char_sn (*fn) == __FALSE) {
000da0  f7fffffe          BL       val_char_sn
000da4  b338              CBZ      r0,|L1.3574|
;;;1904         goto lfn;
;;;1905       }
;;;1906   
;;;1907       /* If 'space' exists in name then it is a long name. */
;;;1908       if (*fn == ' ') goto lfn;
000da6  7820              LDRB     r0,[r4,#0]
000da8  2820              CMP      r0,#0x20
000daa  d024              BEQ      |L1.3574|
;;;1909   
;;;1910       /* If '.' exists in name more then once or if there are more then 3 
;;;1911          valid characters after '.' then it is a long name. */
;;;1912       if (*fn == '.') {
000dac  282e              CMP      r0,#0x2e
000dae  d014              BEQ      |L1.3546|
;;;1913         if (dot) goto lfn;
;;;1914         fn ++;
;;;1915         j   = 0;
;;;1916         dot = 1;
;;;1917         continue;
;;;1918       }
;;;1919   
;;;1920       /* If cases (upper or lower) of letter are different then it is a 
;;;1921          long name. */
;;;1922       ch = *fn;
;;;1923       if ((ch >= 'a' && ch <= 'z') ||
000db0  f1a00161          SUB      r1,r0,#0x61
000db4  2919              CMP      r1,#0x19
000db6  d902              BLS      |L1.3518|
;;;1924           (ch >= 'A' && ch <= 'Z')) {
000db8  3120              ADDS     r1,r1,#0x20
000dba  2919              CMP      r1,#0x19
000dbc  d807              BHI      |L1.3534|
                  |L1.3518|
;;;1925         if (prev_ch && ((prev_ch ^ ch) & 0x20)) {
000dbe  f1b80f00          CMP      r8,#0
000dc2  d003              BEQ      |L1.3532|
000dc4  ea880100          EOR      r1,r8,r0
000dc8  0689              LSLS     r1,r1,#26
000dca  d414              BMI      |L1.3574|
                  |L1.3532|
;;;1926           goto lfn;
;;;1927         }
;;;1928         prev_ch = ch;
000dcc  4680              MOV      r8,r0
                  |L1.3534|
;;;1929       }
;;;1930   
;;;1931       if (dot) {
000dce  b14f              CBZ      r7,|L1.3556|
;;;1932         if (j++ > 2) 
000dd0  4630              MOV      r0,r6
000dd2  1c76              ADDS     r6,r6,#1
000dd4  2802              CMP      r0,#2
000dd6  d80e              BHI      |L1.3574|
000dd8  e006              B        |L1.3560|
                  |L1.3546|
000dda  b967              CBNZ     r7,|L1.3574|
000ddc  1c64              ADDS     r4,r4,#1              ;1914
000dde  2600              MOVS     r6,#0                 ;1915
000de0  2701              MOVS     r7,#1                 ;1916
000de2  e003              B        |L1.3564|
                  |L1.3556|
;;;1933           goto lfn;
;;;1934       } else if (i >= 8) {
000de4  2d08              CMP      r5,#8
000de6  d206              BCS      |L1.3574|
                  |L1.3560|
;;;1935         goto lfn;
;;;1936       }
;;;1937       i  ++;
000de8  1c6d              ADDS     r5,r5,#1
;;;1938       fn ++;
000dea  1c64              ADDS     r4,r4,#1
                  |L1.3564|
000dec  7820              LDRB     r0,[r4,#0]            ;1902
000dee  2800              CMP      r0,#0                 ;1902
000df0  d1d6              BNE      |L1.3488|
;;;1939     }
;;;1940   
;;;1941     if (i >= 12) {
000df2  2d0c              CMP      r5,#0xc
000df4  d301              BCC      |L1.3578|
                  |L1.3574|
;;;1942       /* This is a long name. */
;;;1943   lfn:return (__TRUE);
000df6  2001              MOVS     r0,#1
;;;1944     }
;;;1945   
;;;1946     /* This is a short name. */
;;;1947     return (__FALSE);
;;;1948   }
000df8  e625              B        |L1.2630|
                  |L1.3578|
000dfa  2000              MOVS     r0,#0                 ;1947
000dfc  e623              B        |L1.2630|
;;;1949   
                          ENDP

                  search_for_name PROC
;;;2201   
;;;2202   static BOOL search_for_name (const char *name, IOB *fcb, U8 type, U8 keep_fcb) {
000dfe  e92d4fff          PUSH     {r0-r11,lr}
000e02  b08d              SUB      sp,sp,#0x34
;;;2203     /* Search for entries with requested name and of requested type 
;;;2204        (file or dir).                                                         */
;;;2205   
;;;2206     char         sen[13];
;;;2207     FILEREC     *frec;
;;;2208     U8           lfn_f         = 0;
000e04  2000              MOVS     r0,#0
000e06  460e              MOV      r6,r1                 ;2202
;;;2209     U8           dir_f         = (type == ENT_DIR);
000e08  9006              STR      r0,[sp,#0x18]
000e0a  2a01              CMP      r2,#1
000e0c  d014              BEQ      |L1.3640|
                  |L1.3598|
;;;2210     U8           same_f        = 1;
000e0e  900a              STR      r0,[sp,#0x28]
000e10  2001              MOVS     r0,#1
;;;2211     U8           type_f        = 0;
;;;2212     U8           sfn_name_f    = __FALSE;
;;;2213     U8           chksum        = 0;
000e12  9001              STR      r0,[sp,#4]
000e14  2000              MOVS     r0,#0
;;;2214     U8           ents          = 0;
000e16  4607              MOV      r7,r0
;;;2215     U8           name_ents     = 1;
;;;2216     U32          clus          = fcb->_firstClus;
000e18  9007              STR      r0,[sp,#0x1c]
000e1a  69f0              LDR      r0,[r6,#0x1c]
;;;2217     U32          idx;
;;;2218     U32          first_clus    = 0;
000e1c  2100              MOVS     r1,#0
;;;2219     U32          first_offs    = 0;
;;;2220     U32          sect;
;;;2221     U32          i;
;;;2222   
;;;2223     startDirClus = fcb->_firstClus;
000e1e  4ca7              LDR      r4,|L1.4284|
000e20  9108              STR      r1,[sp,#0x20]
000e22  9000              STR      r0,[sp,#0]
;;;2224   
;;;2225     /* Calculate number of requested entries needed for name. */
;;;2226     if (check_lfn(name) == __TRUE) {
000e24  6120              STR      r0,[r4,#0x10]  ; startDirClus
000e26  f04f0a01          MOV      r10,#1                ;2215
000e2a  468b              MOV      r11,r1                ;2219
000e2c  980d              LDR      r0,[sp,#0x34]
000e2e  f7fffffe          BL       check_lfn
000e32  2801              CMP      r0,#1
000e34  d002              BEQ      |L1.3644|
000e36  e00b              B        |L1.3664|
                  |L1.3640|
000e38  2001              MOVS     r0,#1                 ;2209
000e3a  e7e8              B        |L1.3598|
                  |L1.3644|
;;;2227       /* Add number of LFN entries. */
;;;2228       name_ents += ((strlen(name) + 12) / 13);
000e3c  980d              LDR      r0,[sp,#0x34]
000e3e  f7fffffe          BL       strlen
000e42  300c              ADDS     r0,r0,#0xc
000e44  210d              MOVS     r1,#0xd
000e46  fbb0f0f1          UDIV     r0,r0,r1
000e4a  1c40              ADDS     r0,r0,#1
000e4c  f0000aff          AND      r10,r0,#0xff
                  |L1.3664|
;;;2229     }
;;;2230   
;;;2231     /* Convert name to short entry type (8.3) */
;;;2232     sfn_name_f = cvt_fatname (name, sen);
000e50  a902              ADD      r1,sp,#8
000e52  980d              LDR      r0,[sp,#0x34]
000e54  f7fffffe          BL       cvt_fatname
000e58  b2c0              UXTB     r0,r0
;;;2233   
;;;2234     /* Calculate current sector address for folder. */
;;;2235     sect = get_dir_sect (clus);
000e5a  900b              STR      r0,[sp,#0x2c]
000e5c  9800              LDR      r0,[sp,#0]
000e5e  f7fffffe          BL       get_dir_sect
000e62  4681              MOV      r9,r0
;;;2236   
;;;2237     /* Search through name entries. */
;;;2238     for (idx = 0;  ; idx++) {
000e64  2500              MOVS     r5,#0
000e66  46a0              MOV      r8,r4                 ;2223
                  |L1.3688|
;;;2239       if (in_root_1x) {
000e68  f8980001          LDRB     r0,[r8,#1]  ; in_root_1x
000e6c  b118              CBZ      r0,|L1.3702|
;;;2240         if (idx == 512) {
000e6e  f5b57f00          CMP      r5,#0x200
000e72  d052              BEQ      |L1.3866|
000e74  e016              B        |L1.3748|
                  |L1.3702|
;;;2241           return (__FALSE);
;;;2242         }
;;;2243       }
;;;2244       else {
;;;2245         /* Check if step to next cluster is needed. */
;;;2246         if (idx == mmc.EntsPerClus) {
000e76  488f              LDR      r0,|L1.4276|
000e78  8c81              LDRH     r1,[r0,#0x24]  ; mmc
000e7a  42a9              CMP      r1,r5
000e7c  d112              BNE      |L1.3748|
;;;2247           idx = 0;
;;;2248           if (clus < mmc.FAT32_RootClus) {
000e7e  6a80              LDR      r0,[r0,#0x28]  ; mmc
000e80  9900              LDR      r1,[sp,#0]
000e82  2500              MOVS     r5,#0                 ;2247
000e84  4288              CMP      r0,r1
000e86  d900              BLS      |L1.3722|
;;;2249             clus = mmc.FAT32_RootClus;
000e88  9000              STR      r0,[sp,#0]
                  |L1.3722|
;;;2250           }
;;;2251           EX(set_next_clus (&clus),__FALSE);
000e8a  4668              MOV      r0,sp
000e8c  f7fffffe          BL       set_next_clus
000e90  2800              CMP      r0,#0
000e92  d070              BEQ      |L1.3958|
;;;2252           if (is_EOC (clus)) {
000e94  9800              LDR      r0,[sp,#0]
000e96  f7fffffe          BL       is_EOC
000e9a  bbf0              CBNZ     r0,|L1.3866|
;;;2253             /* No more entries, end of current directory. */
;;;2254             goto not_found;
;;;2255           }
;;;2256           sect = clus_to_sect (clus);
000e9c  9800              LDR      r0,[sp,#0]
000e9e  f7fffffe          BL       clus_to_sect
000ea2  4681              MOV      r9,r0
                  |L1.3748|
;;;2257         }
;;;2258       }
;;;2259   
;;;2260       EX(read_sector (sect + (idx >> 4)),__FALSE);
000ea4  eb091015          ADD      r0,r9,r5,LSR #4
000ea8  f7fffffe          BL       read_sector
000eac  2800              CMP      r0,#0
000eae  d062              BEQ      |L1.3958|
;;;2261       frec = (FILEREC *)ca.buf + (idx & 0x0F);
000eb0  4880              LDR      r0,|L1.4276|
000eb2  f005010f          AND      r1,r5,#0xf
000eb6  3814              SUBS     r0,r0,#0x14
000eb8  6880              LDR      r0,[r0,#8]  ; ca
000eba  eb001441          ADD      r4,r0,r1,LSL #5
;;;2262   
;;;2263       if (frec->FileName[0] == 0x00) {
000ebe  7820              LDRB     r0,[r4,#0]
000ec0  b358              CBZ      r0,|L1.3866|
;;;2264         /* There are no allocated entries after this one. */
;;;2265         goto not_found;
;;;2266       }
;;;2267   
;;;2268       if (frec->FileName[0] == 0xE5) {
000ec2  28e5              CMP      r0,#0xe5
000ec4  d05f              BEQ      |L1.3974|
;;;2269         /* Erased file, first character is 0xE5. */
;;;2270         continue;
;;;2271       }
;;;2272   
;;;2273       if (frec->Attr == ATTR_VOLUME_ID) {
000ec6  7ae1              LDRB     r1,[r4,#0xb]
000ec8  2908              CMP      r1,#8
000eca  d05c              BEQ      |L1.3974|
;;;2274         /* Skip Volume ID entry. */
;;;2275         continue;
;;;2276       }
;;;2277   
;;;2278       if ((frec->Attr == ATTR_LONG_NAME) && (LFN_REC(frec)->Ordinal & ORD_LONG_NAME_LAST)) {
000ecc  290f              CMP      r1,#0xf
000ece  d111              BNE      |L1.3828|
000ed0  0642              LSLS     r2,r0,#25
000ed2  d50f              BPL      |L1.3828|
;;;2279         /* Long name last entry found. */
;;;2280         lfn_f           = 1;
000ed4  2201              MOVS     r2,#1
;;;2281         same_f          = 1;
;;;2282         if (((LFN_REC(frec)->Ordinal & ~ORD_LONG_NAME_LAST) + 1) != name_ents) {
000ed6  f0200040          BIC      r0,r0,#0x40
000eda  9206              STR      r2,[sp,#0x18]         ;2281
000edc  1c40              ADDS     r0,r0,#1
000ede  9201              STR      r2,[sp,#4]
000ee0  4550              CMP      r0,r10
000ee2  d001              BEQ      |L1.3816|
;;;2283           same_f       = 0;
000ee4  2000              MOVS     r0,#0
000ee6  9001              STR      r0,[sp,#4]
                  |L1.3816|
;;;2284         }
;;;2285         first_clus      = clus;
000ee8  9800              LDR      r0,[sp,#0]
;;;2286         first_offs      = idx;
;;;2287         ents            = 0;
;;;2288         chksum          = LFN_REC(frec)->Checksum;
000eea  9008              STR      r0,[sp,#0x20]
000eec  7b60              LDRB     r0,[r4,#0xd]
000eee  46ab              MOV      r11,r5                ;2286
000ef0  2700              MOVS     r7,#0                 ;2287
000ef2  9007              STR      r0,[sp,#0x1c]
                  |L1.3828|
;;;2289       }
;;;2290   
;;;2291       /* type_f == 1 if type of entry we are searching for is the same 
;;;2292          one we are checking now. */
;;;2293       type_f = !(dir_f ^ ((frec->Attr & ATTR_DIRECTORY) == ATTR_DIRECTORY));
000ef4  9a0a              LDR      r2,[sp,#0x28]
000ef6  2001              MOVS     r0,#1
000ef8  f3c11300          UBFX     r3,r1,#4,#1
000efc  4293              CMP      r3,r2
000efe  d000              BEQ      |L1.3842|
000f00  2000              MOVS     r0,#0
                  |L1.3842|
;;;2294   
;;;2295       if (lfn_f) {
000f02  9009              STR      r0,[sp,#0x24]
000f04  9806              LDR      r0,[sp,#0x18]
000f06  b3a8              CBZ      r0,|L1.3956|
;;;2296         /* Long name entry found. */
;;;2297         ents ++;
000f08  1c7f              ADDS     r7,r7,#1
000f0a  b2ff              UXTB     r7,r7
;;;2298   
;;;2299         if (frec->Attr != ATTR_LONG_NAME) {
000f0c  290f              CMP      r1,#0xf
000f0e  d011              BEQ      |L1.3892|
;;;2300           /* If this is long name's accompanying short entry. */
;;;2301           lfn_f = 0;
000f10  2000              MOVS     r0,#0
;;;2302   
;;;2303           /* Calculate short name's checksum. */
;;;2304           if ((same_f) && (chksum == lfn_calc_chksum(frec->FileName))) {
000f12  9006              STR      r0,[sp,#0x18]
000f14  9801              LDR      r0,[sp,#4]
000f16  b150              CBZ      r0,|L1.3886|
000f18  e000              B        |L1.3868|
                  |L1.3866|
000f1a  e05a              B        |L1.4050|
                  |L1.3868|
000f1c  4620              MOV      r0,r4
000f1e  f7fffffe          BL       lfn_calc_chksum
000f22  9907              LDR      r1,[sp,#0x1c]
000f24  4288              CMP      r0,r1
000f26  d102              BNE      |L1.3886|
;;;2305             if (type_f) {
000f28  9809              LDR      r0,[sp,#0x24]
000f2a  bbf0              CBNZ     r0,|L1.4010|
000f2c  e004              B        |L1.3896|
                  |L1.3886|
;;;2306               /* If this is the file or directory we searched for. */
;;;2307               if (keep_fcb) {
;;;2308                 goto found_keep_fcb;
;;;2309               }
;;;2310               goto found;
;;;2311             }
;;;2312           }
;;;2313           else {
;;;2314             /* Check also if name is same as only short name (for checking 
;;;2315                if short name already exists). */
;;;2316             if (name_ents == 1)
000f2e  f1ba0f01          CMP      r10,#1
000f32  d032              BEQ      |L1.3994|
                  |L1.3892|
;;;2317               goto chk_short;
;;;2318           }
;;;2319         }
;;;2320   
;;;2321         if (!same_f) {
000f34  9801              LDR      r0,[sp,#4]
000f36  b330              CBZ      r0,|L1.3974|
                  |L1.3896|
;;;2322           /* If this is not the entry we are searching for. */
;;;2323           continue;
;;;2324         }
;;;2325   
;;;2326         if (chksum != LFN_REC(frec)->Checksum) {
000f38  7b61              LDRB     r1,[r4,#0xd]
000f3a  9807              LDR      r0,[sp,#0x1c]
000f3c  4281              CMP      r1,r0
000f3e  d001              BEQ      |L1.3908|
;;;2327           /* If any of long entries does not have the same checksum 
;;;2328              as previous ones then this name is invalid. */
;;;2329           same_f = 0;
000f40  2000              MOVS     r0,#0
;;;2330           continue;
000f42  e01f              B        |L1.3972|
                  |L1.3908|
;;;2331         }
;;;2332   
;;;2333         /* Long name checking in progress. */
;;;2334         i = ((LFN_REC(frec)->Ordinal & 0x1F) - 1) * 13;
000f44  7820              LDRB     r0,[r4,#0]
000f46  f8dfc178          LDR      r12,|L1.4288|
000f4a  f000001f          AND      r0,r0,#0x1f
000f4e  1e40              SUBS     r0,r0,#1
000f50  eb000180          ADD      r1,r0,r0,LSL #2
000f54  eb0100c0          ADD      r0,r1,r0,LSL #3
;;;2335   
;;;2336         /* Compare 13 chars of name with 13 chars of entry name, ignore case. */
;;;2337         same_f = lfn_cmp_name ((U8 *)frec, (char *)&name[i]);
000f58  990d              LDR      r1,[sp,#0x34]
000f5a  180a              ADDS     r2,r1,r0
000f5c  2000              MOVS     r0,#0
000f5e  bf00              NOP      
                  |L1.3936|
000f60  f81c1000          LDRB     r1,[r12,r0]
000f64  5c63              LDRB     r3,[r4,r1]
000f66  5c11              LDRB     r1,[r2,r0]
000f68  404b              EORS     r3,r3,r1
000f6a  f0330320          BICS     r3,r3,#0x20
000f6e  d003              BEQ      |L1.3960|
000f70  2000              MOVS     r0,#0
000f72  e006              B        |L1.3970|
                  |L1.3956|
000f74  e008              B        |L1.3976|
                  |L1.3958|
000f76  e02d              B        |L1.4052|
                  |L1.3960|
000f78  b111              CBZ      r1,|L1.3968|
000f7a  1c40              ADDS     r0,r0,#1
000f7c  280d              CMP      r0,#0xd
000f7e  d3ef              BCC      |L1.3936|
                  |L1.3968|
000f80  2001              MOVS     r0,#1
                  |L1.3970|
000f82  b2c0              UXTB     r0,r0
                  |L1.3972|
000f84  9001              STR      r0,[sp,#4]
                  |L1.3974|
000f86  e022              B        |L1.4046|
                  |L1.3976|
;;;2338       }
;;;2339       else if (name_ents == 1) {
000f88  f1ba0f01          CMP      r10,#1
000f8c  d11f              BNE      |L1.4046|
;;;2340         /* Short name entry found. */
;;;2341         first_clus = clus;
000f8e  9800              LDR      r0,[sp,#0]
;;;2342         first_offs = idx;
;;;2343         ents       = 1;
;;;2344   
;;;2345         /* If this is not the type of entry we are searching for. */
;;;2346         if (!type_f) { 
000f90  9008              STR      r0,[sp,#0x20]
000f92  9809              LDR      r0,[sp,#0x24]
000f94  46ab              MOV      r11,r5                ;2342
000f96  2701              MOVS     r7,#1                 ;2343
000f98  b1c8              CBZ      r0,|L1.4046|
                  |L1.3994|
;;;2347           continue; 
;;;2348         }
;;;2349   
;;;2350   chk_short:
;;;2351         /* Check if name converted to short entry name is valid. */
;;;2352         if (sfn_name_f == __FALSE) { 
000f9a  980b              LDR      r0,[sp,#0x2c]
000f9c  b1b8              CBZ      r0,|L1.4046|
000f9e  2000              MOVS     r0,#0
000fa0  a902              ADD      r1,sp,#8              ;2206
                  |L1.4002|
000fa2  5c23              LDRB     r3,[r4,r0]            ;2206
000fa4  5c0a              LDRB     r2,[r1,r0]            ;2206
000fa6  4053              EORS     r3,r3,r2              ;2206
000fa8  e000              B        |L1.4012|
                  |L1.4010|
000faa  e00d              B        |L1.4040|
                  |L1.4012|
000fac  f0330320          BICS     r3,r3,#0x20           ;2206
000fb0  d001              BEQ      |L1.4022|
000fb2  2000              MOVS     r0,#0                 ;2206
000fb4  e004              B        |L1.4032|
                  |L1.4022|
000fb6  b112              CBZ      r2,|L1.4030|
000fb8  1c40              ADDS     r0,r0,#1              ;2206
000fba  280b              CMP      r0,#0xb               ;2206
000fbc  d3f1              BCC      |L1.4002|
                  |L1.4030|
000fbe  2001              MOVS     r0,#1                 ;2206
                  |L1.4032|
;;;2353           continue; 
;;;2354         }
;;;2355   
;;;2356         /* Compare name with entry name, ignore case. */
;;;2357         same_f = sfn_cmp_name (frec->FileName, sen);
000fc0  f01000ff          ANDS     r0,r0,#0xff
;;;2358   
;;;2359         /* If this is entry we searched for. */
;;;2360         if (same_f) {
000fc4  9001              STR      r0,[sp,#4]
000fc6  d002              BEQ      |L1.4046|
                  |L1.4040|
;;;2361           if (keep_fcb) {
000fc8  9810              LDR      r0,[sp,#0x40]
000fca  b930              CBNZ     r0,|L1.4058|
000fcc  e007              B        |L1.4062|
                  |L1.4046|
000fce  1c6d              ADDS     r5,r5,#1              ;2238
000fd0  e74a              B        |L1.3688|
                  |L1.4050|
;;;2362             goto found_keep_fcb;
;;;2363           }
;;;2364           goto found;
;;;2365         }
;;;2366       }
;;;2367     }
;;;2368   
;;;2369   not_found:
;;;2370     return (__FALSE);
000fd2  2000              MOVS     r0,#0
                  |L1.4052|
;;;2371   
;;;2372   found_keep_fcb:
;;;2373     return (__TRUE);
;;;2374   
;;;2375   found:
;;;2376     fcb->attrib       = frec->Attr;
;;;2377     fcb->_firstClus   = (((U32)get_u16 ((U8 *)&frec->FirstClusHI)) << 16) +
;;;2378                         (((U32)get_u16 ((U8 *)&frec->FirstClusLO))      ) ;
;;;2379     fcb->fileID       = idx;
;;;2380     fcb->_lastEntClus = clus;
;;;2381     firstEntClus      = first_clus;
;;;2382     firstEntOffs      = first_offs;
;;;2383     numOfEntries      = ents;
;;;2384     fcb->fpos         = 0;
;;;2385     fcb->fsize        = get_u32 ((U8 *)&frec->FileSize);
;;;2386     return (__TRUE);
;;;2387   }
000fd4  b011              ADD      sp,sp,#0x44
                  |L1.4054|
000fd6  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.4058|
000fda  2001              MOVS     r0,#1                 ;2373
000fdc  e7fa              B        |L1.4052|
                  |L1.4062|
000fde  7ae0              LDRB     r0,[r4,#0xb]          ;2376
000fe0  7170              STRB     r0,[r6,#5]            ;2376
000fe2  8b60              LDRH     r0,[r4,#0x1a]         ;2376
000fe4  8aa1              LDRH     r1,[r4,#0x14]         ;2376
000fe6  eb004001          ADD      r0,r0,r1,LSL #16      ;2377
000fea  61f0              STR      r0,[r6,#0x1c]         ;2379
000fec  8035              STRH     r5,[r6,#0]            ;2379
000fee  9800              LDR      r0,[sp,#0]            ;2380
000ff0  6230              STR      r0,[r6,#0x20]         ;2381
000ff2  9908              LDR      r1,[sp,#0x20]         ;2381
000ff4  f8c81014          STR      r1,[r8,#0x14]         ;2382  ; firstEntClus
000ff8  f8a8b004          STRH     r11,[r8,#4]           ;2382
000ffc  f8887000          STRB     r7,[r8,#0]            ;2383
001000  2000              MOVS     r0,#0                 ;2384
001002  6330              STR      r0,[r6,#0x30]         ;2384
001004  7f20              LDRB     r0,[r4,#0x1c]         ;2384
001006  f8d4101d          LDR      r1,[r4,#0x1d]         ;2384
00100a  ea402001          ORR      r0,r0,r1,LSL #8       ;2384
00100e  62f0              STR      r0,[r6,#0x2c]         ;2386
001010  e7e3              B        |L1.4058|
;;;2388   
                          ENDP

                  get_nt_name PROC
;;;2066   
;;;2067   static BOOL get_nt_name (const char *fn, char *sn, int num) {
001012  e92d4ff8          PUSH     {r3-r11,lr}
001016  4683              MOV      r11,r0
;;;2068     /* Create a short name in "sn" with numeric tail (with value num) 
;;;2069        of a long name given in "fn".
;;;2070        It returns __TRUE if successfull else it returns __FALSE.              */
;;;2071     /* Example: *fn   = "Some file.txt"
;;;2072                 *sn   = "SOMEFI~3.TXT
;;;2073                  num  = 3                                                     */
;;;2074     U8  ch = 0;
;;;2075     S8  num_sz;
;;;2076     U32 dot_pos  = 0xFFFF;
;;;2077     U32 val, i, j;
;;;2078   
;;;2079     /* Calculate how many digits requested number has (maximum 6). */
;;;2080     if      (num > 99999) num_sz = 6;
001018  482a              LDR      r0,|L1.4292|
00101a  460e              MOV      r6,r1                 ;2067
00101c  4615              MOV      r5,r2                 ;2067
00101e  f04f0a00          MOV      r10,#0                ;2074
001022  f64f78ff          MOV      r8,#0xffff            ;2076
001026  4282              CMP      r2,r0
001028  dd01              BLE      |L1.4142|
00102a  2706              MOVS     r7,#6
00102c  e013              B        |L1.4182|
                  |L1.4142|
;;;2081     else if (num >  9999) num_sz = 5;
00102e  f242700f          MOV      r0,#0x270f
001032  4285              CMP      r5,r0
001034  dd01              BLE      |L1.4154|
001036  2705              MOVS     r7,#5
001038  e00d              B        |L1.4182|
                  |L1.4154|
;;;2082     else if (num >   999) num_sz = 4;
00103a  f5b57f7a          CMP      r5,#0x3e8
00103e  db01              BLT      |L1.4164|
001040  2704              MOVS     r7,#4
001042  e008              B        |L1.4182|
                  |L1.4164|
;;;2083     else if (num >    99) num_sz = 3;
001044  2d63              CMP      r5,#0x63
001046  dd01              BLE      |L1.4172|
001048  2703              MOVS     r7,#3
00104a  e004              B        |L1.4182|
                  |L1.4172|
;;;2084     else if (num >     9) num_sz = 2;
00104c  2d09              CMP      r5,#9
00104e  dd01              BLE      |L1.4180|
001050  2702              MOVS     r7,#2
001052  e000              B        |L1.4182|
                  |L1.4180|
;;;2085     else                  num_sz = 1;
001054  2701              MOVS     r7,#1
                  |L1.4182|
;;;2086   
;;;2087     /* Find position of last dot (.) in long name. */
;;;2088     for (i = 0; *(fn + i); i++) {
001056  2000              MOVS     r0,#0
001058  e003              B        |L1.4194|
                  |L1.4186|
;;;2089       if (*(fn + i) == '.') dot_pos = i;
00105a  292e              CMP      r1,#0x2e
00105c  d100              BNE      |L1.4192|
00105e  4680              MOV      r8,r0
                  |L1.4192|
001060  1c40              ADDS     r0,r0,#1              ;2088
                  |L1.4194|
001062  f81b1000          LDRB     r1,[r11,r0]           ;2088
001066  2900              CMP      r1,#0                 ;2088
001068  d1f7              BNE      |L1.4186|
;;;2090     }
;;;2091   
;;;2092     if (num == 0) {
00106a  b905              CBNZ     r5,|L1.4206|
;;;2093       /* Enable name creation if 0 without numerical ending */
;;;2094       num_sz = - 1;
00106c  1e4f              SUBS     r7,r1,#1
                  |L1.4206|
;;;2095     }
;;;2096   
;;;2097     /* Copy first part of the name. */
;;;2098     for (i = 0, j = 0; (i < dot_pos) && (j < (7 - num_sz)); i++) {
00106e  f04f0900          MOV      r9,#0
001072  f1c70007          RSB      r0,r7,#7
001076  464c              MOV      r4,r9
001078  9000              STR      r0,[sp,#0]
00107a  e017              B        |L1.4268|
                  |L1.4220|
;;;2099       ch = *(fn + i);
00107c  f81ba009          LDRB     r10,[r11,r9]
;;;2100       if ((ch == ' ') || (ch == '.')) {
001080  f1ba0f20          CMP      r10,#0x20
001084  d010              BEQ      |L1.4264|
001086  f1ba0f2e          CMP      r10,#0x2e
00108a  d00d              BEQ      |L1.4264|
;;;2101         continue;
;;;2102       }
;;;2103       if (ch == 0) {
00108c  f1ba0f00          CMP      r10,#0
001090  d01c              BEQ      |L1.4300|
;;;2104         break;
;;;2105       }
;;;2106       else {
;;;2107         if (ch >= 'a' && ch <= 'z') {
001092  f1aa0061          SUB      r0,r10,#0x61
001096  2819              CMP      r0,#0x19
001098  d801              BHI      |L1.4254|
;;;2108           /* Convert to uppercase. */
;;;2109           ch &= ~0x20;
00109a  f02a0a20          BIC      r10,r10,#0x20
                  |L1.4254|
;;;2110         }
;;;2111         sn[j++] = val_char (ch);
00109e  4650              MOV      r0,r10
0010a0  f7fffffe          BL       val_char
0010a4  5530              STRB     r0,[r6,r4]
0010a6  1c64              ADDS     r4,r4,#1
                  |L1.4264|
0010a8  f1090901          ADD      r9,r9,#1              ;2098
                  |L1.4268|
0010ac  45c1              CMP      r9,r8                 ;2098
0010ae  d20d              BCS      |L1.4300|
0010b0  9800              LDR      r0,[sp,#0]            ;2098
0010b2  e009              B        |L1.4296|
                  |L1.4276|
                          DCD      ||.bss||+0x20
                  |L1.4280|
                          DCD      0x0ffffff8
                  |L1.4284|
                          DCD      ||.data||
                  |L1.4288|
                          DCD      ||.constdata||+0x78
                  |L1.4292|
                          DCD      0x0001869f
                  |L1.4296|
0010c8  42a0              CMP      r0,r4                 ;2098
0010ca  d8d7              BHI      |L1.4220|
                  |L1.4300|
;;;2112       }
;;;2113     }
;;;2114     if (num == 0) goto finish_name;
0010cc  b3f5              CBZ      r5,|L1.4428|
;;;2115   
;;;2116     sn[j++] = '~';
0010ce  207e              MOVS     r0,#0x7e
0010d0  5530              STRB     r0,[r6,r4]
0010d2  1c64              ADDS     r4,r4,#1
;;;2117   
;;;2118     switch (num_sz) {
0010d4  2f07              CMP      r7,#7
0010d6  d245              BCS      |L1.4452|
0010d8  e8dff007          TBB      [pc,r7]
0010dc  44413429          DCB      0x44,0x41,0x34,0x29
0010e0  1d110400          DCB      0x1d,0x11,0x04,0x00
;;;2119       case 6: 
;;;2120         val            = num / 100000;
0010e4  48ff              LDR      r0,|L1.5348|
0010e6  fb95f0f0          SDIV     r0,r5,r0
;;;2121         num           -= val * 100000;
0010ea  49ff              LDR      r1,|L1.5352|
0010ec  4341              MULS     r1,r0,r1
;;;2122         if (val > 9) val = 9;
0010ee  2809              CMP      r0,#9
0010f0  eb051541          ADD      r5,r5,r1,LSL #5       ;2121
0010f4  d900              BLS      |L1.4344|
0010f6  2009              MOVS     r0,#9
                  |L1.4344|
;;;2123         sn[j++]  = '0' + val;
0010f8  3030              ADDS     r0,r0,#0x30
0010fa  5530              STRB     r0,[r6,r4]
0010fc  1c64              ADDS     r4,r4,#1
;;;2124       case 5: 
;;;2125         val            = num /  10000;
0010fe  f2427010          MOV      r0,#0x2710
001102  fb95f0f0          SDIV     r0,r5,r0
;;;2126         num           -= val *  10000;
001106  f46f711c          MVN      r1,#0x270
00110a  4341              MULS     r1,r0,r1
;;;2127         sn[j++]  = '0' + val;
00110c  3030              ADDS     r0,r0,#0x30
00110e  5530              STRB     r0,[r6,r4]
001110  eb051501          ADD      r5,r5,r1,LSL #4       ;2126
001114  1c64              ADDS     r4,r4,#1
;;;2128       case 4: 
;;;2129         val            = num /   1000;
001116  f44f707a          MOV      r0,#0x3e8
00111a  fb95f0f0          SDIV     r0,r5,r0
;;;2130         num           -= val *   1000;
00111e  f06f017c          MVN      r1,#0x7c
001122  4341              MULS     r1,r0,r1
;;;2131         sn[j++]  = '0' + val;
001124  3030              ADDS     r0,r0,#0x30
001126  5530              STRB     r0,[r6,r4]
001128  eb0505c1          ADD      r5,r5,r1,LSL #3       ;2130
00112c  1c64              ADDS     r4,r4,#1
;;;2132       case 3: 
;;;2133         val            = num /    100;
00112e  2064              MOVS     r0,#0x64
001130  fb95f0f0          SDIV     r0,r5,r0
;;;2134         num           -= val *    100;
001134  f06f0118          MVN      r1,#0x18
001138  4341              MULS     r1,r0,r1
;;;2135         sn[j++]  = '0' + val;
00113a  3030              ADDS     r0,r0,#0x30
00113c  5530              STRB     r0,[r6,r4]
00113e  eb050581          ADD      r5,r5,r1,LSL #2       ;2134
001142  1c64              ADDS     r4,r4,#1
;;;2136       case 2: 
;;;2137         val            = num /     10;
001144  200a              MOVS     r0,#0xa
001146  fb95f0f0          SDIV     r0,r5,r0
;;;2138         num           -= val *     10;
00114a  e000              B        |L1.4430|
                  |L1.4428|
00114c  e00a              B        |L1.4452|
                  |L1.4430|
00114e  4241              RSBS     r1,r0,#0
;;;2139         sn[j++]  = '0' + val;
001150  3030              ADDS     r0,r0,#0x30
001152  eb010181          ADD      r1,r1,r1,LSL #2       ;2138
001156  5530              STRB     r0,[r6,r4]
001158  eb050541          ADD      r5,r5,r1,LSL #1       ;2138
00115c  1c64              ADDS     r4,r4,#1
;;;2140       case 1: 
;;;2141         sn[j++]  = '0' + num;
00115e  3530              ADDS     r5,r5,#0x30
001160  5535              STRB     r5,[r6,r4]
001162  1c64              ADDS     r4,r4,#1
                  |L1.4452|
;;;2142         break;
;;;2143     }
;;;2144   
;;;2145   finish_name:
;;;2146     if (ch == 0) goto terminate_name;
001164  f1ba0f00          CMP      r10,#0
001168  d01a              BEQ      |L1.4512|
;;;2147   
;;;2148     sn[j++] = '.';
00116a  202e              MOVS     r0,#0x2e
00116c  5530              STRB     r0,[r6,r4]
00116e  1c64              ADDS     r4,r4,#1
;;;2149   
;;;2150     if (dot_pos != 0xFFFF) {
001170  f5a8417f          SUB      r1,r8,#0xff00
001174  4640              MOV      r0,r8
001176  39ff              SUBS     r1,r1,#0xff
001178  d012              BEQ      |L1.4512|
;;;2151       for (i = dot_pos + 1; (i < dot_pos + 4); i++) {
00117a  1c45              ADDS     r5,r0,#1
00117c  1d07              ADDS     r7,r0,#4
00117e  e00d              B        |L1.4508|
                  |L1.4480|
;;;2152         ch = *(fn + i);
001180  f81b0005          LDRB     r0,[r11,r5]
;;;2153         if (!ch) {
001184  b160              CBZ      r0,|L1.4512|
;;;2154           break;
;;;2155         }
;;;2156         if (ch >= 'a' && ch <= 'z') {
001186  f1a00161          SUB      r1,r0,#0x61
00118a  2919              CMP      r1,#0x19
00118c  d801              BHI      |L1.4498|
;;;2157           /* Convert to uppercase. */
;;;2158           ch &= ~0x20;
00118e  f0200020          BIC      r0,r0,#0x20
                  |L1.4498|
;;;2159         }
;;;2160         sn[j++] = val_char (ch);
001192  f7fffffe          BL       val_char
001196  5530              STRB     r0,[r6,r4]
001198  1c64              ADDS     r4,r4,#1
00119a  1c6d              ADDS     r5,r5,#1              ;2151
                  |L1.4508|
00119c  42bd              CMP      r5,r7                 ;2151
00119e  d3ef              BCC      |L1.4480|
                  |L1.4512|
;;;2161       }
;;;2162     }
;;;2163   
;;;2164   terminate_name:
;;;2165     sn[j] = 0;                           /* Terminate name string */
0011a0  2000              MOVS     r0,#0
0011a2  5530              STRB     r0,[r6,r4]
;;;2166   
;;;2167     return (__TRUE);
0011a4  2001              MOVS     r0,#1
;;;2168   }
0011a6  e8bd8ff8          POP      {r3-r11,pc}
;;;2169   
                          ENDP

                  write_entries PROC
;;;2766   
;;;2767   static BOOL write_entries (const char *name, IOB *fcb, U8 type, FILEREC *copy_frec) {
0011aa  e92d4fff          PUSH     {r0-r11,lr}
0011ae  b097              SUB      sp,sp,#0x5c
;;;2768     /* Write entries to where fcb is pointing to, if copy_frec != NULL then keep 
;;;2769        some info from file record that copy_frec is pointing, when done leave fcb 
;;;2770        to point to last entry of entries that were written. */
;;;2771     char         sfn[13];
;;;2772     char         sen[13];
;;;2773     FILEREC     *frec;
;;;2774     U8           lfn_f         = 0;
0011b0  2000              MOVS     r0,#0
0011b2  460e              MOV      r6,r1                 ;2767
0011b4  461f              MOV      r7,r3                 ;2767
;;;2775     U8           dir_f         = (type == ENT_DIR);
0011b6  9013              STR      r0,[sp,#0x4c]
0011b8  2a01              CMP      r2,#1
0011ba  d01d              BEQ      |L1.4600|
                  |L1.4540|
;;;2776     U8           name_lfn_f    = check_lfn (name);
0011bc  9010              STR      r0,[sp,#0x40]
0011be  9817              LDR      r0,[sp,#0x5c]
0011c0  f7fffffe          BL       check_lfn
0011c4  f00009ff          AND      r9,r0,#0xff
;;;2777     U8           calc_chksum   = 0;
;;;2778     U32          clus          = firstEntClus;
0011c8  f8df8320          LDR      r8,|L1.5356|
0011cc  2000              MOVS     r0,#0                 ;2777
0011ce  9009              STR      r0,[sp,#0x24]
0011d0  f8d81014          LDR      r1,[r8,#0x14]  ; firstEntClus
;;;2779     U32          idx           = firstEntOffs;
0011d4  9108              STR      r1,[sp,#0x20]
0011d6  f8b85004          LDRH     r5,[r8,#4]  ; firstEntOffs
;;;2780     U32          sect;
;;;2781     U32          sz            = strlen (name);
0011da  9817              LDR      r0,[sp,#0x5c]
0011dc  f7fffffe          BL       strlen
;;;2782     U32          i, j;
;;;2783   
;;;2784     /* Calculate address of sector where write will start. */
;;;2785     sect = get_dir_sect (clus);
0011e0  9011              STR      r0,[sp,#0x44]
0011e2  9808              LDR      r0,[sp,#0x20]
0011e4  f7fffffe          BL       get_dir_sect
0011e8  4683              MOV      r11,r0
;;;2786   
;;;2787     if (!name_lfn_f) {
0011ea  f1b90f00          CMP      r9,#0
0011ee  d005              BEQ      |L1.4604|
;;;2788       /* Convert name to short entry type (8.3) */
;;;2789       cvt_fatname (name, sen);
;;;2790     }
;;;2791     else {
;;;2792       /* Find unexisting short name for long name. */
;;;2793       i = 0;
0011f0  2400              MOVS     r4,#0
;;;2794       while (get_nt_name  (name, sfn, i++) == __TRUE) {
;;;2795         if (check_name (sfn, fcb, ENT_FILE) == __FALSE) {
;;;2796           /* If the short name does not exist convert it to entry name. */
;;;2797           cvt_fatname (sfn, sen);
;;;2798           break;
;;;2799         }
;;;2800         if (i > (999999 - 1)) {
0011f2  f8dfa2fc          LDR      r10,|L1.5360|
;;;2801           /* Unable to reserve short entry name. */
;;;2802           return (__FALSE);
0011f6  e00e              B        |L1.4630|
                  |L1.4600|
0011f8  2001              MOVS     r0,#1                 ;2775
0011fa  e7df              B        |L1.4540|
                  |L1.4604|
0011fc  a902              ADD      r1,sp,#8              ;2789
0011fe  9817              LDR      r0,[sp,#0x5c]         ;2789
001200  f7fffffe          BL       cvt_fatname
001204  e017              B        |L1.4662|
                  |L1.4614|
001206  2200              MOVS     r2,#0                 ;2795
001208  4631              MOV      r1,r6                 ;2795
00120a  a80c              ADD      r0,sp,#0x30           ;2795
00120c  f7fffffe          BL       check_name
001210  b1d0              CBZ      r0,|L1.4680|
001212  4554              CMP      r4,r10                ;2800
001214  d87e              BHI      |L1.4884|
                  |L1.4630|
001216  4622              MOV      r2,r4                 ;2794
001218  1c64              ADDS     r4,r4,#1              ;2794
00121a  a90c              ADD      r1,sp,#0x30           ;2794
00121c  9817              LDR      r0,[sp,#0x5c]         ;2794
00121e  f7fffffe          BL       get_nt_name
001222  2801              CMP      r0,#1                 ;2794
001224  d0ef              BEQ      |L1.4614|
;;;2803         }
;;;2804       }
;;;2805     }
;;;2806   
;;;2807     /* At this point we have information if we are writing long name 
;;;2808        (name_lfn_f == 1), if we are writing a file or directory entries 
;;;2809        (dir_f == 1), we have short name (sen) prepared. */
;;;2810   
;;;2811     /* Calculate short name's checksum. */
;;;2812     if (name_lfn_f) {
001226  bf00              NOP      
                  |L1.4648|
001228  f1b90f00          CMP      r9,#0
00122c  d003              BEQ      |L1.4662|
;;;2813       calc_chksum = lfn_calc_chksum ((U8 *)sen);
00122e  a802              ADD      r0,sp,#8
001230  f7fffffe          BL       lfn_calc_chksum
001234  9009              STR      r0,[sp,#0x24]
                  |L1.4662|
001236  f04f0800          MOV      r8,#0                 ;2774
                  |L1.4666|
;;;2814     }
;;;2815   
;;;2816     /* Go through entries. */
;;;2817     for ( ; ; idx ++) {
;;;2818       /* Check if step to next cluster is needed. */
;;;2819       if (in_root_1x) {
00123a  48ac              LDR      r0,|L1.5356|
00123c  7840              LDRB     r0,[r0,#1]  ; in_root_1x
00123e  b140              CBZ      r0,|L1.4690|
;;;2820         if (idx == 512) {
001240  f5b57f00          CMP      r5,#0x200
001244  d066              BEQ      |L1.4884|
001246  e01d              B        |L1.4740|
                  |L1.4680|
001248  a902              ADD      r1,sp,#8              ;2797
00124a  a80c              ADD      r0,sp,#0x30           ;2797
00124c  f7fffffe          BL       cvt_fatname
001250  e7ea              B        |L1.4648|
                  |L1.4690|
;;;2821           goto fail;
;;;2822         }
;;;2823       }
;;;2824       else {
;;;2825         /* Check if step to next cluster is needed. */
;;;2826         if (idx == mmc.EntsPerClus) {
001252  48a8              LDR      r0,|L1.5364|
001254  8c81              LDRH     r1,[r0,#0x24]  ; mmc
001256  42a9              CMP      r1,r5
001258  d114              BNE      |L1.4740|
;;;2827           idx = 0;
;;;2828           /* If we have written to last entry of current cluster then 
;;;2829              allocate new for remaining entries. */
;;;2830           if (clus < mmc.FAT32_RootClus) {
00125a  6a80              LDR      r0,[r0,#0x28]  ; mmc
00125c  9908              LDR      r1,[sp,#0x20]
00125e  2500              MOVS     r5,#0                 ;2827
001260  4288              CMP      r0,r1
001262  d900              BLS      |L1.4710|
;;;2831             clus = mmc.FAT32_RootClus;
001264  9008              STR      r0,[sp,#0x20]
                  |L1.4710|
;;;2832           }
;;;2833           EX(alloc_new_clus (&clus, 1),__FALSE);
001266  2101              MOVS     r1,#1
001268  a808              ADD      r0,sp,#0x20
00126a  f7fffffe          BL       alloc_new_clus
00126e  2800              CMP      r0,#0
001270  d06f              BEQ      |L1.4946|
;;;2834           EX(clear_clus (clus),__FALSE);
001272  9808              LDR      r0,[sp,#0x20]
001274  f7fffffe          BL       clear_clus
001278  2800              CMP      r0,#0
00127a  d06a              BEQ      |L1.4946|
;;;2835           sect = clus_to_sect (clus);
00127c  9808              LDR      r0,[sp,#0x20]
00127e  f7fffffe          BL       clus_to_sect
001282  4683              MOV      r11,r0
                  |L1.4740|
;;;2836         }
;;;2837       }
;;;2838   
;;;2839       EX(read_sector (sect + (idx >> 4)),__FALSE);
001284  eb0b1015          ADD      r0,r11,r5,LSR #4
001288  9006              STR      r0,[sp,#0x18]
00128a  f7fffffe          BL       read_sector
00128e  2800              CMP      r0,#0
001290  d05f              BEQ      |L1.4946|
;;;2840       frec      = (FILEREC *)ca.buf + (idx & 0x0F);
001292  4898              LDR      r0,|L1.5364|
001294  f005020f          AND      r2,r5,#0xf
001298  3814              SUBS     r0,r0,#0x14
;;;2841   
;;;2842       if (name_lfn_f) {
00129a  f1b90f00          CMP      r9,#0
00129e  6881              LDR      r1,[r0,#8]  ; ca
0012a0  eb011442          ADD      r4,r1,r2,LSL #5       ;2840
0012a4  d056              BEQ      |L1.4948|
;;;2843         /* We are handling long name. */
;;;2844         if (lfn_f) {
0012a6  9813              LDR      r0,[sp,#0x4c]
0012a8  b110              CBZ      r0,|L1.4784|
;;;2845           /* If long name last entry created already. */
;;;2846           LFN_REC(frec)->Ordinal = 0;
0012aa  f8848000          STRB     r8,[r4,#0]
0012ae  e003              B        |L1.4792|
                  |L1.4784|
;;;2847         }
;;;2848         else {
;;;2849           /* Long name last entry creation. */
;;;2850           lfn_f = 1;
0012b0  2001              MOVS     r0,#1
;;;2851           LFN_REC(frec)->Ordinal = ORD_LONG_NAME_LAST;
0012b2  9013              STR      r0,[sp,#0x4c]
0012b4  2040              MOVS     r0,#0x40
0012b6  7020              STRB     r0,[r4,#0]
                  |L1.4792|
;;;2852         }
;;;2853   
;;;2854         if (sz) {
0012b8  9811              LDR      r0,[sp,#0x44]
0012ba  b360              CBZ      r0,|L1.4886|
;;;2855           /* Long name's long entry creation. */
;;;2856           LFN_REC(frec)->Ordinal    |= ((sz + 12) / 13);
0012bc  300c              ADDS     r0,r0,#0xc
0012be  210d              MOVS     r1,#0xd
0012c0  fbb0f0f1          UDIV     r0,r0,r1
0012c4  7821              LDRB     r1,[r4,#0]
0012c6  f8dfe230          LDR      lr,|L1.5368|
0012ca  4308              ORRS     r0,r0,r1
0012cc  7020              STRB     r0,[r4,#0]
;;;2857           LFN_REC(frec)->Checksum    = calc_chksum;
0012ce  9809              LDR      r0,[sp,#0x24]
0012d0  7360              STRB     r0,[r4,#0xd]
;;;2858           LFN_REC(frec)->FirstClusLO = 0;
0012d2  f8a4801a          STRH     r8,[r4,#0x1a]
;;;2859           LFN_REC(frec)->Attr        = ATTR_LONG_NAME;
0012d6  200f              MOVS     r0,#0xf
0012d8  72e0              STRB     r0,[r4,#0xb]
;;;2860   
;;;2861           /* Long name creation in progress. */
;;;2862           i = ((LFN_REC(frec)->Ordinal & 0x1F) - 1) * 13;
0012da  7820              LDRB     r0,[r4,#0]
0012dc  f1040c01          ADD      r12,r4,#1
0012e0  f000001f          AND      r0,r0,#0x1f
0012e4  1e40              SUBS     r0,r0,#1
0012e6  eb000180          ADD      r1,r0,r0,LSL #2
0012ea  eb0100c0          ADD      r0,r1,r0,LSL #3
;;;2863   
;;;2864           /* Copy 13 characters of name to 13 characters of entry name. */
;;;2865           lfn_copy_name ((U8 *)frec, (char *)&name[i]);
0012ee  9917              LDR      r1,[sp,#0x5c]
0012f0  eb010a00          ADD      r10,r1,r0
0012f4  2000              MOVS     r0,#0
0012f6  bf00              NOP      
                  |L1.4856|
0012f8  f81a2000          LDRB     r2,[r10,r0]
0012fc  b14a              CBZ      r2,|L1.4882|
0012fe  f81e3000          LDRB     r3,[lr,r0]
001302  54e2              STRB     r2,[r4,r3]
001304  f81e1000          LDRB     r1,[lr,r0]
001308  1c40              ADDS     r0,r0,#1
00130a  280d              CMP      r0,#0xd
00130c  f801800c          STRB     r8,[r1,r12]
001310  d3f2              BCC      |L1.4856|
                  |L1.4882|
001312  e001              B        |L1.4888|
                  |L1.4884|
001314  e0a5              B        |L1.5218|
                  |L1.4886|
001316  e01d              B        |L1.4948|
                  |L1.4888|
001318  2100              MOVS     r1,#0
00131a  4672              MOV      r2,lr
00131c  e006              B        |L1.4908|
                  |L1.4894|
00131e  5c13              LDRB     r3,[r2,r0]
001320  54e1              STRB     r1,[r4,r3]
001322  5c13              LDRB     r3,[r2,r0]
001324  f803100c          STRB     r1,[r3,r12]
001328  21ff              MOVS     r1,#0xff
00132a  1c40              ADDS     r0,r0,#1
                  |L1.4908|
00132c  280d              CMP      r0,#0xd
00132e  d3f6              BCC      |L1.4894|
;;;2866   
;;;2867           if (sz > 12) {
001330  9811              LDR      r0,[sp,#0x44]
001332  280c              CMP      r0,#0xc
001334  d901              BLS      |L1.4922|
;;;2868             sz -= 13;
001336  380d              SUBS     r0,r0,#0xd
001338  e000              B        |L1.4924|
                  |L1.4922|
;;;2869           }
;;;2870           else {
;;;2871             sz = 0;
00133a  2000              MOVS     r0,#0
                  |L1.4924|
;;;2872           }
;;;2873   
;;;2874           if ((idx & 0x0F) == 0x0F) {
00133c  9011              STR      r0,[sp,#0x44]
00133e  43e8              MVNS     r0,r5
001340  0700              LSLS     r0,r0,#28
001342  d104              BNE      |L1.4942|
;;;2875             /* Write last previously used sector as we are going to use 
;;;2876                next one. */
;;;2877             EX(write_sector (sect + (idx >> 4)),__FALSE);
001344  9806              LDR      r0,[sp,#0x18]
001346  f7fffffe          BL       write_sector
00134a  2800              CMP      r0,#0
00134c  d001              BEQ      |L1.4946|
                  |L1.4942|
00134e  1c6d              ADDS     r5,r5,#1              ;2817
001350  e773              B        |L1.4666|
                  |L1.4946|
001352  e084              B        |L1.5214|
                  |L1.4948|
;;;2878           }
;;;2879         }
;;;2880         else {
;;;2881           /* Long name's short entry creation. */
;;;2882           goto wr_short;
;;;2883         }
;;;2884       }
;;;2885       else {
;;;2886         /* We are handling short name. */
;;;2887   
;;;2888   wr_short:
;;;2889         /* Copy the name to the entry. */
;;;2890         for (j = 0; j < 11; j++) {
001354  2000              MOVS     r0,#0
001356  a902              ADD      r1,sp,#8              ;2772
                  |L1.4952|
;;;2891           frec->FileName[j]  = sen[j];
001358  5c0a              LDRB     r2,[r1,r0]
00135a  5422              STRB     r2,[r4,r0]
00135c  1c40              ADDS     r0,r0,#1              ;2890
00135e  280b              CMP      r0,#0xb               ;2890
001360  d3fa              BCC      |L1.4952|
;;;2892         }
;;;2893   
;;;2894         if (copy_frec == NULL) {
001362  b34f              CBZ      r7,|L1.5048|
;;;2895           /* If no copying of informations from frec was requested. */
;;;2896   
;;;2897           frec->NTRsvd         = 0;
;;;2898           frec->CrtTimeTenth   = 0;
;;;2899           set_u16 ((U8 *)&frec->CrtTime, get_time ());
;;;2900           set_u16 ((U8 *)&frec->CrtDate, get_date ());
;;;2901           frec->LastAccDate    = frec->CrtDate;
;;;2902           frec->WriteTime      = frec->CrtTime;
;;;2903           frec->WriteDate      = frec->CrtDate;
;;;2904           frec->FileSize       = 0;
;;;2905   
;;;2906           fcb->fpos            = 0;
;;;2907           fcb->fsize           = 0;
;;;2908   
;;;2909           if (dir_f) {
;;;2910             /* If directory entry was created. */
;;;2911             frec->Attr        = ATTR_DIRECTORY;
;;;2912             fcb->_lastEntClus = clus;
;;;2913             fcb->fileID       = idx;
;;;2914             /* Allocate an unused cluster for directory data. */
;;;2915             if (clus < mmc.FAT32_RootClus) {
;;;2916               clus = mmc.FAT32_RootClus;
;;;2917             }
;;;2918             EX(alloc_new_clus (&clus, 0),__FALSE);
;;;2919             fcb->_firstClus   = clus;
;;;2920   
;;;2921             set_u16 ((U8 *)&frec->FirstClusHI, clus >> 16);
;;;2922             set_u16 ((U8 *)&frec->FirstClusLO, clus      );
;;;2923   
;;;2924             EX(write_sector (sect + (idx >> 4)),__FALSE);
;;;2925   
;;;2926             EX(clear_clus (clus),__FALSE);
;;;2927             goto success_dir;
;;;2928           }
;;;2929           else {
;;;2930             /* If file was created. */
;;;2931             frec->Attr        = ATTR_ARCHIVE;
;;;2932             frec->FirstClusHI = 0;
;;;2933             frec->FirstClusLO = 0;
;;;2934             fcb->_firstClus   = 0;
;;;2935   
;;;2936             EX(write_sector (sect + (idx >> 4)),__FALSE);
;;;2937           }
;;;2938         }
;;;2939         else {
;;;2940           /* If copying of informations from frec was requested. */
;;;2941           frec->Attr           = copy_frec->Attr;
001364  7af8              LDRB     r0,[r7,#0xb]
001366  72e0              STRB     r0,[r4,#0xb]
;;;2942           frec->NTRsvd         = 0;
001368  f884800c          STRB     r8,[r4,#0xc]
;;;2943           frec->CrtTimeTenth   = 0;
00136c  f884800d          STRB     r8,[r4,#0xd]
;;;2944           frec->CrtTime        = copy_frec->CrtTime;
001370  89f8              LDRH     r0,[r7,#0xe]
001372  81e0              STRH     r0,[r4,#0xe]
;;;2945           frec->CrtDate        = copy_frec->CrtDate;
001374  8a38              LDRH     r0,[r7,#0x10]
001376  8220              STRH     r0,[r4,#0x10]
;;;2946           set_u16 ((U8 *)&frec->LastAccDate, get_date ());
001378  f7fffffe          BL       get_date
00137c  4601              MOV      r1,r0
00137e  f1040012          ADD      r0,r4,#0x12
001382  f7fffffe          BL       set_u16
;;;2947           frec->FirstClusHI    = copy_frec->FirstClusHI;
001386  8ab8              LDRH     r0,[r7,#0x14]
001388  82a0              STRH     r0,[r4,#0x14]
;;;2948           set_u16 ((U8 *)&frec->WriteTime, get_time ());
00138a  f7fffffe          BL       get_time
00138e  4601              MOV      r1,r0
001390  f1040016          ADD      r0,r4,#0x16
001394  f7fffffe          BL       set_u16
;;;2949           frec->WriteDate      = frec->LastAccDate;
001398  8a60              LDRH     r0,[r4,#0x12]
00139a  8320              STRH     r0,[r4,#0x18]
;;;2950           frec->FirstClusLO    = copy_frec->FirstClusLO;
00139c  8b78              LDRH     r0,[r7,#0x1a]
00139e  8360              STRH     r0,[r4,#0x1a]
;;;2951           frec->FileSize       = copy_frec->FileSize;
0013a0  69f8              LDR      r0,[r7,#0x1c]
;;;2952   
;;;2953           fcb->fpos            = 0;
0013a2  61e0              STR      r0,[r4,#0x1c]
;;;2954           fcb->fsize           = copy_frec->FileSize;
0013a4  f8c68030          STR      r8,[r6,#0x30]
0013a8  69f8              LDR      r0,[r7,#0x1c]
0013aa  62f0              STR      r0,[r6,#0x2c]
0013ac  8b78              LDRH     r0,[r7,#0x1a]
0013ae  8ab9              LDRH     r1,[r7,#0x14]
;;;2955           fcb->_firstClus      = (((U32)get_u16 ((U8 *)&copy_frec->FirstClusHI)) << 16) +
0013b0  eb004001          ADD      r0,r0,r1,LSL #16
;;;2956                                  (((U32)get_u16 ((U8 *)&copy_frec->FirstClusLO))      ) ;
;;;2957   
;;;2958           EX(write_sector (sect + (idx >> 4)),__FALSE);
0013b4  61f0              STR      r0,[r6,#0x1c]
0013b6  e049              B        |L1.5196|
                  |L1.5048|
0013b8  f884800c          STRB     r8,[r4,#0xc]          ;2897
0013bc  4647              MOV      r7,r8                 ;2897
0013be  f884800d          STRB     r8,[r4,#0xd]          ;2898
0013c2  f7fffffe          BL       get_time
0013c6  4601              MOV      r1,r0                 ;2899
0013c8  f104000e          ADD      r0,r4,#0xe            ;2899
0013cc  f7fffffe          BL       set_u16
0013d0  f7fffffe          BL       get_date
0013d4  4601              MOV      r1,r0                 ;2900
0013d6  f1040010          ADD      r0,r4,#0x10           ;2900
0013da  f7fffffe          BL       set_u16
0013de  8a20              LDRH     r0,[r4,#0x10]         ;2901
0013e0  8260              STRH     r0,[r4,#0x12]         ;2901
0013e2  89e1              LDRH     r1,[r4,#0xe]          ;2902
0013e4  82e1              STRH     r1,[r4,#0x16]         ;2902
0013e6  8320              STRH     r0,[r4,#0x18]         ;2903
0013e8  61e7              STR      r7,[r4,#0x1c]         ;2906
0013ea  6337              STR      r7,[r6,#0x30]         ;2907
0013ec  62f7              STR      r7,[r6,#0x2c]         ;2909
0013ee  9810              LDR      r0,[sp,#0x40]         ;2909
0013f0  b338              CBZ      r0,|L1.5186|
0013f2  2010              MOVS     r0,#0x10              ;2911
0013f4  72e0              STRB     r0,[r4,#0xb]          ;2911
0013f6  9908              LDR      r1,[sp,#0x20]         ;2912
0013f8  483e              LDR      r0,|L1.5364|
0013fa  6231              STR      r1,[r6,#0x20]         ;2913
0013fc  8035              STRH     r5,[r6,#0]            ;2913
0013fe  6a80              LDR      r0,[r0,#0x28]         ;2915  ; mmc
001400  4288              CMP      r0,r1                 ;2915
001402  d900              BLS      |L1.5126|
001404  9008              STR      r0,[sp,#0x20]         ;2916
                  |L1.5126|
001406  2100              MOVS     r1,#0                 ;2918
001408  a808              ADD      r0,sp,#0x20           ;2918
00140a  f7fffffe          BL       alloc_new_clus
00140e  2800              CMP      r0,#0                 ;2918
001410  d025              BEQ      |L1.5214|
001412  9808              LDR      r0,[sp,#0x20]         ;2919
001414  61f0              STR      r0,[r6,#0x1c]         ;2921
001416  0c01              LSRS     r1,r0,#16             ;2921
001418  f1040014          ADD      r0,r4,#0x14           ;2921
00141c  f7fffffe          BL       set_u16
001420  9808              LDR      r0,[sp,#0x20]         ;2922
001422  b281              UXTH     r1,r0                 ;2922
001424  f104001a          ADD      r0,r4,#0x1a           ;2922
001428  f7fffffe          BL       set_u16
00142c  9806              LDR      r0,[sp,#0x18]         ;2924
00142e  f7fffffe          BL       write_sector
001432  2800              CMP      r0,#0                 ;2924
001434  d013              BEQ      |L1.5214|
001436  9808              LDR      r0,[sp,#0x20]         ;2926
001438  f7fffffe          BL       clear_clus
00143c  2800              CMP      r0,#0                 ;2926
00143e  d00e              BEQ      |L1.5214|
001440  e00c              B        |L1.5212|
                  |L1.5186|
001442  2020              MOVS     r0,#0x20              ;2931
001444  72e0              STRB     r0,[r4,#0xb]          ;2931
001446  82a7              STRH     r7,[r4,#0x14]         ;2932
001448  8367              STRH     r7,[r4,#0x1a]         ;2933
00144a  61f7              STR      r7,[r6,#0x1c]         ;2934
                  |L1.5196|
00144c  9806              LDR      r0,[sp,#0x18]
00144e  f7fffffe          BL       write_sector
001452  2800              CMP      r0,#0
001454  d003              BEQ      |L1.5214|
;;;2959         }
;;;2960   
;;;2961   
;;;2962         /* Entries written successfully. */
;;;2963         goto success;
;;;2964       }
;;;2965     }
;;;2966   
;;;2967   fail:
;;;2968     return (__FALSE);
;;;2969   
;;;2970   success:
;;;2971     fcb->fileID       = idx;
001456  8035              STRH     r5,[r6,#0]
;;;2972     fcb->_lastEntClus = clus;
001458  9808              LDR      r0,[sp,#0x20]
00145a  6230              STR      r0,[r6,#0x20]
                  |L1.5212|
;;;2973   
;;;2974   success_dir:
;;;2975     return (__TRUE);
00145c  2001              MOVS     r0,#1
                  |L1.5214|
;;;2976   }
00145e  b01b              ADD      sp,sp,#0x6c
001460  e5b9              B        |L1.4054|
                  |L1.5218|
001462  2000              MOVS     r0,#0                 ;2968
001464  e7fb              B        |L1.5214|
;;;2977   
                          ENDP

                  alloc_name PROC
;;;2410   
;;;2411   static BOOL alloc_name (const char *name, IOB *fcb) {
001466  e92d43f8          PUSH     {r3-r9,lr}
00146a  4604              MOV      r4,r0
;;;2412     /* Find unused position or enough of erased entries for new entries for 
;;;2413        "name" (file or dir).                                                  */
;;;2414     FILEREC     *frec;
;;;2415     U8           name_ents     = 1;
;;;2416     U8           ents          = 0;
;;;2417     U16          first_offs    = 0;
;;;2418     U32          first_clus    = 0;
;;;2419     U32          clus          = fcb->_firstClus;
00146c  69c8              LDR      r0,[r1,#0x1c]
;;;2420     U32          sect;
;;;2421     U32          idx;
;;;2422   
;;;2423     /* Calculate number of requested entries needed for name. */
;;;2424     if (check_lfn(name) == __TRUE) {
00146e  9000              STR      r0,[sp,#0]
001470  2701              MOVS     r7,#1                 ;2415
001472  4620              MOV      r0,r4
001474  f7fffffe          BL       check_lfn
001478  2801              CMP      r0,#1
00147a  d108              BNE      |L1.5262|
;;;2425       /* Add number of LFN entries. */
;;;2426       name_ents += ((strlen(name) + 12) / 13);
00147c  4620              MOV      r0,r4
00147e  f7fffffe          BL       strlen
001482  300c              ADDS     r0,r0,#0xc
001484  210d              MOVS     r1,#0xd
001486  fbb0f0f1          UDIV     r0,r0,r1
00148a  1c40              ADDS     r0,r0,#1
00148c  b2c7              UXTB     r7,r0
                  |L1.5262|
;;;2427     }
;;;2428   
;;;2429     /* Calculate current sector address for folder. */
;;;2430     sect = get_dir_sect (clus);
00148e  9800              LDR      r0,[sp,#0]
001490  f7fffffe          BL       get_dir_sect
;;;2431   
;;;2432     /* Search through name entries. */
;;;2433     for (idx = 0;  ; idx++) {
;;;2434       if (in_root_1x) {
001494  4e15              LDR      r6,|L1.5356|
;;;2435         if (idx == 512) {
;;;2436           return (__FALSE);
;;;2437         }
;;;2438       }
;;;2439       else {
;;;2440         /* Check if step to next cluster is needed. */
;;;2441         if (idx == mmc.EntsPerClus) {
001496  f8df805c          LDR      r8,|L1.5364|
00149a  4605              MOV      r5,r0                 ;2430
00149c  2400              MOVS     r4,#0                 ;2433
                  |L1.5278|
00149e  7870              LDRB     r0,[r6,#1]            ;2434  ; in_root_1x
0014a0  b128              CBZ      r0,|L1.5294|
0014a2  f5b47f00          CMP      r4,#0x200             ;2435
0014a6  d136              BNE      |L1.5398|
0014a8  2000              MOVS     r0,#0                 ;2436
                  |L1.5290|
;;;2442           idx = 0;
;;;2443           if (clus < mmc.FAT32_RootClus) {
;;;2444             clus = mmc.FAT32_RootClus;
;;;2445           }
;;;2446           first_clus = clus;
;;;2447           EX(set_next_clus (&clus),__FALSE);
;;;2448           if (is_EOC (clus)) {
;;;2449             /* No more entries, end of current directory. */
;;;2450   
;;;2451             /* Allocate new cluster. */
;;;2452             clus = first_clus;
;;;2453             EX(alloc_new_clus (&clus, 1),__FALSE);
;;;2454             EX(clear_clus (clus),__FALSE);
;;;2455             first_offs = 0;
;;;2456             first_clus = clus;
;;;2457             goto allocated;
;;;2458           }
;;;2459           sect = clus_to_sect (clus);
;;;2460         }
;;;2461       }
;;;2462   
;;;2463       EX(read_sector (sect + (idx >> 4)),__FALSE);
;;;2464       frec = (FILEREC *)ca.buf + (idx & 0x0F);
;;;2465   
;;;2466       if ((frec->FileName[0] == 0x00) || (frec->FileName[0] == 0xFF)) {
;;;2467         /* Unused entry. */
;;;2468   
;;;2469         if (ents) {
;;;2470           /* If we found unused entry, and it is after erased entries. */
;;;2471           goto allocated;
;;;2472         }
;;;2473         /* If we found first unused entry. */
;;;2474         first_offs = idx;
;;;2475         first_clus = clus;
;;;2476         goto allocated;
;;;2477       }
;;;2478   
;;;2479       if (frec->FileName[0] == 0xE5) {
;;;2480         /* Erased file, first character is 0xE5. */
;;;2481   
;;;2482         if (ents++ == 0) {
;;;2483           /* If this is first erased entry. */
;;;2484           first_offs = idx;
;;;2485           first_clus = clus;
;;;2486           if (name_ents == 1) {
;;;2487             goto allocated;
;;;2488           }
;;;2489           continue;
;;;2490         }
;;;2491         if (ents >= name_ents) {
;;;2492           goto allocated;
;;;2493         }
;;;2494         continue;
;;;2495       }
;;;2496   
;;;2497       /* If we are searching for entry for allocation skip the rest of loop. */
;;;2498       ents = 0;
;;;2499     }
;;;2500   
;;;2501   allocated:
;;;2502     firstEntOffs      = first_offs;
;;;2503     firstEntClus      = first_clus;
;;;2504     return (__TRUE);
;;;2505   }
0014aa  e8bd83f8          POP      {r3-r9,pc}
                  |L1.5294|
0014ae  f8b81024          LDRH     r1,[r8,#0x24]         ;2441  ; mmc
0014b2  42a1              CMP      r1,r4                 ;2441
0014b4  d12f              BNE      |L1.5398|
0014b6  f8d80028          LDR      r0,[r8,#0x28]         ;2443  ; mmc
0014ba  9900              LDR      r1,[sp,#0]            ;2443
0014bc  2400              MOVS     r4,#0                 ;2442
0014be  4288              CMP      r0,r1                 ;2443
0014c0  d900              BLS      |L1.5316|
0014c2  9000              STR      r0,[sp,#0]            ;2444
                  |L1.5316|
0014c4  4668              MOV      r0,sp                 ;2447
0014c6  9d00              LDR      r5,[sp,#0]            ;2447
0014c8  f7fffffe          BL       set_next_clus
0014cc  2800              CMP      r0,#0                 ;2447
0014ce  d0ec              BEQ      |L1.5290|
0014d0  9800              LDR      r0,[sp,#0]            ;2448
0014d2  f7fffffe          BL       is_EOC
0014d6  b1d0              CBZ      r0,|L1.5390|
0014d8  2101              MOVS     r1,#1                 ;2453
0014da  4668              MOV      r0,sp                 ;2453
0014dc  9500              STR      r5,[sp,#0]            ;2453
0014de  f7fffffe          BL       alloc_new_clus
0014e2  e00b              B        |L1.5372|
                  |L1.5348|
                          DCD      0x000186a0
                  |L1.5352|
                          DCD      0xfffff3cb
                  |L1.5356|
                          DCD      ||.data||
                  |L1.5360|
                          DCD      0x000f423e
                  |L1.5364|
                          DCD      ||.bss||+0x20
                  |L1.5368|
                          DCD      ||.constdata||+0x78
                  |L1.5372|
0014fc  2800              CMP      r0,#0                 ;2453
0014fe  d0d4              BEQ      |L1.5290|
001500  9800              LDR      r0,[sp,#0]            ;2454
001502  f7fffffe          BL       clear_clus
001506  2800              CMP      r0,#0                 ;2454
001508  d0cf              BEQ      |L1.5290|
00150a  2000              MOVS     r0,#0                 ;2455
00150c  e017              B        |L1.5438|
                  |L1.5390|
00150e  9800              LDR      r0,[sp,#0]            ;2459
001510  f7fffffe          BL       clus_to_sect
001514  4605              MOV      r5,r0                 ;2459
                  |L1.5398|
001516  eb051014          ADD      r0,r5,r4,LSR #4       ;2463
00151a  f7fffffe          BL       read_sector
00151e  2800              CMP      r0,#0                 ;2463
001520  d0c3              BEQ      |L1.5290|
001522  48fb              LDR      r0,|L1.6416|
001524  f004010f          AND      r1,r4,#0xf            ;2464
001528  6880              LDR      r0,[r0,#8]            ;2464  ; ca
00152a  eb001041          ADD      r0,r0,r1,LSL #5       ;2464
00152e  7800              LDRB     r0,[r0,#0]            ;2466
001530  b120              CBZ      r0,|L1.5436|
001532  28ff              CMP      r0,#0xff              ;2466
001534  d002              BEQ      |L1.5436|
001536  28e5              CMP      r0,#0xe5              ;2479
001538  d003              BEQ      |L1.5442|
00153a  e006              B        |L1.5450|
                  |L1.5436|
00153c  b2a0              UXTH     r0,r4                 ;2474
                  |L1.5438|
00153e  9900              LDR      r1,[sp,#0]            ;2475
001540  e005              B        |L1.5454|
                  |L1.5442|
001542  9900              LDR      r1,[sp,#0]            ;2486
001544  b2a0              UXTH     r0,r4                 ;2484
001546  2f01              CMP      r7,#1                 ;2486
001548  d001              BEQ      |L1.5454|
                  |L1.5450|
00154a  1c64              ADDS     r4,r4,#1              ;2433
00154c  e7a7              B        |L1.5278|
                  |L1.5454|
00154e  80b0              STRH     r0,[r6,#4]            ;2502
001550  2001              MOVS     r0,#1                 ;2504
001552  6171              STR      r1,[r6,#0x14]         ;2504  ; firstEntClus
001554  e7a9              B        |L1.5290|
;;;2506   
                          ENDP

                  fat_find_dir PROC
;;;583    
;;;584    static BOOL fat_find_dir (const char *fn, IOB *fcb, U8 create) {
001556  e92d47f0          PUSH     {r4-r10,lr}
;;;585      /* Look for directory if it exists and leave fcb to point to directory, 
;;;586         if it does not exist and create == 1, create it. */
;;;587      U8  creating_f;
;;;588      U32 sz;
;;;589    
;;;590      creating_f = 0;
00155a  2600              MOVS     r6,#0
;;;591    
;;;592      while (get_dir_name (fn, name_buf, &sz) == __TRUE) {
;;;593    
;;;594        if (!creating_f) {
;;;595          if (find_name (name_buf, fcb, ENT_DIR) == __FALSE) {
00155c  4cec              LDR      r4,|L1.6416|
00155e  4605              MOV      r5,r0                 ;584
001560  468a              MOV      r10,r1                ;584
001562  4691              MOV      r9,r2                 ;584
001564  4637              MOV      r7,r6                 ;590
001566  3444              ADDS     r4,r4,#0x44
001568  e020              B        |L1.5548|
                  |L1.5482|
00156a  48e9              LDR      r0,|L1.6416|
00156c  2201              MOVS     r2,#1
00156e  4651              MOV      r1,r10
001570  3044              ADDS     r0,r0,#0x44
001572  f7fffffe          BL       find_name
001576  b9c0              CBNZ     r0,|L1.5546|
;;;596            /* Directory does not exist. */
;;;597            if (!create) {
001578  ea5f0009          MOVS     r0,r9
00157c  d02a              BEQ      |L1.5588|
;;;598              /* Directory not found. */
;;;599              return (__FALSE);
;;;600            }
;;;601            /* Create requested, set creating_f flag to 1. */
;;;602            creating_f = 1;
00157e  2601              MOVS     r6,#1
                  |L1.5504|
;;;603          }
;;;604        }
;;;605    
;;;606        if (creating_f) {
;;;607          /* If creation of unexisting directory requested. */
;;;608          EX(alloc_name (name_buf, fcb),__FALSE);
001580  48e3              LDR      r0,|L1.6416|
001582  4651              MOV      r1,r10
001584  3044              ADDS     r0,r0,#0x44
001586  f7fffffe          BL       alloc_name
00158a  2800              CMP      r0,#0
00158c  d022              BEQ      |L1.5588|
;;;609          /* fcb points to unallocated entry. */
;;;610          EX(write_entries (name_buf, fcb, ENT_DIR, ACT_NONE),__FALSE);
00158e  48e0              LDR      r0,|L1.6416|
001590  2300              MOVS     r3,#0
001592  2201              MOVS     r2,#1
001594  4651              MOV      r1,r10
001596  3044              ADDS     r0,r0,#0x44
001598  f7fffffe          BL       write_entries
00159c  2800              CMP      r0,#0
00159e  d019              BEQ      |L1.5588|
;;;611          /* Create '.' and '..' entries in created folder. */
;;;612          EX(write_dot_entries (fcb),__FALSE);
0015a0  4650              MOV      r0,r10
0015a2  f7fffffe          BL       write_dot_entries
0015a6  2800              CMP      r0,#0
0015a8  d014              BEQ      |L1.5588|
                  |L1.5546|
;;;613        }
;;;614        fn += sz;
0015aa  4445              ADD      r5,r5,r8
                  |L1.5548|
0015ac  2000              MOVS     r0,#0
0015ae  4601              MOV      r1,r0
                  |L1.5552|
0015b0  5c2a              LDRB     r2,[r5,r0]
0015b2  2a5c              CMP      r2,#0x5c
0015b4  d006              BEQ      |L1.5572|
0015b6  2a22              CMP      r2,#0x22
0015b8  d004              BEQ      |L1.5572|
0015ba  b14a              CBZ      r2,|L1.5584|
0015bc  5462              STRB     r2,[r4,r1]
0015be  1c49              ADDS     r1,r1,#1
0015c0  1c40              ADDS     r0,r0,#1
0015c2  e7f5              B        |L1.5552|
                  |L1.5572|
0015c4  5467              STRB     r7,[r4,r1]
0015c6  f1000801          ADD      r8,r0,#1
0015ca  2e00              CMP      r6,#0                 ;594
0015cc  d1d8              BNE      |L1.5504|
0015ce  e7cc              B        |L1.5482|
                  |L1.5584|
0015d0  5467              STRB     r7,[r4,r1]            ;594
;;;615      }
;;;616    
;;;617      /* Searched directory was found or created and fcb points to it, in 
;;;618         case of creating directory fcb points to entry after ".." entry. */
;;;619      return (__TRUE);
0015d2  2001              MOVS     r0,#1
                  |L1.5588|
;;;620    }
0015d4  e8bd87f0          POP      {r4-r10,pc}
;;;621    
                          ENDP

                  fat_find_file PROC
;;;624    
;;;625    BOOL fat_find_file (const char *fn, IOB *fcb) {
0015d8  b570              PUSH     {r4-r6,lr}
0015da  460c              MOV      r4,r1
;;;626      /* Look for file if it exists in requested directory, the fcb is left 
;;;627         pointing to requested file entries. */
;;;628    
;;;629      if (mmc.FatType == FS_RAW) {
0015dc  49cc              LDR      r1,|L1.6416|
0015de  3114              ADDS     r1,r1,#0x14
0015e0  7909              LDRB     r1,[r1,#4]  ; mmc
0015e2  b1d9              CBZ      r1,|L1.5660|
;;;630        /* RAW File System or FAT not initialized. */
;;;631        return (__FALSE);
;;;632      }
;;;633    
;;;634      /* Remove starting '\' if it exists. */
;;;635      if (*fn == '\\') fn++;
0015e4  7801              LDRB     r1,[r0,#0]
0015e6  295c              CMP      r1,#0x5c
0015e8  d100              BNE      |L1.5612|
0015ea  1c40              ADDS     r0,r0,#1
                  |L1.5612|
;;;636    
;;;637      /* Exit function if "fn" is not given. */
;;;638      if (*fn == 0) return(__FALSE);
0015ec  7801              LDRB     r1,[r0,#0]
0015ee  b1a9              CBZ      r1,|L1.5660|
;;;639    
;;;640      /* To force search of path from root. */
;;;641      fcb->_firstClus = 0;
0015f0  2500              MOVS     r5,#0
;;;642    
;;;643      /* Search for directory. */
;;;644      if (fat_find_dir (fn, fcb, ACT_NONE) == __FALSE) {
0015f2  462a              MOV      r2,r5
0015f4  4621              MOV      r1,r4
0015f6  61e5              STR      r5,[r4,#0x1c]
0015f8  f7fffffe          BL       fat_find_dir
0015fc  2800              CMP      r0,#0
0015fe  d00c              BEQ      |L1.5658|
;;;645        /* Directory does not exist. */
;;;646        return (__FALSE);
;;;647      }
;;;648    
;;;649      /* Search for file. */
;;;650      if (find_name (name_buf, fcb, ENT_FILE) == __FALSE) {
001600  48c3              LDR      r0,|L1.6416|
001602  2200              MOVS     r2,#0
001604  4621              MOV      r1,r4
001606  3044              ADDS     r0,r0,#0x44
001608  f7fffffe          BL       find_name
00160c  2800              CMP      r0,#0
00160e  d004              BEQ      |L1.5658|
;;;651        /* File does not exist. */
;;;652        return (__FALSE);
;;;653      }
;;;654    
;;;655      /* Set _currDatSect and _currDat Clus to show to data of found file. */
;;;656      fcb->_currDatSect  = 0;
001610  f8845024          STRB     r5,[r4,#0x24]
;;;657      fcb->_currDatClus  = fcb->_firstClus;
001614  69e0              LDR      r0,[r4,#0x1c]
;;;658    
;;;659      /* If file exists. */
;;;660      return (__TRUE);
001616  62a0              STR      r0,[r4,#0x28]
001618  2001              MOVS     r0,#1
                  |L1.5658|
;;;661    }
00161a  bd70              POP      {r4-r6,pc}
                  |L1.5660|
00161c  2000              MOVS     r0,#0                 ;638
00161e  bd70              POP      {r4-r6,pc}
;;;662    
                          ENDP

                  get_next_info PROC
;;;2509   
;;;2510   static BOOL get_next_info (FINFO *info, IOB *fcb) {
001620  e92d5fff          PUSH     {r0-r12,lr}
001624  4605              MOV      r5,r0
;;;2511     /* Return next name (file or directory). */
;;;2512     FILEREC     *frec;
;;;2513     U8           lfn_f         = 0;
001626  2000              MOVS     r0,#0
;;;2514     U8           valid_f       = 0;
001628  9002              STR      r0,[sp,#8]
;;;2515     U8           chksum        = 0;
00162a  9001              STR      r0,[sp,#4]
;;;2516     U8           calc_chksum;
;;;2517     U32          clus          = fcb->_firstClus;
00162c  9003              STR      r0,[sp,#0xc]
00162e  69c8              LDR      r0,[r1,#0x1c]
001630  4688              MOV      r8,r1                 ;2510
;;;2518     U32          idx;
;;;2519     U32          idx_inc       = 0;
001632  2700              MOVS     r7,#0
;;;2520     U32          sect;
;;;2521     U32          i, j;
;;;2522   
;;;2523     sect = get_dir_sect (clus);
001634  9000              STR      r0,[sp,#0]
001636  f7fffffe          BL       get_dir_sect
;;;2524   
;;;2525     /* Search through name entries. */
;;;2526     for (idx = info->fileID;  ; idx++) {
00163a  f8b56104          LDRH     r6,[r5,#0x104]
;;;2527       if (in_root_1x) {
00163e  f8dfa2d4          LDR      r10,|L1.6420|
001642  4681              MOV      r9,r0                 ;2523
001644  ea4f0b07          MOV.W    r11,r7                ;2513
                  |L1.5704|
001648  f89a0001          LDRB     r0,[r10,#1]  ; in_root_1x
00164c  b1b8              CBZ      r0,|L1.5758|
;;;2528         if (idx == 512) {
00164e  f5b67f00          CMP      r6,#0x200
001652  d046              BEQ      |L1.5858|
001654  e018              B        |L1.5768|
                  |L1.5718|
;;;2529           return (__FALSE);
;;;2530         }
;;;2531       }
;;;2532       else {
;;;2533         /* Check if step to next cluster is needed. */
;;;2534         while (idx >= mmc.EntsPerClus) {
;;;2535           idx -= mmc.EntsPerClus;
001656  1a36              SUBS     r6,r6,r0
;;;2536           if (clus < mmc.FAT32_RootClus) {
001658  6aa0              LDR      r0,[r4,#0x28]  ; mmc
00165a  9900              LDR      r1,[sp,#0]
00165c  4288              CMP      r0,r1
00165e  d900              BLS      |L1.5730|
;;;2537             clus = mmc.FAT32_RootClus;
001660  9000              STR      r0,[sp,#0]
                  |L1.5730|
;;;2538           }
;;;2539           EX(set_next_clus (&clus),__FALSE);
001662  4668              MOV      r0,sp
001664  f7fffffe          BL       set_next_clus
001668  2800              CMP      r0,#0
00166a  d076              BEQ      |L1.5978|
;;;2540           if (is_EOC (clus)) {
00166c  9800              LDR      r0,[sp,#0]
00166e  f7fffffe          BL       is_EOC
001672  bbb0              CBNZ     r0,|L1.5858|
;;;2541             /* No more entries. */
;;;2542             goto no_more_entries;
;;;2543           }
;;;2544           sect = clus_to_sect (clus);
001674  9800              LDR      r0,[sp,#0]
001676  f7fffffe          BL       clus_to_sect
00167a  4681              MOV      r9,r0
00167c  e001              B        |L1.5762|
                  |L1.5758|
00167e  4ca4              LDR      r4,|L1.6416|
001680  3414              ADDS     r4,r4,#0x14           ;2535
                  |L1.5762|
001682  8ca0              LDRH     r0,[r4,#0x24]         ;2534  ; mmc
001684  42b0              CMP      r0,r6                 ;2534
001686  d9e6              BLS      |L1.5718|
                  |L1.5768|
;;;2545         }
;;;2546       }
;;;2547       idx_inc ++;
001688  1c7f              ADDS     r7,r7,#1
;;;2548   
;;;2549       EX(read_sector (sect + (idx >> 4)),__FALSE);
00168a  eb091016          ADD      r0,r9,r6,LSR #4
00168e  f7fffffe          BL       read_sector
001692  2800              CMP      r0,#0
001694  d061              BEQ      |L1.5978|
;;;2550       frec      = (FILEREC *)ca.buf + (idx & 0x0F);
001696  489e              LDR      r0,|L1.6416|
001698  f006010f          AND      r1,r6,#0xf
00169c  6880              LDR      r0,[r0,#8]  ; ca
00169e  eb001441          ADD      r4,r0,r1,LSL #5
;;;2551   
;;;2552       if (frec->FileName[0] == 0x00) {
0016a2  7820              LDRB     r0,[r4,#0]
0016a4  b1e8              CBZ      r0,|L1.5858|
;;;2553         /* There are no allocated entries after this one. */
;;;2554         goto no_more_entries;
;;;2555       }
;;;2556   
;;;2557       if (frec->FileName[0] == 0xE5) {
0016a6  28e5              CMP      r0,#0xe5
0016a8  d03e              BEQ      |L1.5928|
;;;2558         /* Erased file, first character is 0xE5. */
;;;2559         continue;
;;;2560       }
;;;2561   
;;;2562       if (frec->Attr == ATTR_VOLUME_ID) {
0016aa  7ae1              LDRB     r1,[r4,#0xb]
0016ac  2908              CMP      r1,#8
0016ae  d03b              BEQ      |L1.5928|
;;;2563         /* Skip Volume ID entry. */
;;;2564         continue;
;;;2565       }
;;;2566   
;;;2567       if ((frec->Attr == ATTR_LONG_NAME) && (LFN_REC(frec)->Ordinal & ORD_LONG_NAME_LAST)) {
0016b0  290f              CMP      r1,#0xf
0016b2  d107              BNE      |L1.5828|
0016b4  0640              LSLS     r0,r0,#25
0016b6  d505              BPL      |L1.5828|
;;;2568         /* Long name last entry found. */
;;;2569         lfn_f   = 1;
0016b8  2001              MOVS     r0,#1
;;;2570         valid_f = 1;
0016ba  9002              STR      r0,[sp,#8]
;;;2571         chksum  = LFN_REC(frec)->Checksum;
0016bc  9001              STR      r0,[sp,#4]
0016be  7b60              LDRB     r0,[r4,#0xd]
0016c0  9003              STR      r0,[sp,#0xc]
0016c2  e011              B        |L1.5864|
                  |L1.5828|
;;;2572       }
;;;2573   
;;;2574       if (lfn_f) {
0016c4  9802              LDR      r0,[sp,#8]
0016c6  b388              CBZ      r0,|L1.5932|
;;;2575         /* Long name entry found. */
;;;2576   
;;;2577         if (frec->Attr != ATTR_LONG_NAME) {
0016c8  290f              CMP      r1,#0xf
0016ca  d00b              BEQ      |L1.5860|
;;;2578           /* If this is long name's accompanying short entry. */
;;;2579           lfn_f = 0;
0016cc  2000              MOVS     r0,#0
;;;2580   
;;;2581           /* Calculate short name's checksum. */
;;;2582           calc_chksum = lfn_calc_chksum (frec->FileName);
0016ce  9002              STR      r0,[sp,#8]
0016d0  4620              MOV      r0,r4
0016d2  f7fffffe          BL       lfn_calc_chksum
;;;2583           if ((valid_f) && (calc_chksum == chksum)) {
0016d6  9901              LDR      r1,[sp,#4]
0016d8  b331              CBZ      r1,|L1.5928|
0016da  9903              LDR      r1,[sp,#0xc]
0016dc  4288              CMP      r0,r1
0016de  d047              BEQ      |L1.6000|
0016e0  e002              B        |L1.5864|
                  |L1.5858|
0016e2  e071              B        |L1.6088|
                  |L1.5860|
;;;2584             goto found;
;;;2585           }
;;;2586         }
;;;2587   
;;;2588         if (!valid_f) {
0016e4  9801              LDR      r0,[sp,#4]
0016e6  b1f8              CBZ      r0,|L1.5928|
                  |L1.5864|
;;;2589           /* If this is not a valid entry. */
;;;2590           continue;
;;;2591         }
;;;2592   
;;;2593         if (chksum != LFN_REC(frec)->Checksum) {
0016e8  7b61              LDRB     r1,[r4,#0xd]
0016ea  9803              LDR      r0,[sp,#0xc]
0016ec  4281              CMP      r1,r0
0016ee  d002              BEQ      |L1.5878|
;;;2594           /* If any of long entries does not have the same checksum 
;;;2595              as previous ones then this name is invalid. */
;;;2596           valid_f = 0;
0016f0  2000              MOVS     r0,#0
;;;2597           continue;
0016f2  9001              STR      r0,[sp,#4]
0016f4  e018              B        |L1.5928|
                  |L1.5878|
;;;2598         }
;;;2599   
;;;2600         /* Long name checking in progress. */
;;;2601         i = ((LFN_REC(frec)->Ordinal & 0x1F) - 1) * 13;
0016f6  7820              LDRB     r0,[r4,#0]
0016f8  4b87              LDR      r3,|L1.6424|
0016fa  f000001f          AND      r0,r0,#0x1f
0016fe  1e40              SUBS     r0,r0,#1
001700  eb000180          ADD      r1,r0,r0,LSL #2
001704  eb010cc0          ADD      r12,r1,r0,LSL #3
;;;2602   
;;;2603         /* Copy all 13 name characters to info->name array. */
;;;2604         lfn_copy_info (&info->name[i], (U8 *)frec);
001708  eb05010c          ADD      r1,r5,r12
00170c  2000              MOVS     r0,#0
                  |L1.5902|
00170e  5c1a              LDRB     r2,[r3,r0]
001710  5ca2              LDRB     r2,[r4,r2]
001712  540a              STRB     r2,[r1,r0]
001714  1c40              ADDS     r0,r0,#1
001716  280d              CMP      r0,#0xd
001718  d3f9              BCC      |L1.5902|
;;;2605         i += 13;
;;;2606   
;;;2607         if (LFN_REC(frec)->Ordinal & ORD_LONG_NAME_LAST) {
00171a  7820              LDRB     r0,[r4,#0]
00171c  f10c0c0d          ADD      r12,r12,#0xd          ;2605
001720  0640              LSLS     r0,r0,#25
001722  d501              BPL      |L1.5928|
;;;2608           info->name[i] = 0;
001724  f805b00c          STRB     r11,[r5,r12]
                  |L1.5928|
001728  1c76              ADDS     r6,r6,#1              ;2526
00172a  e78d              B        |L1.5704|
                  |L1.5932|
00172c  e7ff              B        |L1.5934|
                  |L1.5934|
;;;2609         }
;;;2610       }
;;;2611       else {
;;;2612         /* Short name entry found. */
;;;2613   
;;;2614         i = 7;
00172e  2107              MOVS     r1,#7
;;;2615         while (frec->FileName[i] == ' ') {
001730  e000              B        |L1.5940|
                  |L1.5938|
;;;2616           i--;
001732  1e49              SUBS     r1,r1,#1
                  |L1.5940|
001734  5c60              LDRB     r0,[r4,r1]            ;2615
001736  2820              CMP      r0,#0x20              ;2615
001738  d0fb              BEQ      |L1.5938|
;;;2617         }
;;;2618         ++ i;
00173a  1c49              ADDS     r1,r1,#1
;;;2619         for (j = 0; j < i; j++) {
00173c  2000              MOVS     r0,#0
00173e  e002              B        |L1.5958|
                  |L1.5952|
;;;2620           info->name[j] = frec->FileName[j];
001740  5c22              LDRB     r2,[r4,r0]
001742  542a              STRB     r2,[r5,r0]
001744  1c40              ADDS     r0,r0,#1              ;2619
                  |L1.5958|
001746  4288              CMP      r0,r1                 ;2619
001748  d3fa              BCC      |L1.5952|
;;;2621         }
;;;2622         if (frec->FileName[8] != ' ') {
00174a  7a21              LDRB     r1,[r4,#8]
00174c  2920              CMP      r1,#0x20
00174e  d00d              BEQ      |L1.5996|
;;;2623           info->name[j++] = '.';
001750  212e              MOVS     r1,#0x2e
001752  5429              STRB     r1,[r5,r0]
001754  1c40              ADDS     r0,r0,#1
;;;2624           i = 8;
001756  2108              MOVS     r1,#8
;;;2625           while ((frec->FileName[i] != ' ') && (i < 11)) {
001758  e003              B        |L1.5986|
                  |L1.5978|
00175a  e032              B        |L1.6082|
                  |L1.5980|
;;;2626             info->name[j++] = frec->FileName[i++];
00175c  542a              STRB     r2,[r5,r0]
00175e  1c49              ADDS     r1,r1,#1
001760  1c40              ADDS     r0,r0,#1
                  |L1.5986|
001762  5c62              LDRB     r2,[r4,r1]            ;2625
001764  2a20              CMP      r2,#0x20              ;2625
001766  d001              BEQ      |L1.5996|
001768  290b              CMP      r1,#0xb               ;2625
00176a  d3f7              BCC      |L1.5980|
                  |L1.5996|
;;;2627           }
;;;2628         }
;;;2629         info->name[j] = 0;
00176c  f805b000          STRB     r11,[r5,r0]
                  |L1.6000|
001770  f5057582          ADD      r5,r5,#0x104
;;;2630         goto found;
;;;2631       }
;;;2632     }
;;;2633   
;;;2634   no_more_entries:
;;;2635     return (__FALSE);
;;;2636   
;;;2637   found:
;;;2638     info->fileID += idx_inc;
001774  8828              LDRH     r0,[r5,#0]
001776  4438              ADD      r0,r0,r7
001778  8028              STRH     r0,[r5,#0]
;;;2639     fcb->attrib   = frec->Attr;
00177a  7ae1              LDRB     r1,[r4,#0xb]
00177c  f8881005          STRB     r1,[r8,#5]
001780  7f20              LDRB     r0,[r4,#0x1c]
001782  f8d4101d          LDR      r1,[r4,#0x1d]
001786  ea402001          ORR      r0,r0,r1,LSL #8
00178a  f8c8002c          STR      r0,[r8,#0x2c]
00178e  8ae0              LDRH     r0,[r4,#0x16]
001790  ea4f21d0          LSR      r1,r0,#11
001794  7129              STRB     r1,[r5,#4]
001796  f3c01145          UBFX     r1,r0,#5,#6
00179a  ea4f60c0          LSL      r0,r0,#27
00179e  7169              STRB     r1,[r5,#5]
0017a0  ea4f6090          LSR      r0,r0,#26
0017a4  71a8              STRB     r0,[r5,#6]
0017a6  8b20              LDRH     r0,[r4,#0x18]
0017a8  f000011f          AND      r1,r0,#0x1f
0017ac  71e9              STRB     r1,[r5,#7]
0017ae  f3c01143          UBFX     r1,r0,#5,#4
0017b2  ea4f2050          LSR      r0,r0,#9
0017b6  7229              STRB     r1,[r5,#8]
0017b8  f20070bc          ADD      r0,r0,#0x7bc
0017bc  8168              STRH     r0,[r5,#0xa]
;;;2640     fcb->fsize    = get_u32 ((U8 *)&frec->FileSize);
;;;2641     set_time_date (info, frec);
;;;2642     return (__TRUE);
0017be  f04f0001          MOV      r0,#1
                  |L1.6082|
;;;2643   }
0017c2  b004              ADD      sp,sp,#0x10
                  |L1.6084|
0017c4  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.6088|
0017c8  2000              MOVS     r0,#0                 ;2635
0017ca  e7fa              B        |L1.6082|
;;;2644   
                          ENDP

                  fat_ffind PROC
;;;665    
;;;666    BOOL fat_ffind (const char *fn, FINFO *info, IOB *fcb) {
0017cc  b570              PUSH     {r4-r6,lr}
0017ce  460d              MOV      r5,r1
;;;667      /* Find a file or directory in requested directory. */
;;;668    
;;;669      if (mmc.FatType == FS_RAW) {
0017d0  494f              LDR      r1,|L1.6416|
0017d2  4614              MOV      r4,r2                 ;666
0017d4  3114              ADDS     r1,r1,#0x14
0017d6  7909              LDRB     r1,[r1,#4]  ; mmc
0017d8  b1a9              CBZ      r1,|L1.6150|
;;;670        /* RAW File System or FAT not initialized. */
;;;671        return (__FALSE);
;;;672      }
;;;673    
;;;674      /* Remove starting '\' if it exists. */
;;;675      if (*fn == '\\') fn++;
0017da  7801              LDRB     r1,[r0,#0]
0017dc  295c              CMP      r1,#0x5c
0017de  d100              BNE      |L1.6114|
0017e0  1c40              ADDS     r0,r0,#1
                  |L1.6114|
;;;676    
;;;677      /* Exit function if "fn" is not given. */
;;;678      if (*fn == 0) return(__FALSE);
0017e2  7801              LDRB     r1,[r0,#0]
0017e4  b179              CBZ      r1,|L1.6150|
;;;679    
;;;680      /* To force search of path from root. */
;;;681      fcb->_firstClus = 0;
0017e6  2100              MOVS     r1,#0
;;;682    
;;;683      /* Search for directory. */
;;;684      if (fat_find_dir (fn, fcb, 0) == __FALSE) {
0017e8  460a              MOV      r2,r1
0017ea  61e1              STR      r1,[r4,#0x1c]
0017ec  4621              MOV      r1,r4
0017ee  f7fffffe          BL       fat_find_dir
0017f2  2800              CMP      r0,#0
0017f4  d006              BEQ      |L1.6148|
;;;685        /* Directory does not exist. */
;;;686        return (__FALSE);
;;;687      }
;;;688    
;;;689      /* Get next valid info. */
;;;690      if (get_next_info (info, fcb) == __FALSE) {
0017f6  4621              MOV      r1,r4
0017f8  4628              MOV      r0,r5
0017fa  f7fffffe          BL       get_next_info
0017fe  2800              CMP      r0,#0
001800  d000              BEQ      |L1.6148|
;;;691        /* No more valid infos in current directory. */
;;;692        return (__FALSE);
;;;693      }
;;;694    
;;;695      /* Info found. */
;;;696      return (__TRUE);
001802  2001              MOVS     r0,#1
                  |L1.6148|
;;;697    }
001804  bd70              POP      {r4-r6,pc}
                  |L1.6150|
001806  2000              MOVS     r0,#0                 ;678
001808  bd70              POP      {r4-r6,pc}
;;;698    
                          ENDP

                  fat_create PROC
;;;701    
;;;702    BOOL fat_create (const char *fn, IOB *fcb) {
00180a  b510              PUSH     {r4,lr}
00180c  460c              MOV      r4,r1
;;;703      /* Create a file or directory in requested directory. */
;;;704    
;;;705      if (mmc.FatType == FS_RAW) {
00180e  4940              LDR      r1,|L1.6416|
001810  3114              ADDS     r1,r1,#0x14
001812  7909              LDRB     r1,[r1,#4]  ; mmc
001814  b1f9              CBZ      r1,|L1.6230|
;;;706        /* RAW File System or FAT not initialized. */
;;;707        return (__FALSE);
;;;708      }
;;;709    
;;;710      /* Remove starting '\' if it exists. */
;;;711      if (*fn == '\\') fn++;
001816  7801              LDRB     r1,[r0,#0]
001818  295c              CMP      r1,#0x5c
00181a  d100              BNE      |L1.6174|
00181c  1c40              ADDS     r0,r0,#1
                  |L1.6174|
;;;712    
;;;713      /* Exit function if "fn" is not given. */
;;;714      if (*fn == 0) return(__FALSE);
00181e  7801              LDRB     r1,[r0,#0]
001820  b1c9              CBZ      r1,|L1.6230|
;;;715    
;;;716      /* To force search of path from root. */
;;;717      fcb->_firstClus = 0;
001822  2100              MOVS     r1,#0
;;;718    
;;;719      /* Search for directory. */
;;;720      if (fat_find_dir (fn, fcb, 1) == __FALSE) {
001824  61e1              STR      r1,[r4,#0x1c]
001826  2201              MOVS     r2,#1
001828  4621              MOV      r1,r4
00182a  f7fffffe          BL       fat_find_dir
00182e  2800              CMP      r0,#0
001830  d010              BEQ      |L1.6228|
;;;721        /* Directory does not exist and could not be created. */
;;;722        return (__FALSE);
;;;723      }
;;;724    
;;;725      /* File does not exist, create one. */
;;;726      if (alloc_name (name_buf, fcb) == __FALSE) {
001832  4837              LDR      r0,|L1.6416|
001834  4621              MOV      r1,r4
001836  3044              ADDS     r0,r0,#0x44
001838  f7fffffe          BL       alloc_name
00183c  2800              CMP      r0,#0
00183e  d009              BEQ      |L1.6228|
;;;727        /* If unable to find unallocated entry to create file. */
;;;728        return (__FALSE);
;;;729      }
;;;730    
;;;731      /* fcb points to unallocated entry. */
;;;732      if (write_entries (name_buf, fcb, ENT_FILE, ACT_NONE) == __FALSE) {
001840  4833              LDR      r0,|L1.6416|
001842  2300              MOVS     r3,#0
001844  461a              MOV      r2,r3
001846  4621              MOV      r1,r4
001848  3044              ADDS     r0,r0,#0x44
00184a  f7fffffe          BL       write_entries
00184e  2800              CMP      r0,#0
001850  d000              BEQ      |L1.6228|
;;;733        /* If unable to write entries for new file. */
;;;734        return (__FALSE);
;;;735      }
;;;736    
;;;737      /* File created. */
;;;738      return (__TRUE);
001852  2001              MOVS     r0,#1
                  |L1.6228|
;;;739    }
001854  bd10              POP      {r4,pc}
                  |L1.6230|
001856  2000              MOVS     r0,#0                 ;714
001858  bd10              POP      {r4,pc}
;;;740    
                          ENDP

                  unlink_clus_chain PROC
;;;1242   
;;;1243   static BOOL unlink_clus_chain (U32 clus) {
00185a  e92d5ff0          PUSH     {r4-r12,lr}
;;;1244     /* Remove a cluster chain starting with 'clus'. Reset the values to 0.*/
;;;1245     U32 sect,ofs,next,temp;
;;;1246   
;;;1247     if (clus < 2) {
;;;1248       /* An empty file, do nothing here. */
;;;1249       return (__TRUE);
;;;1250     }
;;;1251   
;;;1252     while (clus < (mmc.DataClusCnt + 2)) {
;;;1253       /* Reset top used cluster index. */
;;;1254       if (clus < top_clus) {
;;;1255         top_clus = clus;
;;;1256       }
;;;1257       sect = get_fat_sect (clus);
;;;1258       EX(cache_fat (sect),__FALSE);
;;;1259   
;;;1260       switch (mmc.FatType) {
;;;1261         case FS_FAT12:
;;;1262           ofs  = ((clus * 3) / 2) & 0x1FF;
;;;1263           if (ofs < 511) {
;;;1264             next = get_u16 (&fat.buf[ofs]);
00185e  4f2c              LDR      r7,|L1.6416|
001860  4d2c              LDR      r5,|L1.6420|
001862  3f0c              SUBS     r7,r7,#0xc
001864  4604              MOV      r4,r0                 ;1243
001866  f04f0900          MOV      r9,#0                 ;1258
00186a  f04f0801          MOV      r8,#1                 ;1249
00186e  f1070620          ADD      r6,r7,#0x20           ;1260
001872  2802              CMP      r0,#2                 ;1247
001874  d37d              BCC      |L1.6514|
001876  e076              B        |L1.6502|
                  |L1.6264|
001878  68e8              LDR      r0,[r5,#0xc]          ;1254  ; top_clus
00187a  4284              CMP      r4,r0                 ;1254
00187c  d200              BCS      |L1.6272|
00187e  60ec              STR      r4,[r5,#0xc]          ;1255  ; top_clus
                  |L1.6272|
001880  4620              MOV      r0,r4                 ;1257
001882  f7fffffe          BL       get_fat_sect
001886  4683              MOV      r11,r0                ;1257
001888  f7fffffe          BL       cache_fat
00188c  2800              CMP      r0,#0                 ;1258
00188e  d099              BEQ      |L1.6084|
001890  7930              LDRB     r0,[r6,#4]            ;1260  ; mmc
001892  2801              CMP      r0,#1                 ;1260
001894  d004              BEQ      |L1.6304|
001896  2802              CMP      r0,#2                 ;1260
001898  d047              BEQ      |L1.6442|
00189a  2803              CMP      r0,#3                 ;1260
00189c  d170              BNE      |L1.6528|
00189e  e04d              B        |L1.6460|
                  |L1.6304|
0018a0  eb040044          ADD      r0,r4,r4,LSL #1       ;1262
0018a4  f3c00048          UBFX     r0,r0,#1,#9           ;1262
0018a8  f5b07fff          CMP      r0,#0x1fe             ;1263
0018ac  d811              BHI      |L1.6354|
;;;1265             if (clus & 0x001) {
0018ae  6879              LDR      r1,[r7,#4]  ; fat
0018b0  07e2              LSLS     r2,r4,#31
0018b2  4408              ADD      r0,r0,r1              ;1264
0018b4  8801              LDRH     r1,[r0,#0]            ;1264
0018b6  d003              BEQ      |L1.6336|
;;;1266               temp = next & 0x000F;
0018b8  f001020f          AND      r2,r1,#0xf
;;;1267               next >>= 4;
0018bc  0909              LSRS     r1,r1,#4
0018be  e003              B        |L1.6344|
                  |L1.6336|
;;;1268             }
;;;1269             else {
;;;1270               temp = next & 0xF000;
0018c0  f4014270          AND      r2,r1,#0xf000
;;;1271               next &= 0xFFF;
0018c4  f3c1010b          UBFX     r1,r1,#0,#12
                  |L1.6344|
0018c8  468a              MOV      r10,r1
;;;1272             }
;;;1273             set_u16 (&fat.buf[ofs], temp);
0018ca  b291              UXTH     r1,r2
0018cc  f7fffffe          BL       set_u16
0018d0  e041              B        |L1.6486|
                  |L1.6354|
;;;1274           }
;;;1275           else {
;;;1276             /* This cluster spans on two sectors in the FAT. */
;;;1277             next = fat.buf[511];
;;;1278             if (clus & 0x001) {
0018d2  6878              LDR      r0,[r7,#4]  ; fat
0018d4  07e1              LSLS     r1,r4,#31
0018d6  f89011ff          LDRB     r1,[r0,#0x1ff]        ;1277
0018da  468a              MOV      r10,r1                ;1277
0018dc  d004              BEQ      |L1.6376|
;;;1279               fat.buf[511] &= 0x0F;
0018de  f001010f          AND      r1,r1,#0xf
0018e2  f88011ff          STRB     r1,[r0,#0x1ff]
0018e6  e001              B        |L1.6380|
                  |L1.6376|
;;;1280             }
;;;1281             else {
;;;1282               fat.buf[511] = 0;
0018e8  f88091ff          STRB     r9,[r0,#0x1ff]
                  |L1.6380|
;;;1283             }
;;;1284             fat.dirty = __TRUE;
0018ec  f8878008          STRB     r8,[r7,#8]
;;;1285             sect++;
0018f0  f10b0001          ADD      r0,r11,#1
;;;1286             EX(cache_fat (sect),__FALSE);
0018f4  f7fffffe          BL       cache_fat
0018f8  2800              CMP      r0,#0
0018fa  d03b              BEQ      |L1.6516|
;;;1287             next |= fat.buf[0] << 8;
;;;1288             if (clus & 0x001) {
0018fc  6878              LDR      r0,[r7,#4]  ; fat
0018fe  07e2              LSLS     r2,r4,#31
001900  7802              LDRB     r2,[r0,#0]            ;1287
001902  ea4a2102          ORR      r1,r10,r2,LSL #8      ;1287
001906  d009              BEQ      |L1.6428|
;;;1289               fat.buf[0] = 0;
001908  f8809000          STRB     r9,[r0,#0]
;;;1290               next >>= 4;
00190c  0908              LSRS     r0,r1,#4
00190e  e00a              B        |L1.6438|
                  |L1.6416|
                          DCD      ||.bss||+0xc
                  |L1.6420|
                          DCD      ||.data||
                  |L1.6424|
                          DCD      ||.constdata||+0x78
                  |L1.6428|
;;;1291             }
;;;1292             else {
;;;1293               fat.buf[0] &= 0xF0;
00191c  f00202f0          AND      r2,r2,#0xf0
001920  7002              STRB     r2,[r0,#0]
;;;1294               next &= 0xFFF;
001922  f3c1000b          UBFX     r0,r1,#0,#12
                  |L1.6438|
001926  4682              MOV      r10,r0                ;1290
001928  e015              B        |L1.6486|
                  |L1.6442|
;;;1295             }
;;;1296           }
;;;1297           goto chk_eoc;
;;;1298   
;;;1299         case FS_FAT16:
;;;1300           ofs  = (clus & 0xFF) << 1;
00192a  0620              LSLS     r0,r4,#24
;;;1301           next = get_u16 (&fat.buf[ofs]);
00192c  6879              LDR      r1,[r7,#4]  ; fat
00192e  0dc0              LSRS     r0,r0,#23             ;1300
001930  180b              ADDS     r3,r1,r0
001932  f8b3a000          LDRH     r10,[r3,#0]
;;;1302           *(U16 *)&fat.buf[ofs] = 0;
001936  f8219000          STRH     r9,[r1,r0]
;;;1303           goto chk_eoc;
00193a  e00c              B        |L1.6486|
                  |L1.6460|
;;;1304   
;;;1305         case FS_FAT32:
;;;1306           ofs  = (clus & 0x7F) << 2;
00193c  0660              LSLS     r0,r4,#25
00193e  0dc4              LSRS     r4,r0,#23
;;;1307           next = get_u32 (&fat.buf[ofs]);
001940  6878              LDR      r0,[r7,#4]  ; fat
001942  4420              ADD      r0,r0,r4
001944  f7fffffe          BL       get_u32
;;;1308           *(U32 *)&fat.buf[ofs] = 0;
001948  6879              LDR      r1,[r7,#4]  ; fat
00194a  4682              MOV      r10,r0                ;1307
00194c  f8419004          STR      r9,[r1,r4]
;;;1309           free_clus++;
001950  68a8              LDR      r0,[r5,#8]  ; free_clus
001952  1c40              ADDS     r0,r0,#1
001954  60a8              STR      r0,[r5,#8]  ; free_clus
                  |L1.6486|
;;;1310   chk_eoc:fat.dirty = __TRUE;
001956  f8878008          STRB     r8,[r7,#8]
;;;1311           if (is_EOC (next) == __TRUE) {
00195a  4650              MOV      r0,r10
00195c  f7fffffe          BL       is_EOC
001960  2801              CMP      r0,#1
001962  d00f              BEQ      |L1.6532|
;;;1312             EX(cache_fat (0),__FALSE);
;;;1313             return (__TRUE);
;;;1314           }
;;;1315           break;
;;;1316   
;;;1317         default:
;;;1318           return (__FALSE);
;;;1319       }
;;;1320       clus = next;
001964  4654              MOV      r4,r10
                  |L1.6502|
001966  69b0              LDR      r0,[r6,#0x18]         ;1252  ; mmc
001968  1c80              ADDS     r0,r0,#2              ;1252
00196a  42a0              CMP      r0,r4                 ;1252
00196c  d884              BHI      |L1.6264|
;;;1321     }
;;;1322     EX(cache_fat (0),__FALSE);
00196e  2000              MOVS     r0,#0
001970  e002              B        |L1.6520|
                  |L1.6514|
001972  e00c              B        |L1.6542|
                  |L1.6516|
001974  e005              B        |L1.6530|
001976  e003              B        |L1.6528|
                  |L1.6520|
001978  f7fffffe          BL       cache_fat
00197c  2800              CMP      r0,#0
00197e  d000              BEQ      |L1.6530|
                  |L1.6528|
;;;1323     /* Failed, something wrong with FAT table. */
;;;1324     return (__FALSE);
001980  2000              MOVS     r0,#0
                  |L1.6530|
;;;1325   }
001982  e71f              B        |L1.6084|
                  |L1.6532|
001984  2000              MOVS     r0,#0                 ;1312
001986  f7fffffe          BL       cache_fat
00198a  2800              CMP      r0,#0                 ;1312
00198c  d0f9              BEQ      |L1.6530|
                  |L1.6542|
00198e  2001              MOVS     r0,#1                 ;1313
001990  e718              B        |L1.6084|
;;;1326   
                          ENDP

                  delete_entries PROC
;;;2980   
;;;2981   static BOOL delete_entries (IOB *fcb, U8 keep_data) {
001992  e92d4ff8          PUSH     {r3-r11,lr}
001996  4681              MOV      r9,r0
001998  468a              MOV      r10,r1
;;;2982     /* Delete entries that fcb is pointing to.*/
;;;2983     FILEREC     *frec;
;;;2984     U8           ents          = numOfEntries;
00199a  4eff              LDR      r6,|L1.7576|
00199c  7835              LDRB     r5,[r6,#0]  ; numOfEntries
;;;2985     U32          clus          = firstEntClus;
00199e  6970              LDR      r0,[r6,#0x14]  ; firstEntClus
;;;2986     U32          idx           = firstEntOffs;
0019a0  9000              STR      r0,[sp,#0]
0019a2  88b4              LDRH     r4,[r6,#4]  ; firstEntOffs
;;;2987     U32          sect;
;;;2988   
;;;2989     /* Calculate address of sector where deletion starts. */
;;;2990     sect = get_dir_sect (clus);
0019a4  f7fffffe          BL       get_dir_sect
0019a8  4607              MOV      r7,r0
;;;2991   
;;;2992     for ( ; ents != 0; idx ++) {
;;;2993       /* Check if step to next cluster is needed. */
;;;2994       if (in_root_1x) {
;;;2995         if (idx == 512) {
;;;2996           goto fail;
;;;2997         }
;;;2998       }
;;;2999       else {
;;;3000         /* Check if step to next cluster is needed. */
;;;3001         if (idx == mmc.EntsPerClus) {
0019aa  f8df83f0          LDR      r8,|L1.7580|
0019ae  e035              B        |L1.6684|
                  |L1.6576|
0019b0  7870              LDRB     r0,[r6,#1]            ;2994  ; in_root_1x
0019b2  b118              CBZ      r0,|L1.6588|
0019b4  f5b47f00          CMP      r4,#0x200             ;2995
0019b8  d03e              BEQ      |L1.6712|
0019ba  e013              B        |L1.6628|
                  |L1.6588|
0019bc  f8b81024          LDRH     r1,[r8,#0x24]  ; mmc
0019c0  42a1              CMP      r1,r4
0019c2  d10f              BNE      |L1.6628|
;;;3002           idx = 0;
;;;3003           if (clus < mmc.FAT32_RootClus) {
0019c4  f8d80028          LDR      r0,[r8,#0x28]  ; mmc
0019c8  9900              LDR      r1,[sp,#0]
0019ca  2400              MOVS     r4,#0                 ;3002
0019cc  4288              CMP      r0,r1
0019ce  d900              BLS      |L1.6610|
;;;3004             clus = mmc.FAT32_RootClus;
0019d0  9000              STR      r0,[sp,#0]
                  |L1.6610|
;;;3005           }
;;;3006           EX(set_next_clus (&clus),__FALSE);
0019d2  4668              MOV      r0,sp
0019d4  f7fffffe          BL       set_next_clus
0019d8  2800              CMP      r0,#0
0019da  d02b              BEQ      |L1.6708|
;;;3007           sect = clus_to_sect (clus);
0019dc  9800              LDR      r0,[sp,#0]
0019de  f7fffffe          BL       clus_to_sect
0019e2  4607              MOV      r7,r0
                  |L1.6628|
;;;3008         }
;;;3009       }
;;;3010   
;;;3011       EX(read_sector (sect + (idx >> 4)),__FALSE);
0019e4  eb071014          ADD      r0,r7,r4,LSR #4
0019e8  4683              MOV      r11,r0
0019ea  f7fffffe          BL       read_sector
0019ee  2800              CMP      r0,#0
0019f0  d020              BEQ      |L1.6708|
;;;3012       frec              = (FILEREC *)ca.buf + (idx & 0x0F);
0019f2  48ea              LDR      r0,|L1.7580|
0019f4  f004020f          AND      r2,r4,#0xf
0019f8  3814              SUBS     r0,r0,#0x14
;;;3013       frec->FileName[0] = 0xE5;
0019fa  21e5              MOVS     r1,#0xe5
0019fc  6880              LDR      r0,[r0,#8]            ;3012  ; ca
;;;3014   
;;;3015       -- ents;
0019fe  1e6d              SUBS     r5,r5,#1
001a00  eb001042          ADD      r0,r0,r2,LSL #5       ;3012
001a04  b2ed              UXTB     r5,r5
001a06  7001              STRB     r1,[r0,#0]            ;3013
;;;3016       if (((idx & 0x0F) == 0x0F) || (ents == 0)) {
001a08  43e0              MVNS     r0,r4
001a0a  0700              LSLS     r0,r0,#28
001a0c  d000              BEQ      |L1.6672|
001a0e  b925              CBNZ     r5,|L1.6682|
                  |L1.6672|
001a10  4658              MOV      r0,r11
;;;3017         /* Write last previously used sector as we are going to use next one. */
;;;3018         EX(write_sector (sect + (idx >> 4)),__FALSE);
001a12  f7fffffe          BL       write_sector
001a16  2800              CMP      r0,#0
001a18  d00c              BEQ      |L1.6708|
                  |L1.6682|
001a1a  1c64              ADDS     r4,r4,#1              ;2992
                  |L1.6684|
001a1c  2d00              CMP      r5,#0                 ;2992
001a1e  d1c7              BNE      |L1.6576|
;;;3019       }
;;;3020     }
;;;3021   
;;;3022     if (!keep_data) {
001a20  f1ba0f00          CMP      r10,#0
001a24  d105              BNE      |L1.6706|
;;;3023       /* Reset FAT table linked clusters to 0. */
;;;3024       EX(unlink_clus_chain (fcb->_firstClus),__FALSE);
001a26  f8d9001c          LDR      r0,[r9,#0x1c]
001a2a  f7fffffe          BL       unlink_clus_chain
001a2e  2800              CMP      r0,#0
001a30  d000              BEQ      |L1.6708|
                  |L1.6706|
;;;3025     }
;;;3026   
;;;3027     /* Entries deleted successfully. */
;;;3028     return (__TRUE);
001a32  2001              MOVS     r0,#1
                  |L1.6708|
;;;3029   
;;;3030   fail:
;;;3031     return (__FALSE);
;;;3032   }
001a34  e8bd8ff8          POP      {r3-r11,pc}
                  |L1.6712|
001a38  2000              MOVS     r0,#0                 ;3031
001a3a  e7fb              B        |L1.6708|
;;;3033   
                          ENDP

                  fat_delete PROC
;;;743    
;;;744    BOOL fat_delete (const char *fn, IOB *fcb) {
001a3c  b510              PUSH     {r4,lr}
001a3e  460c              MOV      r4,r1
;;;745      /* Delete a file or directory from requested directory. */
;;;746    
;;;747      if (mmc.FatType == FS_RAW) {
001a40  49d6              LDR      r1,|L1.7580|
001a42  7909              LDRB     r1,[r1,#4]  ; mmc
001a44  b1c1              CBZ      r1,|L1.6776|
;;;748        /* RAW File System or FAT not initialized. */
;;;749        return (__FALSE);
;;;750      }
;;;751    
;;;752      /* Remove starting '\' if it exists. */
;;;753      if (*fn == '\\') fn++;
001a46  7801              LDRB     r1,[r0,#0]
001a48  295c              CMP      r1,#0x5c
001a4a  d100              BNE      |L1.6734|
001a4c  1c40              ADDS     r0,r0,#1
                  |L1.6734|
;;;754    
;;;755      /* Exit function if "fn" is not given. */
;;;756      if (*fn == 0) return(__FALSE);
001a4e  7801              LDRB     r1,[r0,#0]
001a50  b191              CBZ      r1,|L1.6776|
;;;757    
;;;758      /* To force search of path from root. */
;;;759      fcb->_firstClus = 0;
001a52  2100              MOVS     r1,#0
;;;760    
;;;761      /* Search for directory. */
;;;762      if (fat_find_dir (fn, fcb, 0) == __FALSE) {
001a54  460a              MOV      r2,r1
001a56  61e1              STR      r1,[r4,#0x1c]
001a58  4621              MOV      r1,r4
001a5a  f7fffffe          BL       fat_find_dir
001a5e  2800              CMP      r0,#0
001a60  d00b              BEQ      |L1.6778|
;;;763        /* Directory does not exist. */
;;;764        return (__FALSE);
;;;765      }
;;;766    
;;;767      if (name_buf[0]) {
001a62  48ce              LDR      r0,|L1.7580|
001a64  3030              ADDS     r0,r0,#0x30
001a66  7800              LDRB     r0,[r0,#0]  ; name_buf
001a68  b140              CBZ      r0,|L1.6780|
;;;768        /* Search for file. */
;;;769        if (find_name (name_buf, fcb, ENT_FILE) == __FALSE) {
001a6a  48cc              LDR      r0,|L1.7580|
001a6c  2200              MOVS     r2,#0
001a6e  4621              MOV      r1,r4
001a70  3030              ADDS     r0,r0,#0x30
001a72  f7fffffe          BL       find_name
001a76  e004              B        |L1.6786|
                  |L1.6776|
001a78  2000              MOVS     r0,#0                 ;756
                  |L1.6778|
;;;770          /* File does not exist. */
;;;771          return (__FALSE);
;;;772        }
;;;773      }
;;;774      else {
;;;775        /* We want to delete a directory, see if it is empty. */
;;;776        if (chk_dir_empty (fcb) == __FALSE) {
;;;777          /* Directory is not empty, do not delete it. */
;;;778          return (__FALSE);
;;;779        }
;;;780      }
;;;781    
;;;782      /* File or directory entries found and fcb points to first entry. */
;;;783      if (delete_entries (fcb, 0) == __FALSE) {
;;;784        /* If file or directory was not deleted successfully. */
;;;785        return (__FALSE);
;;;786      }
;;;787    
;;;788      /* File was deleted. */
;;;789      return (__TRUE);
;;;790    }
001a7a  bd10              POP      {r4,pc}
                  |L1.6780|
001a7c  4620              MOV      r0,r4                 ;776
001a7e  f7fffffe          BL       chk_dir_empty
                  |L1.6786|
001a82  2800              CMP      r0,#0                 ;776
001a84  d0f9              BEQ      |L1.6778|
001a86  2100              MOVS     r1,#0                 ;783
001a88  4620              MOV      r0,r4                 ;783
001a8a  f7fffffe          BL       delete_entries
001a8e  2800              CMP      r0,#0                 ;783
001a90  d0f3              BEQ      |L1.6778|
001a92  2001              MOVS     r0,#1                 ;789
001a94  bd10              POP      {r4,pc}
;;;791    
                          ENDP

                  read_cache PROC
;;;1508   
;;;1509   static BOOL read_cache (U32 sect, U32 cnt) {
001a96  b570              PUSH     {r4-r6,lr}
001a98  4605              MOV      r5,r0
;;;1510     /* Read a 512 byte sector from Flash Card. */
;;;1511   
;;;1512     if ((_MC_CSIZE == 0) || (ca.nwr > 0)) {
001a9a  48c1              LDR      r0,|L1.7584|
001a9c  460e              MOV      r6,r1                 ;1509
001a9e  8801              LDRH     r1,[r0,#0]  ; _MC_CSIZE
001aa0  b119              CBZ      r1,|L1.6826|
001aa2  4cbe              LDR      r4,|L1.7580|
001aa4  3c14              SUBS     r4,r4,#0x14
001aa6  7c21              LDRB     r1,[r4,#0x10]  ; ca
001aa8  b121              CBZ      r1,|L1.6836|
                  |L1.6826|
;;;1513       /* File Caching switched off or write caching active. */
;;;1514       return (read_sector (sect));
001aaa  4628              MOV      r0,r5
001aac  e8bd4070          POP      {r4-r6,lr}
001ab0  f7ffbffe          B.W      read_sector
                  |L1.6836|
001ab4  49b9              LDR      r1,|L1.7580|
;;;1515     }
;;;1516   
;;;1517     if (ca.nrd > 0) {
001ab6  7c62              LDRB     r2,[r4,#0x11]  ; ca
001ab8  3914              SUBS     r1,r1,#0x14           ;1512
001aba  688b              LDR      r3,[r1,#8]
001abc  b182              CBZ      r2,|L1.6880|
;;;1518       if ((ca.csect <= sect) && sect < (ca.csect + ca.nrd)) {
001abe  6861              LDR      r1,[r4,#4]  ; ca
001ac0  42a9              CMP      r1,r5
001ac2  d80d              BHI      |L1.6880|
001ac4  440a              ADD      r2,r2,r1
001ac6  42aa              CMP      r2,r5
001ac8  d90a              BLS      |L1.6880|
;;;1519         /* Requested sector is already cached. */
;;;1520         memcpy (ca.buf, ca.cbuf + (sect - ca.csect) * 512, 512);
001aca  68e0              LDR      r0,[r4,#0xc]  ; ca
001acc  1a69              SUBS     r1,r5,r1
001ace  eb002141          ADD      r1,r0,r1,LSL #9
001ad2  f44f7200          MOV      r2,#0x200
001ad6  4618              MOV      r0,r3
001ad8  f7fffffe          BL       __aeabi_memcpy
;;;1521         ca.sect = sect;
;;;1522         return (__TRUE);
001adc  6025              STR      r5,[r4,#0]  ; ca
001ade  e015              B        |L1.6924|
                  |L1.6880|
;;;1523       }
;;;1524     }
;;;1525   
;;;1526     if (cnt > _MC_CSIZE) {
001ae0  8801              LDRH     r1,[r0,#0]  ; _MC_CSIZE
001ae2  428e              CMP      r6,r1
001ae4  d900              BLS      |L1.6888|
;;;1527       cnt = _MC_CSIZE;
001ae6  b28e              UXTH     r6,r1
                  |L1.6888|
;;;1528     }
;;;1529   
;;;1530     /* Sector not in cache, read it from the Memory Card. */
;;;1531     if (mmc_read_sect (sect, ca.buf, cnt) == __TRUE) {
001ae8  4632              MOV      r2,r6
001aea  4619              MOV      r1,r3
001aec  4628              MOV      r0,r5
001aee  f7fffffe          BL       mmc_read_sect
001af2  2801              CMP      r0,#1
001af4  d005              BEQ      |L1.6914|
;;;1532       ca.sect  = sect;
;;;1533       /* First sector is used, the rest is cached. */
;;;1534       ca.csect = sect + 1;
;;;1535       ca.nrd   = cnt - 1;
;;;1536       return (__TRUE);
;;;1537     }
;;;1538     ca.sect = INVAL_SECT;
001af6  f04f30ff          MOV      r0,#0xffffffff
;;;1539     ca.nrd  = 0;
001afa  6020              STR      r0,[r4,#0]  ; ca
001afc  2000              MOVS     r0,#0
001afe  7460              STRB     r0,[r4,#0x11]
;;;1540     return (__FALSE);
;;;1541   }
001b00  bd70              POP      {r4-r6,pc}
                  |L1.6914|
001b02  6025              STR      r5,[r4,#0]            ;1534  ; ca
001b04  1c6d              ADDS     r5,r5,#1              ;1534
001b06  1e76              SUBS     r6,r6,#1              ;1535
001b08  6065              STR      r5,[r4,#4]            ;1535  ; ca
001b0a  7466              STRB     r6,[r4,#0x11]         ;1535
                  |L1.6924|
001b0c  2001              MOVS     r0,#1                 ;1536
001b0e  bd70              POP      {r4-r6,pc}
;;;1542   
                          ENDP

                  fat_read PROC
;;;794    
;;;795    U32 fat_read (IOB *fcb, U8 *buf, U32 len) {
001b10  e92d47f0          PUSH     {r4-r10,lr}
;;;796      /* Read data from file at current file position. */
;;;797      U32 sect,pos,nr,rlen;
;;;798    
;;;799      if (mmc.FatType == FS_RAW) {
001b14  f8df9284          LDR      r9,|L1.7580|
001b18  4604              MOV      r4,r0                 ;795
001b1a  468a              MOV      r10,r1                ;795
001b1c  f8990004          LDRB     r0,[r9,#4]  ; mmc
001b20  4616              MOV      r6,r2                 ;795
001b22  2800              CMP      r0,#0
001b24  d00b              BEQ      |L1.6974|
001b26  e9d4100b          LDRD     r1,r0,[r4,#0x2c]
;;;800        /* RAW File System or FAT not initialized. */
;;;801        return (0);
;;;802      }
;;;803      if (fcb->fpos + len > fcb->fsize) {
001b2a  1982              ADDS     r2,r0,r6
001b2c  428a              CMP      r2,r1
001b2e  d901              BLS      |L1.6964|
;;;804        /* Check for End Of File. */
;;;805        len = fcb->fsize - fcb->fpos;
001b30  1a0e              SUBS     r6,r1,r0
;;;806        if (len == 0) {
001b32  d003              BEQ      |L1.6972|
                  |L1.6964|
;;;807          /* End of File. */
;;;808          return (0);
;;;809        }
;;;810      }
;;;811    
;;;812      pos = fcb->fpos & 0x1FF;
001b34  f3c00708          UBFX     r7,r0,#0,#9
;;;813      for (nr = 0; nr < len; nr += rlen) {
001b38  2500              MOVS     r5,#0
001b3a  e039              B        |L1.7088|
                  |L1.6972|
001b3c  2000              MOVS     r0,#0                 ;808
                  |L1.6974|
;;;814        sect = clus_to_sect (fcb->_currDatClus) + fcb->_currDatSect;
;;;815        /* Try to cache current cluster. */
;;;816        EX(read_cache (sect, mmc.SecPerClus - fcb->_currDatSect),0);
;;;817    
;;;818        rlen = len - nr;
;;;819        if ((rlen + pos) > 512) {
;;;820          rlen = 512 - pos;
;;;821        }
;;;822    
;;;823        memcpy (&buf[nr], &ca.buf[pos], rlen);
;;;824        pos = (pos + rlen) & 0x1FF;
;;;825        if (pos == 0) {
;;;826          /* Current sector complete, get next one. */
;;;827          if (++fcb->_currDatSect == mmc.SecPerClus) {
;;;828            /* This cluster is processed, get next one. */
;;;829            fcb->_currDatSect = 0;
;;;830            EX(set_next_clus (&fcb->_currDatClus),0);
;;;831          }
;;;832        }
;;;833      }
;;;834      fcb->fpos += nr;
;;;835      /* Number of characters read. */
;;;836      return (len);
;;;837    }
001b3e  e549              B        |L1.5588|
                  |L1.6976|
001b40  6aa0              LDR      r0,[r4,#0x28]         ;814
001b42  f7fffffe          BL       clus_to_sect
001b46  f8941024          LDRB     r1,[r4,#0x24]         ;814
001b4a  f8992006          LDRB     r2,[r9,#6]            ;816  ; mmc
001b4e  4408              ADD      r0,r0,r1              ;814
001b50  1a51              SUBS     r1,r2,r1              ;816
001b52  f7fffffe          BL       read_cache
001b56  2800              CMP      r0,#0                 ;816
001b58  d0f1              BEQ      |L1.6974|
001b5a  eba60805          SUB      r8,r6,r5              ;818
001b5e  eb080007          ADD      r0,r8,r7              ;819
001b62  f5b07f00          CMP      r0,#0x200             ;819
001b66  d901              BLS      |L1.7020|
001b68  f5c77800          RSB      r8,r7,#0x200          ;820
                  |L1.7020|
001b6c  488b              LDR      r0,|L1.7580|
001b6e  4642              MOV      r2,r8                 ;823
001b70  3814              SUBS     r0,r0,#0x14           ;823
001b72  6880              LDR      r0,[r0,#8]            ;823  ; ca
001b74  19c1              ADDS     r1,r0,r7              ;823
001b76  eb0a0005          ADD      r0,r10,r5             ;823
001b7a  f7fffffe          BL       __aeabi_memcpy
001b7e  eb070008          ADD      r0,r7,r8              ;824
001b82  05c7              LSLS     r7,r0,#23             ;824
001b84  0dff              LSRS     r7,r7,#23             ;824
001b86  d112              BNE      |L1.7086|
001b88  f8940024          LDRB     r0,[r4,#0x24]         ;827
001b8c  1c40              ADDS     r0,r0,#1              ;827
001b8e  b2c1              UXTB     r1,r0                 ;827
001b90  f8841024          STRB     r1,[r4,#0x24]         ;827
001b94  f8990006          LDRB     r0,[r9,#6]            ;827  ; mmc
001b98  4281              CMP      r1,r0                 ;827
001b9a  d108              BNE      |L1.7086|
001b9c  2000              MOVS     r0,#0                 ;829
001b9e  f8840024          STRB     r0,[r4,#0x24]         ;829
001ba2  f1040028          ADD      r0,r4,#0x28           ;830
001ba6  f7fffffe          BL       set_next_clus
001baa  2800              CMP      r0,#0                 ;830
001bac  d0c7              BEQ      |L1.6974|
                  |L1.7086|
001bae  4445              ADD      r5,r5,r8              ;813
                  |L1.7088|
001bb0  42b5              CMP      r5,r6                 ;813
001bb2  d3c5              BCC      |L1.6976|
001bb4  6b20              LDR      r0,[r4,#0x30]         ;834
001bb6  4428              ADD      r0,r0,r5              ;834
001bb8  6320              STR      r0,[r4,#0x30]         ;836
001bba  4630              MOV      r0,r6                 ;836
001bbc  e50a              B        |L1.5588|
;;;838    
                          ENDP

                  fat_write PROC
;;;841    
;;;842    BOOL fat_write (IOB *fcb, const U8 *buf, U32 len) {
001bbe  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
;;;843      /* Write data to file at current file position. */
;;;844      U32 sect,pos,nw,wlen,clus;
;;;845    
;;;846      if (mmc.FatType == FS_RAW) {
001bc2  f8df91d8          LDR      r9,|L1.7580|
001bc6  4604              MOV      r4,r0                 ;842
001bc8  b082              SUB      sp,sp,#8              ;842
001bca  f8990004          LDRB     r0,[r9,#4]  ; mmc
001bce  4690              MOV      r8,r2                 ;842
001bd0  2800              CMP      r0,#0
001bd2  d059              BEQ      |L1.7304|
;;;847        /* RAW File System or FAT not initialized. */
;;;848        return (__FALSE);
;;;849      }
;;;850      if (fcb->_firstClus == 0) {
;;;851        /* Data cluster not allocated yet, allocate one. */
;;;852        EX(get_free_clus (&fcb->_currDatClus),__FALSE);
001bd4  f1040028          ADD      r0,r4,#0x28
001bd8  69e1              LDR      r1,[r4,#0x1c]         ;850
001bda  f04f0a00          MOV      r10,#0                ;846
001bde  4683              MOV      r11,r0
001be0  b939              CBNZ     r1,|L1.7154|
001be2  f7fffffe          BL       get_free_clus
001be6  2800              CMP      r0,#0
001be8  d04e              BEQ      |L1.7304|
;;;853        fcb->_firstClus   = fcb->_currDatClus;
001bea  6aa1              LDR      r1,[r4,#0x28]
;;;854        fcb->_currDatSect = 0;
001bec  61e1              STR      r1,[r4,#0x1c]
001bee  f884a024          STRB     r10,[r4,#0x24]
                  |L1.7154|
;;;855      }
;;;856    
;;;857      pos = fcb->fpos & 0x1FF;
001bf2  6b20              LDR      r0,[r4,#0x30]
;;;858      for (nw = 0; nw < len; nw += wlen) {
001bf4  2600              MOVS     r6,#0
001bf6  f3c00508          UBFX     r5,r0,#0,#9           ;857
001bfa  e03f              B        |L1.7292|
                  |L1.7164|
;;;859        wlen = len - nw;
001bfc  eba80706          SUB      r7,r8,r6
;;;860        if ((wlen + pos) > 512) {
001c00  1978              ADDS     r0,r7,r5
001c02  f5b07f00          CMP      r0,#0x200
001c06  d901              BLS      |L1.7180|
;;;861          wlen = 512 - pos;
001c08  f5c57700          RSB      r7,r5,#0x200
                  |L1.7180|
;;;862        }
;;;863        sect = clus_to_sect (fcb->_currDatClus) + fcb->_currDatSect;
001c0c  6aa0              LDR      r0,[r4,#0x28]
001c0e  f7fffffe          BL       clus_to_sect
001c12  f8941024          LDRB     r1,[r4,#0x24]
001c16  4408              ADD      r0,r0,r1
;;;864        if (pos != 0) {
001c18  9000              STR      r0,[sp,#0]
001c1a  b11d              CBZ      r5,|L1.7204|
;;;865          /* File position not 512-byte aligned. */
;;;866          EX(read_sector (sect),__FALSE);
001c1c  f7fffffe          BL       read_sector
001c20  2800              CMP      r0,#0
001c22  d031              BEQ      |L1.7304|
                  |L1.7204|
;;;867        }
;;;868        memcpy (&ca.buf[pos], &buf[nw], wlen);
001c24  9803              LDR      r0,[sp,#0xc]
001c26  463a              MOV      r2,r7
001c28  1981              ADDS     r1,r0,r6
001c2a  485c              LDR      r0,|L1.7580|
001c2c  3814              SUBS     r0,r0,#0x14
001c2e  6880              LDR      r0,[r0,#8]  ; ca
001c30  4428              ADD      r0,r0,r5
001c32  f7fffffe          BL       __aeabi_memcpy
;;;869        EX(write_cache (sect),__FALSE);
001c36  9800              LDR      r0,[sp,#0]
001c38  f7fffffe          BL       write_cache
001c3c  2800              CMP      r0,#0
001c3e  d023              BEQ      |L1.7304|
;;;870    
;;;871        pos = (pos + wlen) & 0x1FF;
001c40  19e8              ADDS     r0,r5,r7
001c42  05c5              LSLS     r5,r0,#23
001c44  0ded              LSRS     r5,r5,#23
;;;872    
;;;873        if (pos == 0) {
001c46  d118              BNE      |L1.7290|
;;;874          /* Current sector is full, get next one. */
;;;875          if (++fcb->_currDatSect == mmc.SecPerClus) {
001c48  f8940024          LDRB     r0,[r4,#0x24]
001c4c  1c40              ADDS     r0,r0,#1
001c4e  b2c1              UXTB     r1,r0
001c50  f8841024          STRB     r1,[r4,#0x24]
001c54  f8990006          LDRB     r0,[r9,#6]  ; mmc
001c58  4281              CMP      r1,r0
001c5a  d10e              BNE      |L1.7290|
;;;876            /* This cluster is processed, get next one. */
;;;877            fcb->_currDatSect = 0;
001c5c  f884a024          STRB     r10,[r4,#0x24]
;;;878            clus = fcb->_currDatClus;
001c60  6aa0              LDR      r0,[r4,#0x28]
001c62  9000              STR      r0,[sp,#0]
001c64  4658              MOV      r0,r11
;;;879            /* Allocate a free cluster. */
;;;880            EX(get_free_clus (&fcb->_currDatClus),__FALSE);
001c66  f7fffffe          BL       get_free_clus
001c6a  2800              CMP      r0,#0
001c6c  d00c              BEQ      |L1.7304|
;;;881            /* Update also a FAT cluster chain. */
;;;882            EX(write_fat_link (clus, fcb->_currDatClus),__FALSE);
001c6e  6aa1              LDR      r1,[r4,#0x28]
001c70  9800              LDR      r0,[sp,#0]
001c72  f7fffffe          BL       write_fat_link
001c76  2800              CMP      r0,#0
001c78  d006              BEQ      |L1.7304|
                  |L1.7290|
001c7a  443e              ADD      r6,r6,r7              ;858
                  |L1.7292|
001c7c  4546              CMP      r6,r8                 ;858
001c7e  d3bd              BCC      |L1.7164|
;;;883          }
;;;884        }
;;;885      }
;;;886      fcb->fpos += nw;
001c80  6b20              LDR      r0,[r4,#0x30]
001c82  4430              ADD      r0,r0,r6
;;;887      return (__TRUE);
001c84  6320              STR      r0,[r4,#0x30]
001c86  2001              MOVS     r0,#1
                  |L1.7304|
;;;888    }
001c88  b005              ADD      sp,sp,#0x14
001c8a  e8bd8ff0          POP      {r4-r11,pc}
;;;889    
                          ENDP

                  read_last_entry PROC
;;;2718   
;;;2719   static BOOL read_last_entry (IOB *fcb, FILEREC *filerec) {
001c8e  b570              PUSH     {r4-r6,lr}
001c90  460d              MOV      r5,r1
;;;2720     /* Read last entry that fcb is pointing to.*/
;;;2721     FILEREC     *frec;
;;;2722     U32          clus          = fcb->_lastEntClus;
;;;2723     U32          idx           = (U32)fcb->fileID;
;;;2724     U32          sect;
;;;2725   
;;;2726     /* Calculate sector index. */
;;;2727     sect = get_dir_sect (clus);
001c92  6a01              LDR      r1,[r0,#0x20]
001c94  8804              LDRH     r4,[r0,#0]            ;2723
001c96  4608              MOV      r0,r1
001c98  f7fffffe          BL       get_dir_sect
;;;2728   
;;;2729     EX(read_sector (sect + (idx >> 4)),__FALSE);
001c9c  eb001014          ADD      r0,r0,r4,LSR #4
001ca0  f7fffffe          BL       read_sector
001ca4  2800              CMP      r0,#0
001ca6  d00b              BEQ      |L1.7360|
;;;2730     frec = (FILEREC *)ca.buf + (idx & 0x0F);
001ca8  483c              LDR      r0,|L1.7580|
001caa  f004010f          AND      r1,r4,#0xf
001cae  3814              SUBS     r0,r0,#0x14
;;;2731   
;;;2732     /* Copy data from last file record. */
;;;2733     memcpy (filerec, frec, 32);
001cb0  2220              MOVS     r2,#0x20
001cb2  6880              LDR      r0,[r0,#8]            ;2730  ; ca
001cb4  eb001141          ADD      r1,r0,r1,LSL #5       ;2730
001cb8  4628              MOV      r0,r5
001cba  f7fffffe          BL       __aeabi_memcpy4
;;;2734   
;;;2735     /* Last file record read successfully. */
;;;2736     return (__TRUE);
001cbe  2001              MOVS     r0,#1
                  |L1.7360|
;;;2737   }
001cc0  bd70              POP      {r4-r6,pc}
;;;2738   
                          ENDP

                  fat_close_write PROC
;;;892    
;;;893    BOOL fat_close_write (IOB *fcb) {
001cc2  b530              PUSH     {r4,r5,lr}
001cc4  4604              MOV      r4,r0
;;;894      /* Close an opened file, update FAT and Directory record. */
;;;895      FILEREC last_frec;
;;;896    
;;;897      if (mmc.FatType == FS_RAW) {
001cc6  4835              LDR      r0,|L1.7580|
001cc8  b089              SUB      sp,sp,#0x24           ;893
001cca  7900              LDRB     r0,[r0,#4]  ; mmc
001ccc  2800              CMP      r0,#0
001cce  d03e              BEQ      |L1.7502|
001cd0  e9d4010b          LDRD     r0,r1,[r4,#0x2c]
;;;898        /* RAW File System or FAT not initialized. */
;;;899        return (__FALSE);
;;;900      }
;;;901    
;;;902      if (fcb->fpos > fcb->fsize) {
001cd4  4281              CMP      r1,r0
001cd6  d92f              BLS      |L1.7480|
;;;903        /* Write an EOC marker to FAT table Cluster chain. */
;;;904        EX(write_fat_link (fcb->_currDatClus, get_EOC()),__FALSE);
001cd8  f7fffffe          BL       get_EOC
001cdc  4601              MOV      r1,r0
001cde  6aa0              LDR      r0,[r4,#0x28]
001ce0  f7fffffe          BL       write_fat_link
001ce4  2800              CMP      r0,#0
001ce6  d032              BEQ      |L1.7502|
;;;905    
;;;906        /* Update File Length info from Directory Entry record. */
;;;907        /* Read last entry to keep some informations from it. */
;;;908        EX(read_last_entry  (fcb, &last_frec),__FALSE);
001ce8  4669              MOV      r1,sp
001cea  4620              MOV      r0,r4
001cec  f7fffffe          BL       read_last_entry
001cf0  2800              CMP      r0,#0
001cf2  d02c              BEQ      |L1.7502|
;;;909        last_frec.FirstClusHI = (U16)(fcb->_firstClus >> 16);
001cf4  69e0              LDR      r0,[r4,#0x1c]
001cf6  0c00              LSRS     r0,r0,#16
001cf8  f8ad0014          STRH     r0,[sp,#0x14]
;;;910        last_frec.FirstClusLO = (U16)(fcb->_firstClus      );
001cfc  69e0              LDR      r0,[r4,#0x1c]
001cfe  f8ad001a          STRH     r0,[sp,#0x1a]
;;;911        last_frec.FileSize    = fcb->fpos;
001d02  6b20              LDR      r0,[r4,#0x30]
001d04  9007              STR      r0,[sp,#0x1c]
001d06  6a20              LDR      r0,[r4,#0x20]
001d08  8824              LDRH     r4,[r4,#0]
001d0a  f7fffffe          BL       get_dir_sect
001d0e  eb001014          ADD      r0,r0,r4,LSR #4
001d12  4605              MOV      r5,r0
001d14  f7fffffe          BL       read_sector
001d18  b1d8              CBZ      r0,|L1.7506|
001d1a  4820              LDR      r0,|L1.7580|
001d1c  f004010f          AND      r1,r4,#0xf
001d20  3814              SUBS     r0,r0,#0x14
001d22  2220              MOVS     r2,#0x20
001d24  6880              LDR      r0,[r0,#8]  ; ca
001d26  eb001041          ADD      r0,r0,r1,LSL #5
001d2a  4669              MOV      r1,sp
001d2c  f7fffffe          BL       __aeabi_memcpy4
001d30  4628              MOV      r0,r5
001d32  f7fffffe          BL       write_sector
001d36  b160              CBZ      r0,|L1.7506|
                  |L1.7480|
;;;912        /* Write updated last entry. */
;;;913        EX(write_last_entry (fcb, &last_frec),__FALSE);
;;;914      }
;;;915      /* Write also cached Data and FAT table. */
;;;916      EX(write_cache (0),__FALSE);
001d38  2000              MOVS     r0,#0
001d3a  f7fffffe          BL       write_cache
001d3e  2800              CMP      r0,#0
001d40  d005              BEQ      |L1.7502|
;;;917      EX(cache_fat (0),__FALSE);
001d42  2000              MOVS     r0,#0
001d44  f7fffffe          BL       cache_fat
001d48  2800              CMP      r0,#0
001d4a  d000              BEQ      |L1.7502|
;;;918      return (__TRUE);
001d4c  2001              MOVS     r0,#1
                  |L1.7502|
;;;919    }
001d4e  b009              ADD      sp,sp,#0x24
001d50  bd30              POP      {r4,r5,pc}
                  |L1.7506|
001d52  2000              MOVS     r0,#0                 ;913
001d54  e7fb              B        |L1.7502|
;;;920    
                          ENDP

                  fat_set_fpos PROC
;;;923    
;;;924    BOOL fat_set_fpos (IOB *fcb, U32 pos) {
001d56  e92d41f0          PUSH     {r4-r8,lr}
001d5a  4604              MOV      r4,r0
;;;925      /* Set File Position pointer. */
;;;926      U32 i;
;;;927    
;;;928      if (pos > fcb->fsize) {
001d5c  6ac0              LDR      r0,[r0,#0x2c]
001d5e  460d              MOV      r5,r1                 ;924
001d60  4288              CMP      r0,r1
001d62  d200              BCS      |L1.7526|
;;;929        pos = fcb->fsize;
001d64  4605              MOV      r5,r0
                  |L1.7526|
;;;930      }
;;;931      fcb->_currDatSect = (pos / 512) % mmc.SecPerClus;
001d66  480d              LDR      r0,|L1.7580|
001d68  0a69              LSRS     r1,r5,#9
001d6a  7982              LDRB     r2,[r0,#6]  ; mmc
001d6c  fbb1f3f2          UDIV     r3,r1,r2
001d70  fb021113          MLS      r1,r2,r3,r1
001d74  f8841024          STRB     r1,[r4,#0x24]
;;;932      fcb->_currDatClus = fcb->_firstClus;
001d78  69e1              LDR      r1,[r4,#0x1c]
;;;933      for (i = pos / mmc.ClusSize; i; i--) {
001d7a  62a1              STR      r1,[r4,#0x28]
001d7c  6a00              LDR      r0,[r0,#0x20]  ; mmc
001d7e  fbb5f6f0          UDIV     r6,r5,r0
001d82  b146              CBZ      r6,|L1.7574|
;;;934        /* Scan the cluster chain. */
;;;935        EX(set_next_clus (&fcb->_currDatClus),__FALSE);
001d84  f1040728          ADD      r7,r4,#0x28
                  |L1.7560|
001d88  4638              MOV      r0,r7
001d8a  f7fffffe          BL       set_next_clus
001d8e  2800              CMP      r0,#0
001d90  d00a              BEQ      |L1.7592|
001d92  1e76              SUBS     r6,r6,#1              ;933
001d94  d1f8              BNE      |L1.7560|
                  |L1.7574|
;;;936      }
;;;937      fcb->fpos = pos;
;;;938    
;;;939      return (__TRUE);
001d96  e005              B        |L1.7588|
                  |L1.7576|
                          DCD      ||.data||
                  |L1.7580|
                          DCD      ||.bss||+0x20
                  |L1.7584|
                          DCD      _MC_CSIZE
                  |L1.7588|
001da4  2001              MOVS     r0,#1
001da6  6325              STR      r5,[r4,#0x30]
                  |L1.7592|
;;;940    }
001da8  e8bd81f0          POP      {r4-r8,pc}
;;;941    
                          ENDP

                  fat_rename PROC
;;;944    
;;;945    BOOL fat_rename (const char *old, const char *newn, IOB *fcb) {
001dac  b570              PUSH     {r4-r6,lr}
001dae  460c              MOV      r4,r1
;;;946      /* Rename a file or directory to new name. */
;;;947      U8 type;
;;;948    
;;;949      if (mmc.FatType == FS_RAW) {
001db0  49ef              LDR      r1,|L1.8560|
001db2  4615              MOV      r5,r2                 ;945
001db4  7909              LDRB     r1,[r1,#4]  ; mmc
001db6  b3c9              CBZ      r1,|L1.7724|
;;;950        /* RAW File System or FAT not initialized. */
;;;951        return (__FALSE);
;;;952      }
;;;953    
;;;954      /* Remove starting '\' if it exists. */
;;;955      if (*old == '\\') old++;
001db8  7801              LDRB     r1,[r0,#0]
001dba  295c              CMP      r1,#0x5c
001dbc  d100              BNE      |L1.7616|
001dbe  1c40              ADDS     r0,r0,#1
                  |L1.7616|
;;;956    
;;;957      /* Remove starting '\' if it exists. */
;;;958      if (*newn == '\\') newn++;
001dc0  7821              LDRB     r1,[r4,#0]
001dc2  295c              CMP      r1,#0x5c
001dc4  d100              BNE      |L1.7624|
001dc6  1c64              ADDS     r4,r4,#1
                  |L1.7624|
;;;959    
;;;960      /* Exit function if "old" on "new" is not given. */
;;;961      if (*old == 0 || *newn == 0) {
001dc8  7801              LDRB     r1,[r0,#0]
001dca  b379              CBZ      r1,|L1.7724|
001dcc  7821              LDRB     r1,[r4,#0]
001dce  b369              CBZ      r1,|L1.7724|
;;;962        return(__FALSE);
;;;963      }
;;;964    
;;;965      /* Search for directory. */
;;;966      fcb->_firstClus = 0;
001dd0  2100              MOVS     r1,#0
;;;967      if (fat_find_dir (old, fcb, 0) == __FALSE) {
001dd2  460a              MOV      r2,r1
001dd4  61e9              STR      r1,[r5,#0x1c]
001dd6  4629              MOV      r1,r5
001dd8  f7fffffe          BL       fat_find_dir
001ddc  2800              CMP      r0,#0
001dde  d024              BEQ      |L1.7722|
;;;968        /* Directory does not exist. */
;;;969        return (__FALSE);
;;;970      }
;;;971    
;;;972      type = ENT_DIR;
;;;973      if (name_buf[0]) {
001de0  48e3              LDR      r0,|L1.8560|
001de2  2601              MOVS     r6,#1                 ;972
001de4  3030              ADDS     r0,r0,#0x30
001de6  7800              LDRB     r0,[r0,#0]  ; name_buf
001de8  b180              CBZ      r0,|L1.7692|
;;;974        if (check_name (newn, fcb, ENT_FILE) == __TRUE) {
001dea  2200              MOVS     r2,#0
001dec  4629              MOV      r1,r5
001dee  4620              MOV      r0,r4
001df0  f7fffffe          BL       check_name
001df4  2801              CMP      r0,#1
001df6  d01a              BEQ      |L1.7726|
;;;975          /* New file already exist. */
;;;976          return (__FALSE);
;;;977        }
;;;978    
;;;979        type = ENT_FILE;
;;;980        /* Search for file if file name exists. */
;;;981        if (find_name (name_buf, fcb, ENT_FILE) == __FALSE) {
001df8  48dd              LDR      r0,|L1.8560|
001dfa  2600              MOVS     r6,#0                 ;979
001dfc  4632              MOV      r2,r6
001dfe  4629              MOV      r1,r5
001e00  3030              ADDS     r0,r0,#0x30
001e02  f7fffffe          BL       find_name
001e06  2800              CMP      r0,#0
001e08  d00f              BEQ      |L1.7722|
001e0a  e006              B        |L1.7706|
                  |L1.7692|
;;;982          /* File does not exist. */
;;;983          return (__FALSE);
;;;984        }
;;;985      }
;;;986      else {
;;;987        if (check_name (newn, fcb, ENT_DIR) == __TRUE) {
001e0c  2201              MOVS     r2,#1
001e0e  4629              MOV      r1,r5
001e10  4620              MOV      r0,r4
001e12  f7fffffe          BL       check_name
001e16  2801              CMP      r0,#1
001e18  d009              BEQ      |L1.7726|
                  |L1.7706|
;;;988          /* New directory already exist. */
;;;989          return (__FALSE);
;;;990        }
;;;991      }
;;;992    
;;;993      if (rename_entries (newn, fcb, type) == __FALSE) {
001e1a  4632              MOV      r2,r6
001e1c  4629              MOV      r1,r5
001e1e  4620              MOV      r0,r4
001e20  f7fffffe          BL       rename_entries
001e24  2800              CMP      r0,#0
001e26  d000              BEQ      |L1.7722|
;;;994        /* If rename was unsuccessfully. */
;;;995        return (__FALSE);
;;;996      }
;;;997    
;;;998      /* File or directory renamed. */
;;;999      return (__TRUE);
001e28  2001              MOVS     r0,#1
                  |L1.7722|
;;;1000   }
001e2a  bd70              POP      {r4-r6,pc}
                  |L1.7724|
001e2c  e7ff              B        |L1.7726|
                  |L1.7726|
001e2e  2000              MOVS     r0,#0                 ;989
001e30  e7fb              B        |L1.7722|
;;;1001   
                          ENDP

                  is_fat_valid PROC
;;;1725   
;;;1726   static BOOL is_fat_valid (void) {
001e32  49cf              LDR      r1,|L1.8560|
;;;1727     /* Check if Volume Info is sane. */
;;;1728   
;;;1729     /* We only support 512 byte sectors. */
;;;1730     if (mmc.BytesPerSec != 512) {
001e34  8ac8              LDRH     r0,[r1,#0x16]  ; mmc
001e36  f5b07f00          CMP      r0,#0x200
001e3a  d11d              BNE      |L1.7800|
;;;1731       return (__FALSE);
;;;1732     }
;;;1733     /* Check for Valid Sectors per Cluster values. */
;;;1734     switch (mmc.SecPerClus) {
001e3c  7988              LDRB     r0,[r1,#6]  ; mmc
001e3e  2808              CMP      r0,#8
001e40  d00d              BEQ      |L1.7774|
001e42  dc06              BGT      |L1.7762|
001e44  2801              CMP      r0,#1
001e46  d00a              BEQ      |L1.7774|
001e48  2802              CMP      r0,#2
001e4a  d008              BEQ      |L1.7774|
001e4c  2804              CMP      r0,#4
001e4e  d113              BNE      |L1.7800|
001e50  e005              B        |L1.7774|
                  |L1.7762|
001e52  2810              CMP      r0,#0x10
001e54  d003              BEQ      |L1.7774|
001e56  2820              CMP      r0,#0x20
001e58  d001              BEQ      |L1.7774|
001e5a  2840              CMP      r0,#0x40
001e5c  d10c              BNE      |L1.7800|
                  |L1.7774|
;;;1735       case 1:
;;;1736       case 2:
;;;1737       case 4:
;;;1738       case 8:
;;;1739       case 16:
;;;1740       case 32:
;;;1741       case 64: break;
;;;1742       default: return (__FALSE);
;;;1743     }
;;;1744     /* There should be at least 1 reserved sector. */
;;;1745     if (mmc.RsvdSecCnt == 0 || mmc.RsvdSecCnt > 64) {
001e5e  8948              LDRH     r0,[r1,#0xa]  ; mmc
001e60  b150              CBZ      r0,|L1.7800|
001e62  2840              CMP      r0,#0x40
001e64  d808              BHI      |L1.7800|
;;;1746       return (__FALSE);
;;;1747     }
;;;1748     /* Only 1 or 2 FAT tables supported. */
;;;1749     switch (mmc.NumOfFat) {
001e66  7948              LDRB     r0,[r1,#5]  ; mmc
001e68  2801              CMP      r0,#1
001e6a  d001              BEQ      |L1.7792|
001e6c  2802              CMP      r0,#2
001e6e  d103              BNE      |L1.7800|
                  |L1.7792|
;;;1750       case 1:
;;;1751       case 2:  break;
;;;1752       default: return (__FALSE);
;;;1753     }
;;;1754     if (mmc.FatSize > mmc.DskSize) {
001e70  8908              LDRH     r0,[r1,#8]  ; mmc
001e72  68c9              LDR      r1,[r1,#0xc]  ; mmc
001e74  4288              CMP      r0,r1
001e76  d901              BLS      |L1.7804|
                  |L1.7800|
;;;1755       return (__FALSE);
001e78  2000              MOVS     r0,#0
;;;1756     }
;;;1757     return (__TRUE);
;;;1758   }
001e7a  4770              BX       lr
                  |L1.7804|
001e7c  2001              MOVS     r0,#1                 ;1757
001e7e  4770              BX       lr
;;;1759   
                          ENDP

                  get_u32 PROC
;;;3257   
;;;3258   static U32 get_u32 (U8 *nr) {
001e80  7801              LDRB     r1,[r0,#0]
;;;3259     /* Read an unaligned U32 variable in correct Endian format. */
;;;3260   
;;;3261   #ifdef __BIG_ENDIAN
;;;3262     return ((nr[0] << 24) | (nr[1] << 16) | (nr[2] << 8) | nr[3]);
;;;3263   #else
;;;3264     return ((nr[3] << 24) | (nr[2] << 16) | (nr[1] << 8) | nr[0]);
001e82  f8d00001          LDR      r0,[r0,#1]
001e86  ea412000          ORR      r0,r1,r0,LSL #8
;;;3265   #endif
;;;3266   }
001e8a  4770              BX       lr
;;;3267   
                          ENDP

                  get_mbrec PROC
;;;1656   
;;;1657   static BOOL get_mbrec (void) {
001e8c  b510              PUSH     {r4,lr}
;;;1658     /* Read Master Volume Boot Record info. */
;;;1659   
;;;1660     /* Read MBR and set FAT offset address. */
;;;1661     EX(read_sector (0),__FALSE);
001e8e  2000              MOVS     r0,#0
001e90  f7fffffe          BL       read_sector
001e94  2800              CMP      r0,#0
001e96  d009              BEQ      |L1.7852|
;;;1662   
;;;1663     /* Check Executable Marker. */
;;;1664     if (get_u16 (&ca.buf[510]) != 0xAA55) {
001e98  48b5              LDR      r0,|L1.8560|
001e9a  3814              SUBS     r0,r0,#0x14
001e9c  6880              LDR      r0,[r0,#8]  ; ca
001e9e  f8b011fe          LDRH     r1,[r0,#0x1fe]
001ea2  f5a1422a          SUB      r2,r1,#0xaa00
001ea6  3a55              SUBS     r2,r2,#0x55
001ea8  d001              BEQ      |L1.7854|
;;;1665       /* Invalid Master Boot Record. */
;;;1666       return (__FALSE);
001eaa  2000              MOVS     r0,#0
                  |L1.7852|
;;;1667     }
;;;1668   
;;;1669     if ((ca.buf[0] == 0xE9) || (ca.buf[0] == 0xEB && ca.buf[2] == 0x90)) {
;;;1670       /* Partition Table does not exist, this is a BPB. */
;;;1671       mmc.BootRecSec = 0;
;;;1672     }
;;;1673     else {
;;;1674       /* Flash Cards have only one Partition. */
;;;1675       mmc.BootRecSec = get_u32 (&ca.buf[454]);
;;;1676     }
;;;1677     return (__TRUE);
;;;1678   }
001eac  bd10              POP      {r4,pc}
                  |L1.7854|
001eae  7801              LDRB     r1,[r0,#0]            ;1669
001eb0  4caf              LDR      r4,|L1.8560|
001eb2  29e9              CMP      r1,#0xe9              ;1669
001eb4  d00b              BEQ      |L1.7886|
001eb6  29eb              CMP      r1,#0xeb              ;1669
001eb8  d102              BNE      |L1.7872|
001eba  7881              LDRB     r1,[r0,#2]            ;1669
001ebc  2990              CMP      r1,#0x90              ;1669
001ebe  d006              BEQ      |L1.7886|
                  |L1.7872|
001ec0  f50070e3          ADD      r0,r0,#0x1c6          ;1675
001ec4  f7fffffe          BL       get_u32
                  |L1.7880|
001ec8  6020              STR      r0,[r4,#0]            ;1677  ; mmc
001eca  2001              MOVS     r0,#1                 ;1677
001ecc  bd10              POP      {r4,pc}
                  |L1.7886|
001ece  2000              MOVS     r0,#0                 ;1671
001ed0  e7fa              B        |L1.7880|
;;;1679   
                          ENDP

                  write_sector PROC
;;;1495   
;;;1496   static BOOL write_sector (U32 sect) {
001ed2  b570              PUSH     {r4-r6,lr}
;;;1497     /* Write a 512 byte sector to Flash Card. */
;;;1498   
;;;1499     if (mmc_write_sect (sect, ca.buf, 1) == __TRUE) {
001ed4  4ca6              LDR      r4,|L1.8560|
001ed6  4605              MOV      r5,r0                 ;1496
001ed8  3c14              SUBS     r4,r4,#0x14
001eda  2201              MOVS     r2,#1
001edc  68a1              LDR      r1,[r4,#8]  ; ca
001ede  f7fffffe          BL       mmc_write_sect
001ee2  2801              CMP      r0,#1
001ee4  d001              BEQ      |L1.7914|
;;;1500       ca.sect = sect;
;;;1501       return (__TRUE);
;;;1502     }
;;;1503     return (__FALSE);
001ee6  2000              MOVS     r0,#0
;;;1504   }
001ee8  e79f              B        |L1.7722|
                  |L1.7914|
001eea  2001              MOVS     r0,#1                 ;1501
001eec  6025              STR      r5,[r4,#0]            ;1501  ; ca
001eee  e79c              B        |L1.7722|
;;;1505   
                          ENDP

                  set_u16 PROC
;;;3270   
;;;3271   static void set_u16 (U8 *nr, U16 val) {
001ef0  0a0a              LSRS     r2,r1,#8
;;;3272     /* Write an unaligned U16 variable in correct Endian format. */
;;;3273   
;;;3274   #ifdef __BIG_ENDIAN
;;;3275     nr[0] = val >> 8;
;;;3276     nr[1] = val;
;;;3277   #else
;;;3278     nr[1] = val >> 8;
001ef2  7042              STRB     r2,[r0,#1]
;;;3279     nr[0] = val;
001ef4  7001              STRB     r1,[r0,#0]
;;;3280   #endif
;;;3281   }
001ef6  4770              BX       lr
;;;3282   
                          ENDP

                  write_label PROC
;;;1004   
;;;1005   static BOOL write_label (const char *label) {
001ef8  b570              PUSH     {r4-r6,lr}
;;;1006     /* Write a drive label to Root Directory. */
;;;1007     FILEREC *frec;
;;;1008     U32 i;
;;;1009     U8 ch;
;;;1010   
;;;1011     EX(read_sector (mmc.BootRecSec + mmc.RootDirAddr),__FALSE);
001efa  4d9d              LDR      r5,|L1.8560|
001efc  4606              MOV      r6,r0                 ;1005
001efe  8ba9              LDRH     r1,[r5,#0x1c]  ; mmc
001f00  6828              LDR      r0,[r5,#0]  ; mmc
001f02  4408              ADD      r0,r0,r1
001f04  f7fffffe          BL       read_sector
001f08  2800              CMP      r0,#0
001f0a  d08e              BEQ      |L1.7722|
;;;1012     frec = (FILEREC *)&ca.buf[0];
001f0c  f1a50014          SUB      r0,r5,#0x14
;;;1013     memset (frec, 0, 32);
001f10  2120              MOVS     r1,#0x20
001f12  6884              LDR      r4,[r0,#8]  ; ca
001f14  4620              MOV      r0,r4
001f16  f7fffffe          BL       __aeabi_memclr4
;;;1014     for (i = 0; i < 11; i++) {
001f1a  2100              MOVS     r1,#0
                  |L1.7964|
;;;1015       ch = val_char_lab (label[i]);
001f1c  5c70              LDRB     r0,[r6,r1]
001f1e  f1a00230          SUB      r2,r0,#0x30
001f22  2a09              CMP      r2,#9
001f24  d90b              BLS      |L1.7998|
001f26  3a11              SUBS     r2,r2,#0x11
001f28  2a19              CMP      r2,#0x19
001f2a  d908              BLS      |L1.7998|
001f2c  285f              CMP      r0,#0x5f
001f2e  d007              BEQ      |L1.8000|
001f30  2820              CMP      r0,#0x20
001f32  d005              BEQ      |L1.8000|
001f34  3a20              SUBS     r2,r2,#0x20
001f36  2a19              CMP      r2,#0x19
001f38  d80a              BHI      |L1.8016|
001f3a  f0200020          BIC      r0,r0,#0x20
                  |L1.7998|
;;;1016       if (ch == 0) break;
001f3e  b138              CBZ      r0,|L1.8016|
                  |L1.8000|
;;;1017       frec->FileName[i] = ch;
001f40  5460              STRB     r0,[r4,r1]
001f42  1c49              ADDS     r1,r1,#1              ;1014
001f44  290b              CMP      r1,#0xb               ;1014
001f46  d3e9              BCC      |L1.7964|
001f48  e005              B        |L1.8022|
                  |L1.8010|
;;;1018     }
;;;1019     for (  ; i < 11; i++) {
;;;1020       frec->FileName[i] = ' ';
001f4a  5460              STRB     r0,[r4,r1]
001f4c  1c49              ADDS     r1,r1,#1              ;1019
001f4e  e000              B        |L1.8018|
                  |L1.8016|
001f50  2020              MOVS     r0,#0x20              ;1013
                  |L1.8018|
001f52  290b              CMP      r1,#0xb               ;1019
001f54  d3f9              BCC      |L1.8010|
                  |L1.8022|
;;;1021     }
;;;1022     frec->Attr      = ATTR_VOLUME_ID;
001f56  2008              MOVS     r0,#8
001f58  72e0              STRB     r0,[r4,#0xb]
;;;1023     set_u16 ((U8 *)&frec->WriteDate, get_date ());
001f5a  f7fffffe          BL       get_date
001f5e  4601              MOV      r1,r0
001f60  f1040018          ADD      r0,r4,#0x18
001f64  f7fffffe          BL       set_u16
;;;1024     set_u16 ((U8 *)&frec->WriteTime, get_time ());
001f68  f7fffffe          BL       get_time
001f6c  4601              MOV      r1,r0
001f6e  f1040016          ADD      r0,r4,#0x16
001f72  f7fffffe          BL       set_u16
;;;1025     EX(write_sector (mmc.BootRecSec + mmc.RootDirAddr),__FALSE);
001f76  8ba9              LDRH     r1,[r5,#0x1c]  ; mmc
001f78  6828              LDR      r0,[r5,#0]  ; mmc
001f7a  4408              ADD      r0,r0,r1
001f7c  f7fffffe          BL       write_sector
001f80  2800              CMP      r0,#0
001f82  d000              BEQ      |L1.8070|
;;;1026     return (__TRUE);
001f84  2001              MOVS     r0,#1
                  |L1.8070|
;;;1027   }
001f86  e750              B        |L1.7722|
;;;1028   
                          ENDP

                  set_u32 PROC
;;;3285   
;;;3286   static void set_u32 (U8 *nr, U32 val) {
001f88  0e0a              LSRS     r2,r1,#24
;;;3287     /* Write an unaligned U32 variable in correct Endian format. */
;;;3288   
;;;3289   #ifdef __BIG_ENDIAN
;;;3290     nr[0] = val >> 24;
;;;3291     nr[1] = val >> 16;
;;;3292     nr[2] = val >> 8
;;;3293     nr[3] = val;
;;;3294   #else
;;;3295     nr[3] = val >> 24;
001f8a  70c2              STRB     r2,[r0,#3]
;;;3296     nr[2] = val >> 16;
001f8c  0c0a              LSRS     r2,r1,#16
001f8e  7082              STRB     r2,[r0,#2]
;;;3297     nr[1] = val >> 8;
001f90  0a0a              LSRS     r2,r1,#8
001f92  7042              STRB     r2,[r0,#1]
;;;3298     nr[0] = val;
001f94  7001              STRB     r1,[r0,#0]
;;;3299   #endif
;;;3300   }
001f96  4770              BX       lr
;;;3301   
                          ENDP

                  chk_param PROC
;;;3227   
;;;3228   static BOOL chk_param (const char *par, const char *sp) {
001f98  b570              PUSH     {r4-r6,lr}
001f9a  4605              MOV      r5,r0
001f9c  460c              MOV      r4,r1
;;;3229     /* Search for paramter 'par' in the string 'sp'. */
;;;3230   
;;;3231     while (*sp != 0) {
;;;3232       if (*sp++ == '/') {
;;;3233         if (fn_cmp (par, sp) == __TRUE) {
;;;3234           /* Found 'par' in the string 'sp'. */
;;;3235           return (__TRUE);
001f9e  e008              B        |L1.8114|
                  |L1.8096|
001fa0  1c64              ADDS     r4,r4,#1              ;3232
001fa2  292f              CMP      r1,#0x2f              ;3232
001fa4  d105              BNE      |L1.8114|
001fa6  4621              MOV      r1,r4                 ;3233
001fa8  4628              MOV      r0,r5                 ;3233
001faa  f7fffffe          BL       fn_cmp
001fae  2801              CMP      r0,#1                 ;3233
001fb0  d003              BEQ      |L1.8122|
                  |L1.8114|
001fb2  7821              LDRB     r1,[r4,#0]            ;3231
001fb4  2900              CMP      r1,#0                 ;3231
001fb6  d1f3              BNE      |L1.8096|
;;;3236         }
;;;3237       }
;;;3238     }
;;;3239     return (__FALSE);
001fb8  2000              MOVS     r0,#0
                  |L1.8122|
;;;3240   }
001fba  e736              B        |L1.7722|
;;;3241   
                          ENDP

                  clus_to_sect PROC
;;;1419   
;;;1420   static U32 clus_to_sect (U32 clus) {
001fbc  4a6c              LDR      r2,|L1.8560|
001fbe  b510              PUSH     {r4,lr}
;;;1421     /* Calculate absolute sector address from the cluster index. */
;;;1422     U32 sect,base;
;;;1423   
;;;1424     base = mmc.BootRecSec + mmc.RootDirAddr;
001fc0  8b93              LDRH     r3,[r2,#0x1c]  ; mmc
;;;1425     if (mmc.FatType != FS_FAT32) {
001fc2  7914              LDRB     r4,[r2,#4]  ; mmc
001fc4  6811              LDR      r1,[r2,#0]            ;1424  ; mmc
001fc6  2c03              CMP      r4,#3
001fc8  4419              ADD      r1,r1,r3              ;1424
001fca  d001              BEQ      |L1.8144|
;;;1426       base += mmc.RootSecCnt;
001fcc  8bd3              LDRH     r3,[r2,#0x1e]  ; mmc
001fce  4419              ADD      r1,r1,r3
                  |L1.8144|
;;;1427     }
;;;1428     sect = (clus - 2) * mmc.SecPerClus;
001fd0  7992              LDRB     r2,[r2,#6]  ; mmc
001fd2  1e80              SUBS     r0,r0,#2
;;;1429     return (base + sect);
001fd4  fb001002          MLA      r0,r0,r2,r1
;;;1430   }
001fd8  bd10              POP      {r4,pc}
;;;1431   
                          ENDP

                  get_EOC PROC
;;;1639   
;;;1640   static U32 get_EOC (void) {
001fda  4865              LDR      r0,|L1.8560|
;;;1641     /* Return an End Of Chain Marker. */
;;;1642   
;;;1643     switch (mmc.FatType) {
001fdc  7900              LDRB     r0,[r0,#4]  ; mmc
001fde  2801              CMP      r0,#1
001fe0  d005              BEQ      |L1.8174|
001fe2  2802              CMP      r0,#2
001fe4  d006              BEQ      |L1.8180|
001fe6  2803              CMP      r0,#3
001fe8  d007              BEQ      |L1.8186|
;;;1644       case FS_FAT12:
;;;1645         return (0x0FFF);
;;;1646       case FS_FAT16:
;;;1647         return (0xFFFF);
;;;1648       case FS_FAT32:
;;;1649         return (0x0FFFFFFF);
;;;1650     }
;;;1651     return (0);
001fea  2000              MOVS     r0,#0
;;;1652   }
001fec  4770              BX       lr
                  |L1.8174|
001fee  f64070ff          MOV      r0,#0xfff             ;1645
001ff2  4770              BX       lr
                  |L1.8180|
001ff4  f64f70ff          MOV      r0,#0xffff            ;1647
001ff8  4770              BX       lr
                  |L1.8186|
001ffa  f06f4070          MVN      r0,#0xf0000000        ;1649
001ffe  4770              BX       lr
;;;1653   
                          ENDP

                  lfn_calc_chksum PROC
;;;3147   
;;;3148   static U8 lfn_calc_chksum (U8 *fn) {
002000  4602              MOV      r2,r0
;;;3149     /* Calculate LFN checksum. */
;;;3150     U32 i;
;;;3151     U8  sum;
;;;3152   
;;;3153     sum = 0;
002002  2000              MOVS     r0,#0
;;;3154     for (i = 0; i < 11; i++) {
002004  4601              MOV      r1,r0
                  |L1.8198|
;;;3155       sum = ((sum & 1) ? 0x80 : 0) + (sum >> 1) + fn[i];
002006  07c3              LSLS     r3,r0,#31
002008  d000              BEQ      |L1.8204|
00200a  2380              MOVS     r3,#0x80
                  |L1.8204|
00200c  eb030050          ADD      r0,r3,r0,LSR #1
002010  5c53              LDRB     r3,[r2,r1]
002012  1c49              ADDS     r1,r1,#1              ;3154
002014  4418              ADD      r0,r0,r3
002016  b2c0              UXTB     r0,r0
002018  290b              CMP      r1,#0xb               ;3154
00201a  d3f4              BCC      |L1.8198|
;;;3156     }
;;;3157     return (sum);
;;;3158   }
00201c  4770              BX       lr
;;;3159   
                          ENDP

                  val_char_sn PROC
;;;1966   
;;;1967   static BOOL val_char_sn (U8 ch) {
00201e  f1a00120          SUB      r1,r0,#0x20
;;;1968     /* Validate character 'ch' to be a valid short name character. */
;;;1969   
;;;1970     if ((ch >= ' ' && ch <= '!') ||
002022  2901              CMP      r1,#1
002024  d917              BLS      |L1.8278|
;;;1971         (ch >= '#' && ch <= ')') ||
002026  1ec9              SUBS     r1,r1,#3
002028  2906              CMP      r1,#6
00202a  d914              BLS      |L1.8278|
;;;1972         (ch == '-')              ||
00202c  282d              CMP      r0,#0x2d
00202e  d012              BEQ      |L1.8278|
;;;1973         (ch == '.')              ||
002030  282e              CMP      r0,#0x2e
002032  d010              BEQ      |L1.8278|
;;;1974         (ch >= '0' && ch <= '9') ||
002034  390d              SUBS     r1,r1,#0xd
002036  2909              CMP      r1,#9
002038  d90d              BLS      |L1.8278|
;;;1975         (ch == '@')              ||
00203a  2840              CMP      r0,#0x40
00203c  d00b              BEQ      |L1.8278|
;;;1976         (ch >= 'A' && ch <= 'Z') ||
00203e  3911              SUBS     r1,r1,#0x11
002040  2919              CMP      r1,#0x19
002042  d908              BLS      |L1.8278|
;;;1977         (ch >= '^' && ch <= '{') ||
002044  391d              SUBS     r1,r1,#0x1d
002046  291d              CMP      r1,#0x1d
002048  d905              BLS      |L1.8278|
;;;1978         (ch == '}')              ||
00204a  287d              CMP      r0,#0x7d
00204c  d003              BEQ      |L1.8278|
;;;1979         (ch == '~')               ) {
00204e  287e              CMP      r0,#0x7e
002050  d001              BEQ      |L1.8278|
;;;1980   
;;;1981       /* This is a valid short name character. */
;;;1982       return (__TRUE);
;;;1983     }
;;;1984   
;;;1985     /* This is not a valid short name character. */
;;;1986     return (__FALSE);
002052  2000              MOVS     r0,#0
;;;1987   }
002054  4770              BX       lr
                  |L1.8278|
002056  2001              MOVS     r0,#1                 ;1982
002058  4770              BX       lr
;;;1988   
                          ENDP

                  val_char PROC
;;;1952   
;;;1953   static U8 val_char (U8 ch) {
00205a  b510              PUSH     {r4,lr}
00205c  4604              MOV      r4,r0
;;;1954     /* Validate character 'ch' to be a valid character if not convert it 
;;;1955        to 'X'. */
;;;1956   
;;;1957     if (val_char_sn (ch) == __FALSE) {
00205e  f7fffffe          BL       val_char_sn
002062  b108              CBZ      r0,|L1.8296|
;;;1958       return ('X');
;;;1959     }
;;;1960   
;;;1961     return (ch);
002064  4620              MOV      r0,r4
;;;1962   }
002066  bd10              POP      {r4,pc}
                  |L1.8296|
002068  2058              MOVS     r0,#0x58              ;1958
00206a  bd10              POP      {r4,pc}
;;;1963   
                          ENDP

                  check_name PROC
;;;2401   
;;;2402   static BOOL check_name (const char *name, IOB *fcb, U8 type) {
00206c  2301              MOVS     r3,#1
;;;2403     /* Check if requested name of requested type exists.                      */
;;;2404   
;;;2405     return (search_for_name (name, fcb, type, ACT_KEEPFCB));
00206e  f7ffbffe          B.W      search_for_name
;;;2406   }
;;;2407   
                          ENDP

                  find_name PROC
;;;2391   
;;;2392   static BOOL find_name (const char *name, IOB *fcb, U8 type) {
002072  2300              MOVS     r3,#0
;;;2393     /* Search for entries with requested name and of requested type 
;;;2394        (file or dir).                                                         */
;;;2395   
;;;2396     return (search_for_name (name, fcb, type, ACT_NONE));
002074  f7ffbffe          B.W      search_for_name
;;;2397   }
;;;2398   
                          ENDP

                  chk_dir_empty PROC
;;;2647   
;;;2648   static BOOL chk_dir_empty (IOB *fcb) {
002078  b5f8              PUSH     {r3-r7,lr}
;;;2649     /* Return __TRUE if directory is empty (has only "." and ".." entries) or 
;;;2650        __FALSE if directory is not empty. */
;;;2651     FILEREC     *frec;
;;;2652     U32          clus          = fcb->_firstClus;
00207a  69c0              LDR      r0,[r0,#0x1c]
;;;2653     U32          idx;
;;;2654     U32          sect;
;;;2655   
;;;2656     if (clus == 0) {
00207c  9000              STR      r0,[sp,#0]
00207e  b3b0              CBZ      r0,|L1.8430|
;;;2657       /* If checking for root, always return not empty. */
;;;2658       goto dir_not_empty;
;;;2659     }
;;;2660   
;;;2661     /* Calculate address of sector where search starts. */
;;;2662     sect = clus_to_sect (clus);
002080  f7fffffe          BL       clus_to_sect
;;;2663   
;;;2664     /* Search until unallocated entry found. */
;;;2665     for (idx = 0; ; idx ++) {
;;;2666       /* Check if step to next cluster is needed. */
;;;2667       if (idx == mmc.EntsPerClus) {
002084  4f3a              LDR      r7,|L1.8560|
002086  4606              MOV      r6,r0                 ;2662
002088  2400              MOVS     r4,#0                 ;2665
                  |L1.8330|
00208a  8cb8              LDRH     r0,[r7,#0x24]  ; mmc
00208c  42a0              CMP      r0,r4
00208e  d10d              BNE      |L1.8364|
;;;2668         idx = 0;
002090  2400              MOVS     r4,#0
;;;2669         EX(set_next_clus (&clus),__FALSE);
002092  4668              MOV      r0,sp
002094  f7fffffe          BL       set_next_clus
002098  2800              CMP      r0,#0
00209a  d029              BEQ      |L1.8432|
;;;2670         if (is_EOC (clus)) {
00209c  9800              LDR      r0,[sp,#0]
00209e  f7fffffe          BL       is_EOC
0020a2  bb40              CBNZ     r0,|L1.8438|
;;;2671           /* No more entries, end of current directory. */
;;;2672           goto dir_empty;
;;;2673         }
;;;2674         sect = clus_to_sect (clus);
0020a4  9800              LDR      r0,[sp,#0]
0020a6  f7fffffe          BL       clus_to_sect
0020aa  4606              MOV      r6,r0
                  |L1.8364|
;;;2675       }
;;;2676   
;;;2677       EX(read_sector (sect + (idx >> 4)),__FALSE);
0020ac  eb061014          ADD      r0,r6,r4,LSR #4
0020b0  f7fffffe          BL       read_sector
0020b4  2800              CMP      r0,#0
0020b6  d01b              BEQ      |L1.8432|
;;;2678       frec      = (FILEREC *)ca.buf + (idx & 0x0F);
0020b8  482d              LDR      r0,|L1.8560|
0020ba  f004010f          AND      r1,r4,#0xf
0020be  3814              SUBS     r0,r0,#0x14
0020c0  6880              LDR      r0,[r0,#8]  ; ca
0020c2  eb001541          ADD      r5,r0,r1,LSL #5
;;;2679   
;;;2680       if (frec->FileName[0] == '.') {
0020c6  7828              LDRB     r0,[r5,#0]
0020c8  282e              CMP      r0,#0x2e
0020ca  d109              BNE      |L1.8416|
;;;2681         if (strcmp ((const char *)&frec->FileName[0], ".          \x10") == 0) {
0020cc  a129              ADR      r1,|L1.8564|
0020ce  4628              MOV      r0,r5
0020d0  f7fffffe          BL       strcmp
0020d4  b168              CBZ      r0,|L1.8434|
;;;2682           /* Dot entry. */
;;;2683           continue;
;;;2684         }
;;;2685         if (strcmp ((const char *)&frec->FileName[0], "..         \x10") == 0) {
0020d6  a12b              ADR      r1,|L1.8580|
0020d8  4628              MOV      r0,r5
0020da  f7fffffe          BL       strcmp
0020de  b140              CBZ      r0,|L1.8434|
                  |L1.8416|
;;;2686           /* Dot dot entry. */
;;;2687           continue;
;;;2688         }
;;;2689       }
;;;2690   
;;;2691       if (frec->FileName[0] == 0x00) {
0020e0  7828              LDRB     r0,[r5,#0]
0020e2  b140              CBZ      r0,|L1.8438|
;;;2692         /* There are no allocated entries after this one. */
;;;2693         goto dir_empty;
;;;2694       }
;;;2695   
;;;2696       if (frec->FileName[0] == 0xE5) {
0020e4  28e5              CMP      r0,#0xe5
0020e6  d004              BEQ      |L1.8434|
;;;2697         /* Erased file, first character is 0xE5. */
;;;2698         continue;
;;;2699       }
;;;2700   
;;;2701       if (frec->Attr == ATTR_VOLUME_ID) {
0020e8  7ae8              LDRB     r0,[r5,#0xb]
0020ea  2808              CMP      r0,#8
0020ec  d001              BEQ      |L1.8434|
                  |L1.8430|
;;;2702         /* Skip Volume ID entry. */
;;;2703         continue;
;;;2704       }
;;;2705   
;;;2706       goto dir_not_empty;
;;;2707     }
;;;2708   
;;;2709   dir_not_empty:
;;;2710     return (__FALSE);
0020ee  2000              MOVS     r0,#0
                  |L1.8432|
;;;2711   
;;;2712   dir_empty:
;;;2713     return (__TRUE);
;;;2714   }
0020f0  bdf8              POP      {r3-r7,pc}
                  |L1.8434|
0020f2  1c64              ADDS     r4,r4,#1              ;2665
0020f4  e7c9              B        |L1.8330|
                  |L1.8438|
0020f6  2001              MOVS     r0,#1                 ;2713
0020f8  bdf8              POP      {r3-r7,pc}
;;;2715   
                          ENDP

                  rename_entries PROC
;;;3037   
;;;3038   static BOOL rename_entries (const char *new_name, IOB *fcb, U8 type) {
0020fa  e92d47f0          PUSH     {r4-r10,lr}
0020fe  b088              SUB      sp,sp,#0x20
002100  4688              MOV      r8,r1
002102  4692              MOV      r10,r2
002104  4681              MOV      r9,r0
;;;3039     /* Rename entries that fcb is pointing to to requested new_name. */
;;;3040     FILEREC      old_frec;
;;;3041     U8           name_lfn_f    = check_lfn (new_name); 
002106  f7fffffe          BL       check_lfn
;;;3042     U8           longer_f;
;;;3043     U8           ents          = numOfEntries;
00210a  4f22              LDR      r7,|L1.8596|
00210c  b2c6              UXTB     r6,r0                 ;3041
;;;3044   
;;;3045     /* Read last entry to keep some informations from it. */
;;;3046     EX(read_last_entry (fcb, &old_frec),__FALSE);
00210e  4669              MOV      r1,sp
002110  783d              LDRB     r5,[r7,#0]            ;3043  ; numOfEntries
002112  4640              MOV      r0,r8
002114  f7fffffe          BL       read_last_entry
002118  2800              CMP      r0,#0
00211a  d024              BEQ      |L1.8550|
;;;3047   
;;;3048     /* See if we can write over old entries. */
;;;3049     longer_f     = 0;
00211c  2400              MOVS     r4,#0
;;;3050     if (name_lfn_f) {
00211e  b15e              CBZ      r6,|L1.8504|
;;;3051       if (ents == 1) {
002120  2d01              CMP      r5,#1
002122  d008              BEQ      |L1.8502|
;;;3052         longer_f = 1;
;;;3053       }
;;;3054       else if (((strlen(new_name) + 12) / 13) > ents) {
002124  4648              MOV      r0,r9
002126  f7fffffe          BL       strlen
00212a  300c              ADDS     r0,r0,#0xc
00212c  210d              MOVS     r1,#0xd
00212e  fbb0f0f1          UDIV     r0,r0,r1
002132  42a8              CMP      r0,r5
002134  d900              BLS      |L1.8504|
                  |L1.8502|
;;;3055         longer_f = 1;
002136  2401              MOVS     r4,#1
                  |L1.8504|
;;;3056       }
;;;3057     }
;;;3058   
;;;3059     /* Delete old entries, but keep data. */
;;;3060     EX(delete_entries (fcb, 1),__FALSE);
002138  2101              MOVS     r1,#1
00213a  4640              MOV      r0,r8
00213c  f7fffffe          BL       delete_entries
002140  2800              CMP      r0,#0
002142  d010              BEQ      |L1.8550|
;;;3061   
;;;3062     if (longer_f) {
002144  b13c              CBZ      r4,|L1.8534|
;;;3063       /* Allocate new space for entries and write them. */
;;;3064   
;;;3065       /* If creation of new entries requested find unallocated entry */
;;;3066       fcb->_firstClus = firstEntClus;
002146  6979              LDR      r1,[r7,#0x14]  ; firstEntClus
;;;3067       if (alloc_name (new_name, fcb) == __FALSE) {
002148  f8c8101c          STR      r1,[r8,#0x1c]
00214c  4641              MOV      r1,r8
00214e  4648              MOV      r0,r9
002150  f7fffffe          BL       alloc_name
002154  b148              CBZ      r0,|L1.8554|
                  |L1.8534|
;;;3068         /* If unable to find unallocated entry. */
;;;3069         goto fail;
;;;3070       }
;;;3071     }
;;;3072   
;;;3073     /* Write new entries. */
;;;3074     if (write_entries (new_name, fcb, type, &old_frec) == __FALSE) {
002156  466b              MOV      r3,sp
002158  4652              MOV      r2,r10
00215a  4641              MOV      r1,r8
00215c  4648              MOV      r0,r9
00215e  f7fffffe          BL       write_entries
002162  b110              CBZ      r0,|L1.8554|
;;;3075       /* Rename was unsuccessfull. */
;;;3076       goto fail;
;;;3077     }
;;;3078   
;;;3079     /* Rename successfull. */
;;;3080     return(__TRUE);
002164  2001              MOVS     r0,#1
                  |L1.8550|
;;;3081   
;;;3082   fail:
;;;3083     return (__FALSE);
;;;3084   }
002166  b008              ADD      sp,sp,#0x20
002168  e4e9              B        |L1.6974|
                  |L1.8554|
00216a  2000              MOVS     r0,#0                 ;3083
00216c  e7fb              B        |L1.8550|
;;;3085   
                          ENDP

00216e  0000              DCW      0x0000
                  |L1.8560|
                          DCD      ||.bss||+0x20
                  |L1.8564|
002174  2e202020          DCB      ".          ",16,0
002178  20202020
00217c  20202010
002180  00      
002181  00                DCB      0
002182  00                DCB      0
002183  00                DCB      0
                  |L1.8580|
002184  2e2e2020          DCB      "..         ",16,0
002188  20202020
00218c  20202010
002190  00      
002191  00                DCB      0
002192  00                DCB      0
002193  00                DCB      0
                  |L1.8596|
                          DCD      ||.data||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  ||fat||
                          %        12
                  ||ca||
                          %        20
                  mmc
                          %        48
                  name_buf
                          %        260

                          AREA ||.constdata||, DATA, READONLY, ALIGN=1

                  IniDevCfg
000000  01100000          DCB      0x01,0x10,0x00,0x00
000004  0002              DCW      0x0002
000006  1000              DCB      0x10,0x00
000008  02000041          DCW      0x0200,0x0041
00000c  01100000          DCB      0x01,0x10,0x00,0x00
000010  0002              DCW      0x0002
000012  1000              DCB      0x10,0x00
000014  04000041          DCW      0x0400,0x0041
000018  01200000          DCB      0x01,0x20,0x00,0x00
00001c  0002              DCW      0x0002
00001e  2000              DCB      0x20,0x00
000020  04000041          DCW      0x0400,0x0041
000024  01200000          DCB      0x01,0x20,0x00,0x00
000028  0004              DCW      0x0004
00002a  2000              DCB      0x20,0x00
00002c  04000041          DCW      0x0400,0x0041
000030  02100000          DCB      0x02,0x10,0x00,0x00
000034  0008              DCW      0x0008
000036  2000              DCB      0x20,0x00
000038  04000041          DCW      0x0400,0x0041
00003c  02100400          DCB      0x02,0x10,0x04,0x00
000040  0010              DCW      0x0010
000042  2000              DCB      0x20,0x00
000044  04000081          DCW      0x0400,0x0081
000048  02200800          DCB      0x02,0x20,0x08,0x00
00004c  0020              DCW      0x0020
00004e  2000              DCB      0x20,0x00
000050  04000081          DCW      0x0400,0x0081
000054  02201000          DCB      0x02,0x20,0x10,0x00
000058  0040              DCW      0x0040
00005a  2000              DCB      0x20,0x00
00005c  04000101          DCW      0x0400,0x0101
000060  02402000          DCB      0x02,0x40,0x20,0x00
000064  0100              DCW      0x0100
000066  2000              DCB      0x20,0x00
000068  02000101          DCW      0x0200,0x0101
00006c  03404000          DCB      0x03,0x40,0x40,0x00
000070  0100              DCW      0x0100
000072  2000              DCB      0x20,0x00
000074  04000101          DCW      0x0400,0x0101
                  ChIndex
000078  01030507          DCB      0x01,0x03,0x05,0x07
00007c  090e1012          DCB      0x09,0x0e,0x10,0x12
000080  1416181c          DCB      0x14,0x16,0x18,0x1c
000084  1e                DCB      0x1e

                          AREA ||.data||, DATA, ALIGN=2

                  numOfEntries
000000  00                DCB      0x00
                  in_root_1x
000001  00                DCB      0x00
                  warm_restart
000002  0000              DCB      0x00,0x00
                  firstEntOffs
000004  00000000          DCB      0x00,0x00,0x00,0x00
                  free_clus
                          DCD      0x00000000
                  top_clus
                          DCD      0x00000000
                  startDirClus
                          DCD      0x00000000
                  firstEntClus
                          DCD      0x00000000
