<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>LUFA Library - RNDIS Ethernet Demo: Lib/TCP.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<script type="text/javascript">
function hasClass(ele,cls) {
  return ele.className.match(new RegExp('(\\s|^)'+cls+'(\\s|$)'));
}

function addClass(ele,cls) {
  if (!this.hasClass(ele,cls)) ele.className += " "+cls;
}

function removeClass(ele,cls) {
  if (hasClass(ele,cls)) {
    var reg = new RegExp('(\\s|^)'+cls+'(\\s|$)');
    ele.className=ele.className.replace(reg,' ');
  }
}

function toggleVisibility(linkObj) {
 var base = linkObj.getAttribute('id');
 var summary = document.getElementById(base + '-summary');
 var content = document.getElementById(base + '-content');
 var trigger = document.getElementById(base + '-trigger');
 if ( hasClass(linkObj,'closed') ) {
   summary.style.display = 'none';
   content.style.display = 'block';
   trigger.src = 'open.png';
   removeClass(linkObj,'closed');
   addClass(linkObj,'opened');
 } else if ( hasClass(linkObj,'opened') ) {
   summary.style.display = 'block';
   content.style.display = 'none';
   trigger.src = 'closed.png';
   removeClass(linkObj,'opened');
   addClass(linkObj,'closed');
 }
 return false;
}
</script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">LUFA Library - RNDIS Ethernet Demo&#160;<span id="projectnumber">0.0.0</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('a00030.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">TCP.c File Reference</div>  </div>
</div>
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="a00031.html">TCP.h</a>&quot;</code><br/>
</div><table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00030.html#a11249837b77c0f03863a1c375aa9ada6">TCP_TCPTask</a> (USB_ClassInfo_RNDIS_Device_t *const RNDISInterfaceInfo, <a class="el" href="a00004.html">Ethernet_Frame_Info_t</a> *const <a class="el" href="a00036.html#aef9503cade38a6b550a948e5c4cc8d2b">FrameOUT</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00030.html#a3a02a29f93af673139608232298ef119">TCP_Init</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00030.html#a1707fcc52e95e8435a772bef4493c1ac">TCP_SetPortState</a> (const uint16_t Port, const uint8_t State, void(*Handler)(<a class="el" href="a00010.html">TCP_ConnectionState_t</a> *, <a class="el" href="a00008.html">TCP_ConnectionBuffer_t</a> *))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00030.html#a21124735556432c7a437998aa748cd67">TCP_GetPortState</a> (const uint16_t Port)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00030.html#af59f40c0018701454c72c0edc61f87a1">TCP_SetConnectionState</a> (const uint16_t Port, const <a class="el" href="a00006.html">IP_Address_t</a> RemoteAddress, const uint16_t RemotePort, const uint8_t State)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00030.html#a899d0564f1ef7b15f41b75176ddade0c">TCP_GetConnectionState</a> (const uint16_t Port, const <a class="el" href="a00006.html">IP_Address_t</a> RemoteAddress, const uint16_t RemotePort)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00009.html">TCP_ConnectionInfo_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00030.html#a8a407edd2889d82fc2617a3b1884e584">TCP_GetConnectionInfo</a> (const uint16_t Port, const <a class="el" href="a00006.html">IP_Address_t</a> RemoteAddress, const uint16_t RemotePort)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00030.html#aa2bf6261c8743fd64cb4e8f3f59498ee">TCP_ProcessTCPPacket</a> (void *IPHeaderInStart, void *TCPHeaderInStart, void *TCPHeaderOutStart)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00030.html#ad0d8fac4bf081cb55d7344589bd4c6db">TCP_Checksum16</a> (void *TCPHeaderOutStart, const <a class="el" href="a00006.html">IP_Address_t</a> SourceAddress, const <a class="el" href="a00006.html">IP_Address_t</a> DestinationAddress, const uint16_t TCPOutSize)</td></tr>
<tr><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00012.html">TCP_PortState_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00030.html#af2e38fb19ac4d5ce52d9b52f5f227f8e">PortStateTable</a> [MAX_OPEN_TCP_PORTS]</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00010.html">TCP_ConnectionState_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00030.html#a651f91ede4e43961a77e264996aea775">ConnectionStateTable</a> [MAX_TCP_CONNECTIONS]</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Transmission Control Protocol (TCP) packet handling routines. This protocol handles the reliable in-order transmission and reception of packets to and from devices on a network, to "ports" on the device. It is used in situations where data delivery must be reliable and correct, e.g. HTTP, TELNET and most other non-streaming protocols. </p>
</div><hr/><h2>Function Documentation</h2>
<a class="anchor" id="ad0d8fac4bf081cb55d7344589bd4c6db"></a><!-- doxytag: member="TCP.c::TCP_Checksum16" ref="ad0d8fac4bf081cb55d7344589bd4c6db" args="(void *TCPHeaderOutStart, const IP_Address_t SourceAddress, const IP_Address_t DestinationAddress, const uint16_t TCPOutSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static uint16_t TCP_Checksum16 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>TCPHeaderOutStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00006.html">IP_Address_t</a>&#160;</td>
          <td class="paramname"><em>SourceAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00006.html">IP_Address_t</a>&#160;</td>
          <td class="paramname"><em>DestinationAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>TCPOutSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Calculates the appropriate TCP checksum, consisting of the addition of the one's compliment of each word, complimented.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">TCPHeaderOutStart</td><td>Pointer to the start of the packet's outgoing TCP header </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SourceAddress</td><td>Source protocol IP address of the outgoing IP header </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DestinationAddress</td><td>Destination protocol IP address of the outgoing IP header </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">TCPOutSize</td><td>Size in bytes of the TCP data header and payload</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A 16-bit TCP checksum value </dd></dl>

</div>
</div>
<a class="anchor" id="a8a407edd2889d82fc2617a3b1884e584"></a><!-- doxytag: member="TCP.c::TCP_GetConnectionInfo" ref="a8a407edd2889d82fc2617a3b1884e584" args="(const uint16_t Port, const IP_Address_t RemoteAddress, const uint16_t RemotePort)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00009.html">TCP_ConnectionInfo_t</a>* TCP_GetConnectionInfo </td>
          <td>(</td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>Port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00006.html">IP_Address_t</a>&#160;</td>
          <td class="paramname"><em>RemoteAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>RemotePort</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Retrieves the connection info structure of a given connection to a host.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Port</td><td>TCP port on the device in the connection, specified in big endian </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">RemoteAddress</td><td>Remote protocol IP address of the connected host </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">RemotePort</td><td>Remote TCP port of the connected host, specified in big endian</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>ConnectionInfo structure of the connection if found, NULL otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a899d0564f1ef7b15f41b75176ddade0c"></a><!-- doxytag: member="TCP.c::TCP_GetConnectionState" ref="a899d0564f1ef7b15f41b75176ddade0c" args="(const uint16_t Port, const IP_Address_t RemoteAddress, const uint16_t RemotePort)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t TCP_GetConnectionState </td>
          <td>(</td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>Port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00006.html">IP_Address_t</a>&#160;</td>
          <td class="paramname"><em>RemoteAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>RemotePort</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Retrieves the current state of a given TCP connection to a host.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Port</td><td>TCP port on the device in the connection, specified in big endian </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">RemoteAddress</td><td>Remote protocol IP address of the connected host </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">RemotePort</td><td>Remote TCP port of the connected host, specified in big endian</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A value from the <a class="el" href="a00031.html#ada8f5fbdd98f2bcd9db12a180365e1fe">TCP_ConnectionStates_t</a> enum </dd></dl>

</div>
</div>
<a class="anchor" id="a21124735556432c7a437998aa748cd67"></a><!-- doxytag: member="TCP.c::TCP_GetPortState" ref="a21124735556432c7a437998aa748cd67" args="(const uint16_t Port)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t TCP_GetPortState </td>
          <td>(</td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>Port</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Retrieves the current state of a given TCP port, specified in big endian.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Port</td><td>TCP port whose state is to be retrieved, given in big-endian</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A value from the <a class="el" href="a00031.html#a25e27db92241172c3518ef8a237a38f6">TCP_PortStates_t</a> enum </dd></dl>

</div>
</div>
<a class="anchor" id="a3a02a29f93af673139608232298ef119"></a><!-- doxytag: member="TCP.c::TCP_Init" ref="a3a02a29f93af673139608232298ef119" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TCP_Init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initializes the TCP protocol handler, clearing the port and connection state tables. This must be called before TCP packets are processed. </p>

</div>
</div>
<a class="anchor" id="aa2bf6261c8743fd64cb4e8f3f59498ee"></a><!-- doxytag: member="TCP.c::TCP_ProcessTCPPacket" ref="aa2bf6261c8743fd64cb4e8f3f59498ee" args="(void *IPHeaderInStart, void *TCPHeaderInStart, void *TCPHeaderOutStart)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t TCP_ProcessTCPPacket </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>IPHeaderInStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>TCPHeaderInStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>TCPHeaderOutStart</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Processes a TCP packet inside an Ethernet frame, and writes the appropriate response to the output Ethernet frame if one is created by a application handler.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">IPHeaderInStart</td><td>Pointer to the start of the incoming packet's IP header </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">TCPHeaderInStart</td><td>Pointer to the start of the incoming packet's TCP header </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">TCPHeaderOutStart</td><td>Pointer to the start of the outgoing packet's TCP header</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of bytes written to the out Ethernet frame if any, NO_RESPONSE if no response was generated, NO_PROCESS if the packet processing was deferred until the next Ethernet packet handler iteration </dd></dl>

</div>
</div>
<a class="anchor" id="af59f40c0018701454c72c0edc61f87a1"></a><!-- doxytag: member="TCP.c::TCP_SetConnectionState" ref="af59f40c0018701454c72c0edc61f87a1" args="(const uint16_t Port, const IP_Address_t RemoteAddress, const uint16_t RemotePort, const uint8_t State)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TCP_SetConnectionState </td>
          <td>(</td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>Port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00006.html">IP_Address_t</a>&#160;</td>
          <td class="paramname"><em>RemoteAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>RemotePort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>State</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the connection state of the given port, remote address and remote port to the given TCP connection state. If the connection exists in the connection state table it is updated, otherwise it is created if possible.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Port</td><td>TCP port of the connection on the device, specified in big endian </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">RemoteAddress</td><td>Remote protocol IP address of the connected device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">RemotePort</td><td>TCP port of the remote device in the connection, specified in big endian </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">State</td><td>TCP connection state, a value from the <a class="el" href="a00031.html#ada8f5fbdd98f2bcd9db12a180365e1fe">TCP_ConnectionStates_t</a> enum</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Boolean true if the connection was updated or created, false otherwise (no more space in the connection state table) </dd></dl>

</div>
</div>
<a class="anchor" id="a1707fcc52e95e8435a772bef4493c1ac"></a><!-- doxytag: member="TCP.c::TCP_SetPortState" ref="a1707fcc52e95e8435a772bef4493c1ac" args="(const uint16_t Port, const uint8_t State, void(*Handler)(TCP_ConnectionState_t *, TCP_ConnectionBuffer_t *))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TCP_SetPortState </td>
          <td>(</td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>Port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>State</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(<a class="el" href="a00010.html">TCP_ConnectionState_t</a> *, <a class="el" href="a00008.html">TCP_ConnectionBuffer_t</a> *)&#160;</td>
          <td class="paramname"><em>Handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the state and callback handler of the given port, specified in big endian to the given state.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Port</td><td>Port whose state and callback function to set, specified in big endian </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">State</td><td>New state of the port, a value from the <a class="el" href="a00031.html#a25e27db92241172c3518ef8a237a38f6">TCP_PortStates_t</a> enum </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Handler</td><td>Application callback handler for the port</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Boolean true if the port state was set, false otherwise (no more space in the port state table) </dd></dl>

</div>
</div>
<a class="anchor" id="a11249837b77c0f03863a1c375aa9ada6"></a><!-- doxytag: member="TCP.c::TCP_TCPTask" ref="a11249837b77c0f03863a1c375aa9ada6" args="(USB_ClassInfo_RNDIS_Device_t *const RNDISInterfaceInfo, Ethernet_Frame_Info_t *const FrameOUT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TCP_TCPTask </td>
          <td>(</td>
          <td class="paramtype">USB_ClassInfo_RNDIS_Device_t *const&#160;</td>
          <td class="paramname"><em>RNDISInterfaceInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00004.html">Ethernet_Frame_Info_t</a> *const&#160;</td>
          <td class="paramname"><em>FrameOUT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Task to handle the calling of each registered application's callback function, to process and generate TCP packets at the application level. If an application produces a response, this task constructs the appropriate Ethernet frame and places it into the Ethernet OUT buffer for later transmission. </p>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="a651f91ede4e43961a77e264996aea775"></a><!-- doxytag: member="TCP.c::ConnectionStateTable" ref="a651f91ede4e43961a77e264996aea775" args="[MAX_TCP_CONNECTIONS]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00010.html">TCP_ConnectionState_t</a> <a class="el" href="a00030.html#a651f91ede4e43961a77e264996aea775">ConnectionStateTable</a>[MAX_TCP_CONNECTIONS]</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Connection state table array. This contains the current status of TCP connections in the device. To save on space, only active (non-closed) connections are stored - closed connections may be overwritten at any time, and the system will assume any connections not present in the array are closed. </p>

</div>
</div>
<a class="anchor" id="af2e38fb19ac4d5ce52d9b52f5f227f8e"></a><!-- doxytag: member="TCP.c::PortStateTable" ref="af2e38fb19ac4d5ce52d9b52f5f227f8e" args="[MAX_OPEN_TCP_PORTS]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00012.html">TCP_PortState_t</a> <a class="el" href="a00030.html#af2e38fb19ac4d5ce52d9b52f5f227f8e">PortStateTable</a>[MAX_OPEN_TCP_PORTS]</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Port state table array. This contains the current status of TCP ports in the device. To save on space, only open ports are stored - closed ports may be overwritten at any time, and the system will assume any ports not present in the array are closed. This allows for MAX_OPEN_TCP_PORTS to be less than the number of ports used by the application if desired. </p>

</div>
</div>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="a00030.html">TCP.c</a>      </li>
      <li class="footer">Generated by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </li>
    </ul>
  </div>

</body>
</html>
