<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>LUFA Library: Endpoint Management (XMEGA)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.4 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<script type="text/javascript">
function hasClass(ele,cls) {
  return ele.className.match(new RegExp('(\\s|^)'+cls+'(\\s|$)'));
}

function addClass(ele,cls) {
  if (!this.hasClass(ele,cls)) ele.className += " "+cls;
}

function removeClass(ele,cls) {
  if (hasClass(ele,cls)) {
    var reg = new RegExp('(\\s|^)'+cls+'(\\s|$)');
    ele.className=ele.className.replace(reg,' ');
  }
}

function toggleVisibility(linkObj) {
 var base = linkObj.getAttribute('id');
 var summary = document.getElementById(base + '-summary');
 var content = document.getElementById(base + '-content');
 var trigger = document.getElementById(base + '-trigger');
 if ( hasClass(linkObj,'closed') ) {
   summary.style.display = 'none';
   content.style.display = 'block';
   trigger.src = 'open.png';
   removeClass(linkObj,'closed');
   addClass(linkObj,'opened');
 } else if ( hasClass(linkObj,'opened') ) {
   summary.style.display = 'block';
   content.style.display = 'none';
   trigger.src = 'closed.png';
   removeClass(linkObj,'opened');
   addClass(linkObj,'closed');
 }
 return false;
}
</script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="LUFA_thumb.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">LUFA Library&#160;<span id="projectnumber">120219</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('group___group___endpoint_management___x_m_e_g_a.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#define-members">Defines</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Endpoint Management (XMEGA)</div>  </div>
<div class="ingroups"><a class="el" href="group___group___endpoint_management.html">Endpoint Management</a></div></div>
<div class="contents">

<p>Endpoint management definitions for the Atmel AVR XMEGA architecture.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___endpoint_management___x_m_e_g_a.html#gaebe9cfe97e9292e5e8cfba9885bbd901">ENDPOINT_CONTROLEP_DEFAULT_SIZE</a>&#160;&#160;&#160;8</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___endpoint_management___x_m_e_g_a.html#gad9e1bb9ac6153e39301490b29e77e93a">ENDPOINT_MAX_SIZE</a>(EPIndex)&#160;&#160;&#160;_ENDPOINT_GET_MAXSIZE(EPIndex)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___endpoint_management___x_m_e_g_a.html#ga39206fe8d12fdddec3aadc86f1018c88">ENDPOINT_BANKS_SUPPORTED</a>(EPIndex)&#160;&#160;&#160;_ENDPOINT_GET_BANKS(EPIndex)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___endpoint_management___x_m_e_g_a.html#ga0aaeafaa974fb7095750a771e2adfc73">ENDPOINT_TOTAL_ENDPOINTS</a>&#160;&#160;&#160;ENDPOINT_DETAILS_MAXEP</td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___endpoint_management___x_m_e_g_a.html#gaabe158bf40f66c96a704094cfdfbbf47">Endpoint_SelectEndpoint</a> (const uint8_t EndpointNumber)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___endpoint_management___x_m_e_g_a.html#ga22272fed65e01ca76a4571f9914b5fe5">Endpoint_ConfigureEndpoint</a> (const uint8_t Number, const uint8_t Type, const uint8_t Direction, const uint16_t Size, const uint8_t Banks) ATTR_ALWAYS_INLINE</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___endpoint_management___x_m_e_g_a.html#ga3eb31e520c947003839bfb5e1e4bf95c">Endpoint_GetCurrentEndpoint</a> (void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___endpoint_management___x_m_e_g_a.html#gaf9df3619b7c2f9b63403097f9869cd3e">Endpoint_ResetEndpoint</a> (const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___endpoint_management___x_m_e_g_a.html#ga0258dd64dd4215c59ce9713868f5a387">Endpoint_IsEnabled</a> (void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___endpoint_management___x_m_e_g_a.html#ga22dedc9265477d753e932fc805ebb91d">Endpoint_IsConfigured</a> (void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___endpoint_management___x_m_e_g_a.html#ga4744236ce0d28f80c69a3225fdeabe81">Endpoint_GetEndpointInterrupts</a> (void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___endpoint_management___x_m_e_g_a.html#gadef5dafdf7515ce080f890640fe5f4ef">Endpoint_HasEndpointInterrupted</a> (const uint8_t EndpointNumber) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___endpoint_management___x_m_e_g_a.html#gac2051cf461db29c5c73651edbe77638a">Endpoint_ResetDataToggle</a> (void) ATTR_ALWAYS_INLINE</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___endpoint_management___x_m_e_g_a.html#gaedaf95aead8b39dcea3ed2fa52e86950">Endpoint_GetEndpointDirection</a> (void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___endpoint_management___x_m_e_g_a.html#ga9e00020d1fca630c351e3b8139ba67df">Endpoint_ClearStatusStage</a> (void)</td></tr>
<tr><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___endpoint_management___x_m_e_g_a.html#gac1805540ce24cf3cbd621c2e0cbc1c31">USB_Device_ControlEndpointSize</a></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Endpoint Bank Mode Masks</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___endpoint_management___x_m_e_g_a.html#gae4bc67200452560b253e3f01acae9373">ENDPOINT_BANK_SINGLE</a>&#160;&#160;&#160;0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___endpoint_management___x_m_e_g_a.html#ga417e96e8278a9c41e846fff106ce5791">ENDPOINT_BANK_DOUBLE</a>&#160;&#160;&#160;USB_EP_PINGPONG_bm</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<p>Functions, macros and enums related to endpoint management when in USB Device mode. This module contains the endpoint management macros, as well as endpoint interrupt and data send/receive functions for various data types. </p>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="ga417e96e8278a9c41e846fff106ce5791"></a><!-- doxytag: member="Endpoint_XMEGA.h::ENDPOINT_BANK_DOUBLE" ref="ga417e96e8278a9c41e846fff106ce5791" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ENDPOINT_BANK_DOUBLE&#160;&#160;&#160;USB_EP_PINGPONG_bm</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Mask for the bank mode selection for the <a class="el" href="group___group___endpoint_management___a_v_r8.html#ga22272fed65e01ca76a4571f9914b5fe5">Endpoint_ConfigureEndpoint()</a> macro. This indicates that the endpoint should have two banks, which requires more USB FIFO memory but results in faster transfers as one USB device (the AVR or the host) can access one bank while the other accesses the second bank. </p>

</div>
</div>
<a class="anchor" id="gae4bc67200452560b253e3f01acae9373"></a><!-- doxytag: member="Endpoint_XMEGA.h::ENDPOINT_BANK_SINGLE" ref="gae4bc67200452560b253e3f01acae9373" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ENDPOINT_BANK_SINGLE&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Mask for the bank mode selection for the <a class="el" href="group___group___endpoint_management___a_v_r8.html#ga22272fed65e01ca76a4571f9914b5fe5">Endpoint_ConfigureEndpoint()</a> macro. This indicates that the endpoint should have one single bank, which requires less USB FIFO memory but results in slower transfers as only one USB device (the AVR or the host) can access the endpoint's bank at the one time. </p>

</div>
</div>
<a class="anchor" id="ga39206fe8d12fdddec3aadc86f1018c88"></a><!-- doxytag: member="Endpoint_XMEGA.h::ENDPOINT_BANKS_SUPPORTED" ref="ga39206fe8d12fdddec3aadc86f1018c88" args="(EPIndex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ENDPOINT_BANKS_SUPPORTED</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">EPIndex</td><td>)</td>
          <td>&#160;&#160;&#160;_ENDPOINT_GET_BANKS(EPIndex)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Retrieves the total number of banks supported by the given endpoint.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This macro will only work correctly on endpoint indexes that are compile-time constants defined by the preprocessor.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">EPIndex</td><td>Endpoint number, a value between 0 and (<a class="el" href="group___group___endpoint_management___x_m_e_g_a.html#ga0aaeafaa974fb7095750a771e2adfc73">ENDPOINT_TOTAL_ENDPOINTS</a> - 1) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaebe9cfe97e9292e5e8cfba9885bbd901"></a><!-- doxytag: member="Endpoint_XMEGA.h::ENDPOINT_CONTROLEP_DEFAULT_SIZE" ref="gaebe9cfe97e9292e5e8cfba9885bbd901" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ENDPOINT_CONTROLEP_DEFAULT_SIZE&#160;&#160;&#160;8</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Default size of the default control endpoint's bank, until altered by the control endpoint bank size value in the device descriptor. Not available if the <code>FIXED_CONTROL_ENDPOINT_SIZE</code> token is defined. </p>

</div>
</div>
<a class="anchor" id="gad9e1bb9ac6153e39301490b29e77e93a"></a><!-- doxytag: member="Endpoint_XMEGA.h::ENDPOINT_MAX_SIZE" ref="gad9e1bb9ac6153e39301490b29e77e93a" args="(EPIndex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ENDPOINT_MAX_SIZE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">EPIndex</td><td>)</td>
          <td>&#160;&#160;&#160;_ENDPOINT_GET_MAXSIZE(EPIndex)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Retrieves the maximum bank size in bytes of a given endpoint.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This macro will only work correctly on endpoint indexes that are compile-time constants defined by the preprocessor.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">EPIndex</td><td>Endpoint number, a value between 0 and (<a class="el" href="group___group___endpoint_management___x_m_e_g_a.html#ga0aaeafaa974fb7095750a771e2adfc73">ENDPOINT_TOTAL_ENDPOINTS</a> - 1) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0aaeafaa974fb7095750a771e2adfc73"></a><!-- doxytag: member="Endpoint_XMEGA.h::ENDPOINT_TOTAL_ENDPOINTS" ref="ga0aaeafaa974fb7095750a771e2adfc73" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ENDPOINT_TOTAL_ENDPOINTS&#160;&#160;&#160;ENDPOINT_DETAILS_MAXEP</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Total number of endpoints (including the default control endpoint at address 0) which may be used in the device. Different USB AVR models support different amounts of endpoints, this value reflects the maximum number of endpoints for the currently selected AVR model. </p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga9e00020d1fca630c351e3b8139ba67df"></a><!-- doxytag: member="Endpoint_XMEGA.h::Endpoint_ClearStatusStage" ref="ga9e00020d1fca630c351e3b8139ba67df" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Endpoint_ClearStatusStage </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Completes the status stage of a control transfer on a CONTROL type endpoint automatically, with respect to the data direction. This is a convenience function which can be used to simplify user control request handling. </p>

</div>
</div>
<a class="anchor" id="ga22272fed65e01ca76a4571f9914b5fe5"></a><!-- doxytag: member="Endpoint_XMEGA.h::Endpoint_ConfigureEndpoint" ref="ga22272fed65e01ca76a4571f9914b5fe5" args="(const uint8_t Number, const uint8_t Type, const uint8_t Direction, const uint16_t Size, const uint8_t Banks) ATTR_ALWAYS_INLINE" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool Endpoint_ConfigureEndpoint </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>Number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>Type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>Direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>Size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>Banks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Configures the specified endpoint number with the given endpoint type, direction, bank size and banking mode. Once configured, the endpoint may be read from or written to, depending on its direction.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Number</td><td>Endpoint number to configure. This must be more than 0 and less than <a class="el" href="group___group___endpoint_management___x_m_e_g_a.html#ga0aaeafaa974fb7095750a771e2adfc73">ENDPOINT_TOTAL_ENDPOINTS</a>.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Type</td><td>Type of endpoint to configure, a <code>EP_TYPE_*</code> mask. Not all endpoint types are available on Low Speed USB devices - refer to the USB 2.0 specification.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Direction</td><td>Endpoint data direction, either <a class="el" href="group___group___u_s_b_management.html#gab011e2ee1e9f55b60cda3dbc79b95961">ENDPOINT_DIR_OUT</a> or <a class="el" href="group___group___u_s_b_management.html#gabe19393ecfcac9ea1ee8c6b3dc87830a">ENDPOINT_DIR_IN</a>. All endpoints (except Control type) are unidirectional - data may only be read from or written to the endpoint bank based on its direction, not both.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Size</td><td>Size of the endpoint's bank, where packets are stored before they are transmitted to the USB host, or after they have been received from the USB host (depending on the endpoint's data direction). The bank size must indicate the maximum packet size that the endpoint can handle.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Banks</td><td>Number of banks to use for the endpoint being configured, an <code>ENDPOINT_BANK_*</code> mask. More banks uses more USB DPRAM, but offers better performance. Isochronous type endpoints <b>must</b> have at least two banks.</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The default control endpoint should not be manually configured by the user application, as it is automatically configured by the library internally. <br/>
<br/>
</dd>
<dd>
This routine will automatically select the specified endpoint.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Boolean <code>true</code> if the configuration succeeded, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3eb31e520c947003839bfb5e1e4bf95c"></a><!-- doxytag: member="Endpoint_XMEGA.h::Endpoint_GetCurrentEndpoint" ref="ga3eb31e520c947003839bfb5e1e4bf95c" args="(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static uint8_t Endpoint_GetCurrentEndpoint </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the endpoint address of the currently selected endpoint. This is typically used to save the currently selected endpoint number so that it can be restored after another endpoint has been manipulated.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Index of the currently selected endpoint. </dd></dl>

</div>
</div>
<a class="anchor" id="gaedaf95aead8b39dcea3ed2fa52e86950"></a><!-- doxytag: member="Endpoint_XMEGA.h::Endpoint_GetEndpointDirection" ref="gaedaf95aead8b39dcea3ed2fa52e86950" args="(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static uint8_t Endpoint_GetEndpointDirection </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Determines the currently selected endpoint's direction.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The currently selected endpoint's direction, as a <code>ENDPOINT_DIR_*</code> mask. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4744236ce0d28f80c69a3225fdeabe81"></a><!-- doxytag: member="Endpoint_XMEGA.h::Endpoint_GetEndpointInterrupts" ref="ga4744236ce0d28f80c69a3225fdeabe81" args="(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static uint8_t Endpoint_GetEndpointInterrupts </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns a mask indicating which INTERRUPT type endpoints have interrupted - i.e. their interrupt duration has elapsed. Which endpoints have interrupted can be determined by masking the return value against <code>(1 &lt;&lt; <em>{Endpoint Number}</em>)</code>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Mask whose bits indicate which endpoints have interrupted. </dd></dl>

</div>
</div>
<a class="anchor" id="gadef5dafdf7515ce080f890640fe5f4ef"></a><!-- doxytag: member="Endpoint_XMEGA.h::Endpoint_HasEndpointInterrupted" ref="gadef5dafdf7515ce080f890640fe5f4ef" args="(const uint8_t EndpointNumber) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool Endpoint_HasEndpointInterrupted </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>EndpointNumber</em></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Determines if the specified endpoint number has interrupted (valid only for INTERRUPT type endpoints).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">EndpointNumber</td><td>Index of the endpoint whose interrupt flag should be tested.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Boolean <code>true</code> if the specified endpoint has interrupted, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga22dedc9265477d753e932fc805ebb91d"></a><!-- doxytag: member="Endpoint_XMEGA.h::Endpoint_IsConfigured" ref="ga22dedc9265477d753e932fc805ebb91d" args="(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool Endpoint_IsConfigured </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Determines if the currently selected endpoint is configured.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Boolean <code>true</code> if the currently selected endpoint has been configured, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0258dd64dd4215c59ce9713868f5a387"></a><!-- doxytag: member="Endpoint_XMEGA.h::Endpoint_IsEnabled" ref="ga0258dd64dd4215c59ce9713868f5a387" args="(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool Endpoint_IsEnabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Determines if the currently selected endpoint is enabled, but not necessarily configured.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Boolean <code>true</code> if the currently selected endpoint is enabled, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="gac2051cf461db29c5c73651edbe77638a"></a><!-- doxytag: member="Endpoint_XMEGA.h::Endpoint_ResetDataToggle" ref="gac2051cf461db29c5c73651edbe77638a" args="(void) ATTR_ALWAYS_INLINE" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Endpoint_ResetDataToggle </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Resets the data toggle of the currently selected endpoint. </p>

</div>
</div>
<a class="anchor" id="gaf9df3619b7c2f9b63403097f9869cd3e"></a><!-- doxytag: member="Endpoint_XMEGA.h::Endpoint_ResetEndpoint" ref="gaf9df3619b7c2f9b63403097f9869cd3e" args="(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Endpoint_ResetEndpoint </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>EndpointNumber</em></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Resets the endpoint bank FIFO. This clears all the endpoint banks and resets the USB controller's data In and Out pointers to the bank's contents.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">EndpointNumber</td><td>Endpoint number whose FIFO buffers are to be reset. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaabe158bf40f66c96a704094cfdfbbf47"></a><!-- doxytag: member="Endpoint_XMEGA.h::Endpoint_SelectEndpoint" ref="gaabe158bf40f66c96a704094cfdfbbf47" args="(const uint8_t EndpointNumber)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Endpoint_SelectEndpoint </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>EndpointNumber</em></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Selects the given endpoint number. If the address from the device descriptors is used, the value should be masked with the <a class="el" href="group___group___endpoint_management.html#ga6ee88e6fd992e2a064923871980b493d">ENDPOINT_EPNUM_MASK</a> constant to extract only the endpoint number (and discarding the endpoint direction bit).</p>
<p>Any endpoint operations which do not require the endpoint number to be indicated will operate on the currently selected endpoint.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">EndpointNumber</td><td>Endpoint number to select. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="gac1805540ce24cf3cbd621c2e0cbc1c31"></a><!-- doxytag: member="Endpoint_XMEGA.h::USB_Device_ControlEndpointSize" ref="gac1805540ce24cf3cbd621c2e0cbc1c31" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t <a class="el" href="group___group___endpoint_management___x_m_e_g_a.html#gac1805540ce24cf3cbd621c2e0cbc1c31">USB_Device_ControlEndpointSize</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Global indicating the maximum packet size of the default control endpoint located at address 0 in the device. This value is set to the value indicated in the device descriptor in the user project once the USB interface is initialized into device mode.</p>
<p>If space is an issue, it is possible to fix this to a static value by defining the control endpoint size in the <code>FIXED_CONTROL_ENDPOINT_SIZE</code> token passed to the compiler in the makefile via the -D switch. When a fixed control endpoint size is used, the size is no longer dynamically read from the descriptors at runtime and instead fixed to the given value. When used, it is important that the descriptor control endpoint size value matches the size given as the <code>FIXED_CONTROL_ENDPOINT_SIZE</code> token - it is recommended that the <code>FIXED_CONTROL_ENDPOINT_SIZE</code> token be used in the device descriptors to ensure this.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This variable should be treated as read-only in the user application, and never manually changed in value. </dd></dl>

</div>
</div>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</body><span style="margin-right: 20px; float: right;"><a href="http://www.lufa-lib.org" title="LUFA Project Page">LUFA Project Page</a> | <a href="http://www.lufa-lib.org/support" title="LUFA Support List">Support Mailing List</a> | <a href="http://www.lufa-lib.org/donate" title="Donate to Support LUFA">Donate</a> | <a href="http://www.fourwalledcubicle.com" title="Four Walled Cubicle Website">Four Walled Cubicle</a> - LUFA, the Lightweight USB Framework for AVRs</span></html>
